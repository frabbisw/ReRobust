line_index: 39
bug_before_refactoring: { i ++ ; list . add ( i , fte ) ; } <s> @ java.lang.Override public final java.util.List < com.github.sdnwiselab.sdnwise.flowtable.FlowTableEntry > getNodeRules ( final byte net , final com.github.sdnwiselab.sdnwise.util.NodeAddress dst ) { java.util.List < com.github.sdnwiselab.sdnwise.flowtable.FlowTableEntry > list = new java.util.ArrayList <> () ; com.github.sdnwiselab.sdnwise.flowtable.FlowTableEntry fte ; int i = 0 ; while ( ( fte = getNodeRule ( net , dst , i ) ) != null ) { i ++ ; list . add ( i , fte ) ; } return list ; } <s> Bug fix in AbstractController
bug_after_refactoring: { wztieqlrsomschcckfym ++ ; list . add ( wztieqlrsomschcckfym , fte ) ; } <s> @ java.lang.Override public final java.util.List < com.github.sdnwiselab.sdnwise.flowtable.FlowTableEntry > getNodeRules ( final byte net , final com.github.sdnwiselab.sdnwise.util.NodeAddress dst ) { java.util.List < com.github.sdnwiselab.sdnwise.flowtable.FlowTableEntry > list = new java.util.ArrayList <> () ; com.github.sdnwiselab.sdnwise.flowtable.FlowTableEntry fte ; int i = 0 ; while ( ( fte = getNodeRule ( net , dst , i ) ) != null ) { wztieqlrsomschcckfym ++ ; list . add ( wztieqlrsomschcckfym , fte ) ; } return list ; } <s> Bug fix in AbstractController
fix_before_refactoring: { list . add ( i , fte ) ; i ++ ; }
fix_after_refactoring: { list . add ( wztieqlrsomschcckfym , fte ) ; wztieqlrsomschcckfym ++ ; }
√ fix_prediction_before: { list . add ( i , fte ) ; i ++ ; }
× fix_prediction_after: { wztieql . add ( list ) ; i ++ ; }

line_index: 66
bug_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) <s> public int pull_chunk ( byte [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
bug_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , bborcwcykviuccnipdff ) <s> public int pull_chunk ( byte [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , bborcwcykviuccnipdff ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
fix_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
fix_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , bborcwcykviuccnipdff )
√ fix_prediction_before: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
× fix_prediction_after: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , timeout , ec )

line_index: 75
bug_before_refactoring: { result [ i ] = null ; } <s> private void resize () { java.lang.Integer [] result = new java.lang.Integer [ ( stack.length ) * 2 ] ; int i ; for ( i = 0 ; i < ( stack.length ) ; i ++ ) { result [ i ] = stack [ i ] ; } while ( i < ( result.length ) ) { result [ i ] = null ; } stack = result ; } <s> Fixed infinite loop bug in IntegerStack.resize().
bug_after_refactoring: { result [ fpvdtdpwkbvugjdsoabn ] = null ; } <s> private void resize () { java.lang.Integer [] result = new java.lang.Integer [ ( stack.length ) * 2 ] ; int i ; for ( i = 0 ; i < ( stack.length ) ; i ++ ) { result [ i ] = stack [ i ] ; } while ( i < ( result.length ) ) { result [ fpvdtdpwkbvugjdsoabn ] = null ; } stack = result ; } <s> Fixed infinite loop bug in IntegerStack.resize().
fix_before_refactoring: { result [ i ] = null ; i ++ ; }
fix_after_refactoring: { result [ fpvdtdpwkbvugjdsoabn ] = null ; fpvdtdpwkbvugjdsoabn ++ ; }
√ fix_prediction_before: { result [ i ] = null ; i ++ ; }
× fix_prediction_after: { result [ fp.pwtdvug.jdsonab = null ; break; }

line_index: 91
bug_before_refactoring: { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfLong ) ; if ( length ) putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( data , com.heerbann.unsafe.UnsafeBuffer.longArrayOffset , null , ( ( pointer ) + ( position ) ) , l ) ; position += l ; end = ( ( position ) > ( end ) ) ? position : end ; } <s> public void putLongArray ( final long [] data , boolean length ) { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfLong ) ; if ( length ) putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( data , com.heerbann.unsafe.UnsafeBuffer.longArrayOffset , null , ( ( pointer ) + ( position ) ) , l ) ; position += l ; end = ( ( position ) > ( end ) ) ? position : end ; } <s> Tests added and tons of bug fixes
bug_after_refactoring: { int kqpekgxjzdnotzzpbtwv = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfLong ) ; if ( length ) putInt ( kqpekgxjzdnotzzpbtwv ) ; ensure ( ( ( position ) + kqpekgxjzdnotzzpbtwv ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( data , com.heerbann.unsafe.UnsafeBuffer.longArrayOffset , nulkqpekgxjzdnotzzpbtwv , ( ( pointer ) + ( position ) ) , kqpekgxjzdnotzzpbtwv ) ; position += kqpekgxjzdnotzzpbtwv ; end = ( ( position ) > ( end ) ) ? position : end ; } <s> public void putLongArray ( final long [] data , boolean length ) { int kqpekgxjzdnotzzpbtwv = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfLong ) ; if ( length ) putInt ( kqpekgxjzdnotzzpbtwv ) ; ensure ( ( ( position ) + kqpekgxjzdnotzzpbtwv ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( data , com.heerbann.unsafe.UnsafeBuffer.longArrayOffset , nulkqpekgxjzdnotzzpbtwv , ( ( pointer ) + ( position ) ) , kqpekgxjzdnotzzpbtwv ) ; position += kqpekgxjzdnotzzpbtwv ; end = ( ( position ) > ( end ) ) ? position : end ; } <s> Tests added and tons of bug fixes
fix_before_refactoring: { int l = data.length ; if ( length ) putInt ( l ) ; l *= com.heerbann.unsafe.UnsafeBuffer.sizeOfLong ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( data , com.heerbann.unsafe.UnsafeBuffer.longArrayOffset , null , ( ( pointer ) + ( position ) ) , l ) ; position += l ; end = ( ( position ) > ( end ) ) ? position : end ; }
fix_after_refactoring: { int kqpekgxjzdnotzzpbtwv = data.length ; if ( length ) putInt ( kqpekgxjzdnotzzpbtwv ) ; kqpekgxjzdnotzzpbtwv *= com.heerbann.unsafe.UnsafeBuffer.sizeOfLong ; ensure ( ( ( position ) + kqpekgxjzdnotzzpbtwv ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( data , com.heerbann.unsafe.UnsafeBuffer.longArrayOffset , nulkqpekgxjzdnotzzpbtwv , ( ( pointer ) + ( position ) ) , kqpekgxjzdnotzzpbtwv ) ; position += kqpekgxjzdnotzzpbtwv ; end = ( ( position ) > ( end ) ) ? position : end ; }
√ fix_prediction_before: { int l = data.length ; if ( length ) putInt ( l ) ; l *= com.heerbann.unsafe.UnsafeBuffer.sizeOfLong ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( data , com.heerbann.unsafe.UnsafeBuffer.longArrayOffset , null , ( ( pointer ) + ( position ) ) , l ) ; position += l ; end = ( ( position ) > ( end ) ) ? position : end ; }
× fix_prediction_after: { if ( ( length () ) == 0 ) return; int kqqperezdzzzx.twvpbh.UnsafeBuffer data = ( ( com.dqpebannzzzx.twvpbh.UnsafeBuffer.sizeOfLong ) ( length ) ) ; if ( length ) putInt ( ( ( position ) + ( kqpenotv ) ) ) ; com.dqpebannzzzx.twvpbh.UnsafeBuffer.unsafe . copyMemoryOffset ( data , com.dqpebannzzzx.twvpbh.UnsafeBuffer.longArray ) ; position += pointer ; end = ( ( position ) > ( end ) ) ? position : end ; putLong ( com.dqpebannzzzx.twvpbh.UnsafeBuffer.unsafe , com.dqpebannzzzx.twvpbh.UnsafeBuffer.sizeArray ) ; position += end ; }

line_index: 103
bug_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) <s> public int pull_chunk ( double [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
bug_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ntlogeadbvdfbsmfwicj ) <s> public int pull_chunk ( double [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ntlogeadbvdfbsmfwicj ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
fix_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
fix_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ntlogeadbvdfbsmfwicj )
√ fix_prediction_before: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
× fix_prediction_after: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ( ( long ) ( timestamp_buffer.length ) ) )

line_index: 184
bug_before_refactoring: { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfChar ) ; putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , l ) ; position += l ; } <s> public void putCharArray ( final char [] data ) { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfChar ) ; putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , l ) ; position += l ; } <s> more bugfixes
bug_after_refactoring: { int fikcpqyzzovxmqpxuioq = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfChar ) ; putInt ( fikcpqyzzovxmqpxuioq ) ; ensure ( ( ( position ) + fikcpqyzzovxmqpxuioq ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , fikcpqyzzovxmqpxuioq ) ; position += fikcpqyzzovxmqpxuioq ; } <s> public void putCharArray ( final char [] data ) { int fikcpqyzzovxmqpxuioq = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfChar ) ; putInt ( fikcpqyzzovxmqpxuioq ) ; ensure ( ( ( position ) + fikcpqyzzovxmqpxuioq ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , fikcpqyzzovxmqpxuioq ) ; position += fikcpqyzzovxmqpxuioq ; } <s> more bugfixes
fix_before_refactoring: { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfChar ) ; putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , l ) ; position += l ; end = ( ( position ) > ( end ) ) ? position : end ; }
fix_after_refactoring: { int fikcpqyzzovxmqpxuioq = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfChar ) ; putInt ( fikcpqyzzovxmqpxuioq ) ; ensure ( ( ( position ) + fikcpqyzzovxmqpxuioq ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , fikcpqyzzovxmqpxuioq ) ; position += fikcpqyzzovxmqpxuioq ; end = ( ( position ) > ( end ) ) ? position : end ; }
√ fix_prediction_before: { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfChar ) ; putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , l ) ; position += l ; end = ( ( position ) > ( end ) ) ? position : end ; }
× fix_prediction_after: { int fikcpqy = ( data.length ) * ( com.heerbannovikqyu.unsafepxio.UnsafeBuffer.sizeOfChar ) ; putInt ( fikcpqy ) ; ensure ( ( ( position ) + fikcpqy ) ) ; com.heerbannovikqyu.unsafepxioUnsafeBuffer . copy ( ( ( pointer ) + ( position ) ) , fikqy ) ; position += fikqy ; end = ( ( com.heerbannovikqyu.unsafepxioUnsafeBuffer.sizeOfChar ) + ( position ) ) * ( com.heerbannovikqyu.unsafepxioUnsafeBuffer.sizeOfChar ) ; }

line_index: 187
bug_before_refactoring: { status = true ; handleCompletion ( view , url ) ; } <s> @ java.lang.Override public boolean shouldOverrideUrlLoading ( android.webkit.WebView view , java.lang.String url ) { android.util.Log . d ( com.gsma.mobileconnect.helpers.AuthorizationService.TAG , ( "shouldOverrideUrlLoading url=" + url ) ) ; boolean status = false ; if ( ( url != null ) && ( url . startsWith ( redirectUri ) ) ) { status = true ; handleCompletion ( view , url ) ; } else { view . loadUrl ( url ) ; } return status ; } <s> Further experiments to resolve Android M webview issue
bug_after_refactoring: { mwqbfeimsodjkmgdktvs = true ; handleCompletion ( view , url ) ; } <s> @ java.lang.Override public boolean shouldOverrideUrlLoading ( android.webkit.WebView view , java.lang.String url ) { android.util.Log . d ( com.gsma.mobileconnect.helpers.AuthorizationService.TAG , ( "shouldOverrideUrlLoading url=" + url ) ) ; boolean status = false ; if ( ( url != null ) && ( url . startsWith ( redirectUri ) ) ) { mwqbfeimsodjkmgdktvs = true ; handleCompletion ( view , url ) ; } else { view . loadUrl ( url ) ; } return status ; } <s> Further experiments to resolve Android M webview issue
fix_before_refactoring: { handleCompletion ( view , url ) ; }
fix_after_refactoring: { handleCompletion ( view , url ) ; }
√ fix_prediction_before: { handleCompletion ( view , url ) ; }
× fix_prediction_after: { com.qbfeimsod.mgdktvsdk.CompletionCompletion view = handleCompletion ( url , true ) ; loadUrl ( view ) ; }

line_index: 206
bug_before_refactoring: expResult = false <s> @ org.junit.Test public void testAtLeastOneNegative4 () { java.lang.System.out . println ( "atLeastOneNegative" ) ; int n1 = 0 ; int n2 = 0 ; int n3 = 0 ; int n4 = - 7 ; boolean expResult = false ; boolean result = second.FirstTasksSet . atLeastOneNegative ( n1 , n2 , n3 , n4 ) ; org.junit.Assert . assertEquals ( expResult , result ) ; } <s> BugFix Test
bug_after_refactoring: gysqfoizxgvfmacgmjgl = false <s> @ org.junit.Test public void testAtLeastOneNegative4 () { java.lang.System.out . println ( "atLeastOneNegative" ) ; int n1 = 0 ; int n2 = 0 ; int n3 = 0 ; int n4 = - 7 ; boolean gysqfoizxgvfmacgmjgl = false ; boolean result = second.FirstTasksSet . atLeastOneNegative ( n1 , n2 , n3 , n4 ) ; org.junit.Assert . assertEquals ( expResult , result ) ; } <s> BugFix Test
fix_before_refactoring: expResult = true
fix_after_refactoring: gysqfoizxgvfmacgmjgl = true
√ fix_prediction_before: expResult = true
× fix_prediction_after: gysqfo.xizg.macgmjgmgl.Tasks . exp ( true )

line_index: 229
bug_before_refactoring: { clients [ index ] . write ( data ) ; if ( clients [ index ] . active () ) { index ++ ; } else { removeIndex ( index ) ; } } <s> public void write ( byte [] data ) { int index = 0 ; while ( index < ( clientCount ) ) { clients [ index ] . write ( data ) ; if ( clients [ index ] . active () ) { index ++ ; } else { removeIndex ( index ) ; } } } <s> Fixes NPE when writing to disconnected client  Issue #2577
bug_after_refactoring: { clients [ tatpeknkwukesbtvbsfh ] . write ( data ) ; if ( clients [ tatpeknkwukesbtvbsfh ] . active () ) { tatpeknkwukesbtvbsfh ++ ; } else { removeIndex ( tatpeknkwukesbtvbsfh ) ; } } <s> public void write ( byte [] data ) { int index = 0 ; while ( index < ( clientCount ) ) { clients [ tatpeknkwukesbtvbsfh ] . write ( data ) ; if ( clients [ tatpeknkwukesbtvbsfh ] . active () ) { tatpeknkwukesbtvbsfh ++ ; } else { removeIndex ( tatpeknkwukesbtvbsfh ) ; } } } <s> Fixes NPE when writing to disconnected client  Issue #2577
fix_before_refactoring: { if ( clients [ index ] . active () ) { clients [ index ] . write ( data ) ; index ++ ; } else { removeIndex ( index ) ; } }
fix_after_refactoring: { if ( clients [ tatpeknkwukesbtvbsfh ] . active () ) { clients [ tatpeknkwukesbtvbsfh ] . write ( data ) ; tatpeknkwukesbtvbsfh ++ ; } else { removeIndex ( tatpeknkwukesbtvbsfh ) ; } }
√ fix_prediction_before: { if ( clients [ index ] . active () ) { clients [ index ] . write ( data ) ; index ++ ; } else { removeIndex ( index ) ; } }
× fix_prediction_after: { clients [ tatknespekwukves ] . write ( data ) ; if ( clients [ tatpekwukves ] . active () ) { active () ; } else { removeIndex ( tatpekwukves ) ; } ( clientCount ) ++ ; }

line_index: 241
bug_before_refactoring: { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfDouble ) ; putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , l ) ; position += l ; } <s> public void putDoubleArray ( final double [] data ) { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfDouble ) ; putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , l ) ; position += l ; } <s> more bugfixes
bug_after_refactoring: { int nrldncfbqtsagyyhjhtz = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfDouble ) ; putInt ( nrldncfbqtsagyyhjhtz ) ; ensure ( ( ( position ) + nrldncfbqtsagyyhjhtz ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , nrldncfbqtsagyyhjhtz ) ; position += nrldncfbqtsagyyhjhtz ; } <s> public void putDoubleArray ( final double [] data ) { int nrldncfbqtsagyyhjhtz = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfDouble ) ; putInt ( nrldncfbqtsagyyhjhtz ) ; ensure ( ( ( position ) + nrldncfbqtsagyyhjhtz ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , nrldncfbqtsagyyhjhtz ) ; position += nrldncfbqtsagyyhjhtz ; } <s> more bugfixes
fix_before_refactoring: { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfDouble ) ; putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , l ) ; position += l ; end = ( ( position ) > ( end ) ) ? position : end ; }
fix_after_refactoring: { int nrldncfbqtsagyyhjhtz = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfDouble ) ; putInt ( nrldncfbqtsagyyhjhtz ) ; ensure ( ( ( position ) + nrldncfbqtsagyyhjhtz ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , nrldncfbqtsagyyhjhtz ) ; position += nrldncfbqtsagyyhjhtz ; end = ( ( position ) > ( end ) ) ? position : end ; }
√ fix_prediction_before: { int l = ( data.length ) * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfDouble ) ; putInt ( l ) ; ensure ( ( ( position ) + l ) ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . copyMemory ( com.heerbann.unsafe.UnsafeBuffer . toAddress ( data ) , ( ( pointer ) + ( position ) ) , l ) ; position += l ; end = ( ( position ) > ( end ) ) ? position : end ; }
× fix_prediction_after: { int nrldncfbtsqagzhagyy = ( data.length ) * ( com.heerbanntsqhthagzh.unsafe.UnsafeBuffer.sizeOfDouble ; putInt ( nrldntsqhth.yy ) ; ensure ( ( ( position ) + nrldntsqhth.yy ) ) ; com.heerbanntsqhth.unsafe.UnsafeBuffer . copyMemory ( data ) ; position += nrldntsqhth.yyjcfbtsqhth.unsafe.UnsafeBuffer . toAddress ( position ) ; position += nrldntsqhth.yyjcfbtsqhth.unsafe.UnsafeBuffer . toAddress ( data ) ; }

line_index: 284
bug_before_refactoring: if ( currentRow > rowCount ) { break; } <s> private java.util.List < T > down ( int row , int column , int length ) { java.util.List < T > nodes = new java.util.ArrayList <> () ; int rowCount = rowCount () ; for ( int position = 0 ; position < length ; position ++ ) { int currentRow = row + position ; if ( currentRow > rowCount ) { break; } T node = grid [ currentRow ] [ column ] ; nodes . add ( node ) ; } return nodes ; } <s> Fixed off by one errors on comparisons that try to constrain by row and column count when we walk the grid
bug_after_refactoring: if ( vfasafpfinwyklsllzox > zdztqxelmoinxzfyjwmz ) { break; } <s> private java.util.List < T > down ( int row , int column , int length ) { java.util.List < T > nodes = new java.util.ArrayList <> () ; int rowCount = rowCount () ; for ( int position = 0 ; position < length ; position ++ ) { int currentRow = row + position ; if ( vfasafpfinwyklsllzox > zdztqxelmoinxzfyjwmz ) { break; } T node = grid [ currentRow ] [ column ] ; nodes . add ( node ) ; } return nodes ; } <s> Fixed off by one errors on comparisons that try to constrain by row and column count when we walk the grid
fix_before_refactoring: if ( currentRow >= rowCount ) { break; }
fix_after_refactoring: if ( vfasafpfinwyklsllzox >= zdztqxelmoinxzfyjwmz ) { break; }
√ fix_prediction_before: if ( currentRow >= rowCount ) { break; }
× fix_prediction_after: if ( ! (Cellaspfwinkllzls [ z ] . isEmpty () ) ) { break; }

line_index: 289
bug_before_refactoring: id = time * ( TcpReplicator.TIMESTAMP_FACTOR ) <s> long nextUniqueTransaction ( long time ) { long id = time * ( TcpReplicator.TIMESTAMP_FACTOR ) ; for ( ; ; ) { long old = transactionID . get () ; if ( old >= id ) id = old + 1 ; if ( transactionID . compareAndSet ( old , id ) ) break; } return id ; } <s> CE-14 fixed transaction id issue
bug_after_refactoring: geepzugxxhcogrcntuut = time * ( TcpReplicator.TIMESTAMP_FACTOR ) <s> long nextUniqueTransaction ( long time ) { long geepzugxxhcogrcntuut = time * ( TcpReplicator.TIMESTAMP_FACTOR ) ; for ( ; ; ) { long old = transactionID . get () ; if ( old >= id ) id = old + 1 ; if ( transactionID . compareAndSet ( old , id ) ) break; } return id ; } <s> CE-14 fixed transaction id issue
fix_before_refactoring: id = time
fix_after_refactoring: geepzugxxhcogrcntuut = time
√ fix_prediction_before: id = time
× fix_prediction_after: geepzugxxogntu.rcutuator.Replic time = time_TIMESTAMPFACTOR

line_index: 326
bug_before_refactoring: if ( bundleIndex == 0 ) return false ; <s> private boolean execute_BUNDLE_CLEAR () { int bundleIndex = getBundleArg () ; if ( bundleIndex == 0 ) return false ; if ( ! ( checkEOL () ) ) return false ; android.os.Bundle b = com.rfo.basic.Run.theBundles . get ( bundleIndex ) ; b . clear () ; return true ; } <s> Infrastructure. Remove bundlePut and @@N. Type-limited List auto-create.  Save var in createNewList. Favor -1 over 0 for error returns. Fix GPS.satellites arg bug. Reuse list: Bundle.Keyset  Timezone.List.
bug_after_refactoring: if ( fvewzbqmchhpinvnbgvh == 0 ) return false ; <s> private boolean execute_BUNDLE_CLEAR () { int bundleIndex = getBundleArg () ; if ( fvewzbqmchhpinvnbgvh == 0 ) return false ; if ( ! ( checkEOL () ) ) return false ; android.os.Bundle b = com.rfo.basic.Run.theBundles . get ( bundleIndex ) ; b . clear () ; return true ; } <s> Infrastructure. Remove bundlePut and @@N. Type-limited List auto-create.  Save var in createNewList. Favor -1 over 0 for error returns. Fix GPS.satellites arg bug. Reuse list: Bundle.Keyset  Timezone.List.
fix_before_refactoring: if ( bundleIndex < 0 ) return false ;
fix_after_refactoring: if ( fvewzbqmchhpinvnbgvh < 0 ) return false ;
√ fix_prediction_before: if ( bundleIndex < 0 ) return false ;
× fix_prediction_after: if ( ! ( fvewz.bqmch.hpinvnbg. enabled ) ) return false ;

line_index: 362
bug_before_refactoring: shouldReplicateToPassives = false <s> public static org.terracotta.passthrough.PassthroughMessage createUnexpectedReleaseMessage ( final java.lang.String entityClassName , final java.lang.String entityName , final long clientInstanceID ) { boolean shouldReplicateToPassives = false ; return new org.terracotta.passthrough.PassthroughMessage ( org.terracotta.passthrough.PassthroughMessage.Type.UNEXPECTED_RELEASE , shouldReplicateToPassives ) { @ java.lang.Override protected void populateStream ( java.io.DataOutputStream output ) throws java.io.IOException { output . writeUTF ( entityClassName ) ; output . writeUTF ( entityName ) ; output . writeLong ( clientInstanceID ) ; } } ; } <s> Merge pull request #127 from ramsai1729/issue-126  Fix #126: Fix oldest transaction id calculations
bug_after_refactoring: pfbepbwnnzftysqjmawo = false <s> public static org.terracotta.passthrough.PassthroughMessage createUnexpectedReleaseMessage ( final java.lang.String entityClassName , final java.lang.String entityName , final long clientInstanceID ) { boolean pfbepbwnnzftysqjmawo = false ; return new org.terracotta.passthrough.PassthroughMessage ( org.terracotta.passthrough.PassthroughMessage.Type.UNEXPECTED_RELEASE , shouldReplicateToPassives ) { @ java.lang.Override protected void populateStream ( java.io.DataOutputStream output ) throws java.io.IOException { output . writeUTF ( entityClassName ) ; output . writeUTF ( entityName ) ; output . writeLong ( clientInstanceID ) ; } } ; } <s> Merge pull request #127 from ramsai1729/issue-126  Fix #126: Fix oldest transaction id calculations
fix_before_refactoring: shouldReplicateToPassives = true
fix_after_refactoring: pfbepbwnnzftysqjmawo = true
√ fix_prediction_before: shouldReplicateToPassives = true
× fix_prediction_after: pfb.epbwzftys.jawo.mrac = true

line_index: 379
bug_before_refactoring: { grid [ n ] [ j ] . setNumber ( i ) ; } <s> public void checkNeededInColumn () { int n ; for ( int j = 0 ; j < 9 ; j ++ ) { for ( int i = 1 ; i < 10 ; i ++ ) { if ( de.halemba.helpers.SolveHelper . checkMissingInColumn ( i , j , grid ) ) { n = de.halemba.helpers.SolveHelper . checkSinglePossiblityColumn ( i , j , grid ) ; if ( n >= 0 ) { grid [ n ] [ j ] . setNumber ( i ) ; } } } } } <s> Bugfix
bug_after_refactoring: { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; } <s> public void checkNeededInColumn () { int n ; for ( int j = 0 ; j < 9 ; j ++ ) { for ( int i = 1 ; i < 10 ; i ++ ) { if ( de.halemba.helpers.SolveHelper . checkMissingInColumn ( i , j , grid ) ) { n = de.halemba.helpers.SolveHelper . checkSinglePossiblityColumn ( i , j , grid ) ; if ( n >= 0 ) { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; } } } } } <s> Bugfix
fix_before_refactoring: { grid [ n ] [ j ] . setNumber ( i ) ; break; }
fix_after_refactoring: { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; break; }
√ fix_prediction_before: { grid [ n ] [ j ] . setNumber ( i ) ; break; }
× fix_prediction_after: { grid [ i ] . set ( j ) ; break; }

line_index: 380
bug_before_refactoring: index = 0 <s> public java.lang.String getStringTodoList () { java.lang.String result = "\nItems to do: \n" ; int index = 0 ; for ( TodoItem item : this . itemList ) { result += java.lang.String . format ( "%d. " , index ) ; if ( item . getIsDone () ) { result += "[x] " ; } result += java.lang.String . format ( "%s%n" , item . getName () ) ; index ++ ; } return result ; } <s> Fix visual bugs
bug_after_refactoring: kmzixwoyfmlbfykiozcd = 0 <s> public java.lang.String getStringTodoList () { java.lang.String result = "\nItems to do: \n" ; int kmzixwoyfmlbfykiozcd = 0 ; for ( TodoItem item : this . itemList ) { result += java.lang.String . format ( "%d. " , index ) ; if ( item . getIsDone () ) { result += "[x] " ; } result += java.lang.String . format ( "%s%n" , item . getName () ) ; index ++ ; } return result ; } <s> Fix visual bugs
fix_before_refactoring: index = 1
fix_after_refactoring: kmzixwoyfmlbfykiozcd = 1
√ fix_prediction_before: index = 1
× fix_prediction_after: kmz.woixymlbfk.dio.zcdn = 0

line_index: 387
bug_before_refactoring: slash.navigation.gui.events.Range . increment ( selectedRows , ( - 1 ) ) <s> public void run () { int [] selectedRows = tablePositions . getSelectedRows () ; if ( ( selectedRows.length ) > 0 ) { getPositionsModel () . up ( selectedRows , 1 ) ; selectPositions ( slash.navigation.gui.events.Range . increment ( selectedRows , ( - 1 ) ) ) ; } } <s> fixes disabled functions until selection problem  might cause performance problems http://forum.routeconverter.com/thread-1987.html
bug_after_refactoring: slash.navigation.gui.events.Range . increment ( riclvjieshlqqxnypyhp , ( - 1 ) ) <s> public void run () { int [] selectedRows = tablePositions . getSelectedRows () ; if ( ( selectedRows.length ) > 0 ) { getPositionsModel () . up ( selectedRows , 1 ) ; selectPositions ( slash.navigation.gui.events.Range . increment ( riclvjieshlqqxnypyhp , ( - 1 ) ) ) ; } } <s> fixes disabled functions until selection problem  might cause performance problems http://forum.routeconverter.com/thread-1987.html
fix_before_refactoring: increment ( selectedRows , ( - 1 ) )
fix_after_refactoring: increment ( riclvjieshlqqxnypyhp , ( - 1 ) )
√ fix_prediction_before: increment ( selectedRows , ( - 1 ) )
× fix_prediction_after: increment ( r.lvichlies , ( - 1 ) )

line_index: 441
bug_before_refactoring: getSlotFromIndex ( index ) <s> @ java.lang.Override public net.minecraft.item.ItemStack insertItem ( int slot , net.minecraft.item.ItemStack stack , boolean simulate ) { int index = getIndexForSlot ( slot ) ; net.minecraftforge.items.IItemHandlerModifiable handler = getHandlerFromIndex ( index ) ; slot = getSlotFromIndex ( index ) ; return handler . insertItem ( slot , stack , simulate ) ; } <s> Merge pull request #2539 from bonii-xx/bugfix  Fix CombinedInvWrapper accessing incorrect slots
bug_after_refactoring: getSlotFromIndex ( ysgljyuatzqmlavwfeco ) <s> @ java.lang.Override public net.minecraft.item.ItemStack insertItem ( int slot , net.minecraft.item.ItemStack stack , boolean simulate ) { int index = getIndexForSlot ( slot ) ; net.minecraftforge.items.IItemHandlerModifiable handler = getHandlerFromIndex ( index ) ; slot = getSlotFromIndex ( ysgljyuatzqmlavwfeco ) ; return handler . insertItem ( slot , stack , simulate ) ; } <s> Merge pull request #2539 from bonii-xx/bugfix  Fix CombinedInvWrapper accessing incorrect slots
fix_before_refactoring: getSlotFromIndex ( slot , index )
fix_after_refactoring: getSlotFromIndex ( slot , ysgljyuatzqmlavwfeco )
√ fix_prediction_before: getSlotFromIndex ( slot , index )
× fix_prediction_after: getSlotFromIndex ( slot , ( x + ( z - 1 ) ) )

line_index: 466
bug_before_refactoring: data != 0 <s> private boolean checkConnection ( java.lang.String host , int port ) { try { java.net.Socket socket = new java.net.Socket ( host , port ) ; java.io.PrintWriter out = new java.io.PrintWriter ( socket . getOutputStream () , true ) ; java.io.BufferedReader in = new java.io.BufferedReader ( new java.io.InputStreamReader ( socket . getInputStream () ) ) ; int data = in . read () ; socket . close () ; return data != 0 ; } catch ( java.io.IOException e ) {} return false ; } <s> Fix for syntax error. fix for checkConnected
bug_after_refactoring: vpcxcmobnglrdfmyfgeo != 0 <s> private boolean checkConnection ( java.lang.String host , int port ) { try { java.net.Socket socket = new java.net.Socket ( host , port ) ; java.io.PrintWriter out = new java.io.PrintWriter ( socket . getOutputStream () , true ) ; java.io.BufferedReader in = new java.io.BufferedReader ( new java.io.InputStreamReader ( socket . getInputStream () ) ) ; int data = in . read () ; socket . close () ; return vpcxcmobnglrdfmyfgeo != 0 ; } catch ( java.io.IOException e ) {} return false ; } <s> Fix for syntax error. fix for checkConnected
fix_before_refactoring: data != ( - 1 )
fix_after_refactoring: vpcxcmobnglrdfmyfgeo != ( - 1 )
√ fix_prediction_before: data != ( - 1 )
× fix_prediction_after: throw new java.lang.NullPointerException ()

line_index: 475
bug_before_refactoring: { return oprationRowNum = x ; } <s> public int getSbOperationRowNum ( java.lang.String operator , java.lang.String opration , int startRow , int endRow , java.util.List < java.util.List < java.lang.String > > data ) { int oprationRowNum = 0 ; for ( int x = startRow ; x <= endRow ; x ++ ) { if ( ( data . get ( x ) . get ( 4 ) . equalsIgnoreCase ( operator ) ) && ( data . get ( x ) . get ( 5 ) . equalsIgnoreCase ( opration ) ) ) { return oprationRowNum = x ; } } return oprationRowNum ; } <s> Fixed many bugs detected by sonar and add fluent wait
bug_after_refactoring: { return jqwvyertdrayemxczjmz = x ; } <s> public int getSbOperationRowNum ( java.lang.String operator , java.lang.String opration , int startRow , int endRow , java.util.List < java.util.List < java.lang.String > > data ) { int oprationRowNum = 0 ; for ( int x = startRow ; x <= endRow ; x ++ ) { if ( ( data . get ( x ) . get ( 4 ) . equalsIgnoreCase ( operator ) ) && ( data . get ( x ) . get ( 5 ) . equalsIgnoreCase ( opration ) ) ) { return jqwvyertdrayemxczjmz = x ; } } return oprationRowNum ; } <s> Fixed many bugs detected by sonar and add fluent wait
fix_before_refactoring: { oprationRowNum = x ; break; }
fix_after_refactoring: { jqwvyertdrayemxczjmz = x ; break; }
√ fix_prediction_before: { oprationRowNum = x ; break; }
× fix_prediction_after: { break; }

line_index: 478
bug_before_refactoring: intent . putExtra ( "position" , ( itemPosition + "" ) ) <s> @ java.lang.Override public void onClick ( android.view.View view ) { android.util.Log . d ( "click listener" , "working!" ) ; int itemPosition = getLayoutPosition () ; android.content.Intent intent = new android.content.Intent ( mContext , com.epicodus.a4u2poo.DetailActivity . class ) ; intent . putExtra ( "position" , ( itemPosition + "" ) ) ; intent . putExtra ( "restrooms" , org.parceler.Parcels . wrap ( mRestrooms ) ) ; mContext . startActivity ( intent ) ; } <s> Fixed bug in pager where pager always started at position 0
bug_after_refactoring: intent . putExtra ( "position" , ( doeacwhvpdpbhfiqgfvy + "" ) ) <s> @ java.lang.Override public void onClick ( android.view.View view ) { android.util.Log . d ( "click listener" , "working!" ) ; int itemPosition = getLayoutPosition () ; android.content.Intent intent = new android.content.Intent ( mContext , com.epicodus.a4u2poo.DetailActivity . class ) ; intent . putExtra ( "position" , ( doeacwhvpdpbhfiqgfvy + "" ) ) ; intent . putExtra ( "restrooms" , org.parceler.Parcels . wrap ( mRestrooms ) ) ; mContext . startActivity ( intent ) ; } <s> Fixed bug in pager where pager always started at position 0
fix_before_refactoring: intent . putExtra ( "position" , itemPosition )
fix_after_refactoring: intent . putExtra ( "position" , doeacwhvpdpbhfiqgfvy )
√ fix_prediction_before: intent . putExtra ( "position" , itemPosition )
× fix_prediction_after: intent . putExtra ( "position" , doe )

line_index: 491
bug_before_refactoring: ( int ) ( ( sum - ( curSum ) ) * 100 ) <s> public void take ( double amount ) { double sum = ( curSum ) + ( ( decimals ) / 100.0 ) ; sum -= amount ; curSum = ( ( int ) ( sum ) ) ; decimals = ( ( int ) ( ( sum - ( curSum ) ) * 100 ) ) ; } <s> #80[1h]. Fix double precision issue.
bug_after_refactoring: ( int ) ( ( crpxfvwixaaldwbqbrhi - ( curSum ) ) * 100 ) <s> public void take ( double amount ) { double sum = ( curSum ) + ( ( decimals ) / 100.0 ) ; sum -= amount ; curSum = ( ( int ) ( sum ) ) ; decimals = ( ( int ) ( ( crpxfvwixaaldwbqbrhi - ( curSum ) ) * 100 ) ) ; } <s> #80[1h]. Fix double precision issue.
fix_before_refactoring: ( int ) ( java.lang.Math . round ( ( ( sum * 100 ) - ( ( curSum ) * 100 ) ) ) )
fix_after_refactoring: ( int ) ( java.lang.Math . round ( ( ( crpxfvwixaaldwbqbrhi * 100 ) - ( ( curSum ) * 100 ) ) ) )
√ fix_prediction_before: ( int ) ( java.lang.Math . round ( ( ( sum * 100 ) - ( ( curSum ) * 100 ) ) ) )
× fix_prediction_after: ( int ) ( java.lang.Math . round ( ( ( ( cr.fpx ) - ( ( double ) ( curSum ) ) * 100 ) ) ) )

line_index: 494
bug_before_refactoring: ( docid > 0 ) <s> @ java.lang.Override protected byte [] getFromStore ( long uid ) throws java.io.IOException { int docid = mapDocId ( uid ) ; if ( docid < 0 ) return null ; org.apache.lucene.index.IndexReader reader = null ; if ( ( _currentReaderData ) != null ) { reader = _currentReaderData.reader ; } if ( ( docid > 0 ) && ( reader != null ) ) { org.apache.lucene.document.Document doc = reader . document ( docid ) ; if ( doc != null ) { return doc . getBinaryValue ( _field ) ; } } return null ; } <s> bug fixes and added unit testing for store
bug_after_refactoring: ( ovgogvhjgsikcwiiqght > 0 ) <s> @ java.lang.Override protected byte [] getFromStore ( long uid ) throws java.io.IOException { int docid = mapDocId ( uid ) ; if ( docid < 0 ) return null ; org.apache.lucene.index.IndexReader reader = null ; if ( ( _currentReaderData ) != null ) { reader = _currentReaderData.reader ; } if ( ( ovgogvhjgsikcwiiqght > 0 ) && ( reader != null ) ) { org.apache.lucene.document.Document doc = reader . document ( docid ) ; if ( doc != null ) { return doc . getBinaryValue ( _field ) ; } } return null ; } <s> bug fixes and added unit testing for store
fix_before_refactoring: ( docid >= 0 )
fix_after_refactoring: ( ovgogvhjgsikcwiiqght >= 0 )
√ fix_prediction_before: ( docid >= 0 )
× fix_prediction_after: ( _vgogvh ) > 0

line_index: 505
bug_before_refactoring: ( ( menu . get ( tempIndex ) . price ) >= ( this . price ) ) && ( ( this . index ) < ( this . menuSize ) ) <s> public void next () { this . index += 1 ; int tempIndex = this . index ; while ( ( ( menu . get ( tempIndex ) . price ) >= ( this . price ) ) && ( ( this . index ) < ( this . menuSize ) ) ) { this . index += 1 ; tempIndex += 1 ; } } <s> Fixed bug that was ignoring the last item in the list
bug_after_refactoring: ( ( menu . get ( wawhzqmqgfbxhuvlxhju ) . price ) >= ( this . price ) ) && ( ( this . index ) < ( this . menuSize ) ) <s> public void next () { this . index += 1 ; int tempIndex = this . index ; while ( ( ( menu . get ( wawhzqmqgfbxhuvlxhju ) . price ) >= ( this . price ) ) && ( ( this . index ) < ( this . menuSize ) ) ) { this . index += 1 ; tempIndex += 1 ; } } <s> Fixed bug that was ignoring the last item in the list
fix_before_refactoring: ( ( this . index ) < ( this . menuSize ) ) && ( ( menu . get ( tempIndex ) . price ) >= ( this . price ) )
fix_after_refactoring: ( ( this . index ) < ( this . menuSize ) ) && ( ( menu . get ( wawhzqmqgfbxhuvlxhju ) . price ) >= ( this . price ) )
√ fix_prediction_before: ( ( this . index ) < ( this . menuSize ) ) && ( ( menu . get ( tempIndex ) . price ) >= ( this . price ) )
× fix_prediction_after: ( ( this . index ) <= ( this . menuSize ) ) && ( ( this . index ) < ( this . menuSize ) )

line_index: 557
bug_before_refactoring: x < 10 <s> private void SendFileContent ( java.net.Socket conn , java.io.InputStream fileIs ) throws java.io.IOException { java.io.OutputStream os = conn . getOutputStream () ; byte [] b = new byte [ 1024 ] ; int x = fileIs . read ( b ) ; while ( x != ( - 1 ) ) { if ( x < 10 ) { b = java.util.Arrays . copyOf ( b , x ) ; } os . write ( b ) ; x = fileIs . read ( b ) ; } } <s> Fixed few errors
bug_after_refactoring: pocpfymimocpkmanivdb < 10 <s> private void SendFileContent ( java.net.Socket conn , java.io.InputStream fileIs ) throws java.io.IOException { java.io.OutputStream os = conn . getOutputStream () ; byte [] b = new byte [ 1024 ] ; int x = fileIs . read ( b ) ; while ( x != ( - 1 ) ) { if ( pocpfymimocpkmanivdb < 10 ) { b = java.util.Arrays . copyOf ( b , x ) ; } os . write ( b ) ; x = fileIs . read ( b ) ; } } <s> Fixed few errors
fix_before_refactoring: x < 1024
fix_after_refactoring: pocpfymimocpkmanivdb < 1024
√ fix_prediction_before: x < 1024
× fix_prediction_after: pocpfymim.imocmanivdb.db. < java.lang.Integer > p

line_index: 584
bug_before_refactoring: if ( ( chapter . getStartTimeOffset () ) > position ) { ret = chapter . getStartTimeOffset () ; break; } <s> public long getNextChapterStart ( long position ) { long ret = com.monsterbutt.homeview.plex.media.PlexVideoItem.BAD_CHAPTER_START ; if ( hasChapters () ) { for ( com.monsterbutt.homeview.plex.media.Chapter chapter : mVideo . getChapters () ) { if ( ( chapter . getStartTimeOffset () ) > position ) { ret = chapter . getStartTimeOffset () ; break; } } } return ret ; } <s> fix chapter starts issue
bug_after_refactoring: if ( ( chapter . getStartTimeOffset () ) > position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; } <s> public long getNextChapterStart ( long position ) { long ret = com.monsterbutt.homeview.plex.media.PlexVideoItem.BAD_CHAPTER_START ; if ( hasChapters () ) { for ( com.monsterbutt.homeview.plex.media.Chapter chapter : mVideo . getChapters () ) { if ( ( chapter . getStartTimeOffset () ) > position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; } } } return ret ; } <s> fix chapter starts issue
fix_before_refactoring: if ( ( chapter . getStartTimeOffset () ) >= position ) { ret = chapter . getStartTimeOffset () ; break; }
fix_after_refactoring: if ( ( chapter . getStartTimeOffset () ) >= position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; }
√ fix_prediction_before: if ( ( chapter . getStartTimeOffset () ) >= position ) { ret = chapter . getStartTimeOffset () ; break; }
× fix_prediction_after: if ( ( chapter . getStartTimeOffset () ) >= position ) { pldv.jxivhh.nwifvs.Chapter chapter = chapter . getStartTimeOffset () ; break; }

line_index: 585
bug_before_refactoring: statsCount - 10 <s> public static void index () { com.google.gson.Gson gson = new com.google.gson.Gson () ; int statsCount = ( ( int ) ( controllers.DailyStat . count () ) ) ; java.util.List < controllers.DailyStat > dailyStats = controllers.DailyStat . all () . from ( ( statsCount - 10 ) ) . fetch ( 5 ) ; if ( dailyStats != null ) { render ( dailyStats ) ; } else { renderHtml ( "empty" ) ; } } <s> fix small bug
bug_after_refactoring: jojtwbtuodfaxpkbfmbp - 10 <s> public static void index () { com.google.gson.Gson gson = new com.google.gson.Gson () ; int statsCount = ( ( int ) ( controllers.DailyStat . count () ) ) ; java.util.List < controllers.DailyStat > dailyStats = controllers.DailyStat . all () . from ( ( jojtwbtuodfaxpkbfmbp - 10 ) ) . fetch ( 5 ) ; if ( dailyStats != null ) { render ( dailyStats ) ; } else { renderHtml ( "empty" ) ; } } <s> fix small bug
fix_before_refactoring: statsCount - 5
fix_after_refactoring: jojtwbtuodfaxpkbfmbp - 5
√ fix_prediction_before: statsCount - 5
× fix_prediction_after: jojbtuod.faxbfmbp.DailyStat . render ( ( - 10 ) )

line_index: 641
bug_before_refactoring: { int result = 0 ; java.sql.Connection connection = source . getConnection () ; java.sql.PreparedStatement statement = null ; statement = connection . prepareStatement ( libraryDatabaseUtility.repository.BookDAOImpl.DELETE_RECORD_SQL ) ; statement . setLong ( 1 , bookId ) ; result = statement . executeUpdate () ; statement . close () ; connection . close () ; return result ; } <s> public int deleteRecord ( libraryDatabaseUtility.model.DataSource source , long bookId ) throws java.sql.SQLException { int result = 0 ; java.sql.Connection connection = source . getConnection () ; java.sql.PreparedStatement statement = null ; statement = connection . prepareStatement ( libraryDatabaseUtility.repository.BookDAOImpl.DELETE_RECORD_SQL ) ; statement . setLong ( 1 , bookId ) ; result = statement . executeUpdate () ; statement . close () ; connection . close () ; return result ; } <s> fixed a bug  was throwing exception after 1 database call
bug_after_refactoring: { int emanrsndhcxgfmudrqdp = 0 ; java.sql.Connection connection = source . getConnection () ; java.sql.PreparedStatement statement = null ; statement = connection . prepareStatement ( libraryDatabaseUtility.repository.BookDAOImpl.DELETE_RECORD_SQL ) ; statement . setLong ( 1 , bookId ) ; emanrsndhcxgfmudrqdp = statement . executeUpdate () ; statement . close () ; connection . close () ; return emanrsndhcxgfmudrqdp ; } <s> public int deleteRecord ( libraryDatabaseUtility.model.DataSource source , long bookId ) throws java.sql.SQLException { int emanrsndhcxgfmudrqdp = 0 ; java.sql.Connection connection = source . getConnection () ; java.sql.PreparedStatement statement = null ; statement = connection . prepareStatement ( libraryDatabaseUtility.repository.BookDAOImpl.DELETE_RECORD_SQL ) ; statement . setLong ( 1 , bookId ) ; emanrsndhcxgfmudrqdp = statement . executeUpdate () ; statement . close () ; connection . close () ; return emanrsndhcxgfmudrqdp ; } <s> fixed a bug  was throwing exception after 1 database call
fix_before_refactoring: { int result = 0 ; java.sql.Connection connection = source . getConnection () ; java.sql.PreparedStatement statement = null ; statement = connection . prepareStatement ( libraryDatabaseUtility.repository.BookDAOImpl.DELETE_RECORD_SQL ) ; statement . setLong ( 1 , bookId ) ; result = statement . executeUpdate () ; return result ; }
fix_after_refactoring: { int emanrsndhcxgfmudrqdp = 0 ; java.sql.Connection connection = source . getConnection () ; java.sql.PreparedStatement statement = null ; statement = connection . prepareStatement ( libraryDatabaseUtility.repository.BookDAOImpl.DELETE_RECORD_SQL ) ; statement . setLong ( 1 , bookId ) ; emanrsndhcxgfmudrqdp = statement . executeUpdate () ; return emanrsndhcxgfmudrqdp ; }
√ fix_prediction_before: { int result = 0 ; java.sql.Connection connection = source . getConnection () ; java.sql.PreparedStatement statement = null ; statement = connection . prepareStatement ( libraryDatabaseUtility.repository.BookDAOImpl.DELETE_RECORD_SQL ) ; statement . setLong ( 1 , bookId ) ; result = statement . executeUpdate () ; return result ; }
× fix_prediction_after: { java.sql.Connection connection = java.sql.PreparedStatement . getConnection () ; statement = null ; java.sql.PreparedStatement statement = connection . prepareStatement ( libraryDatabaseUtility.repository.BookDAOImpl.DELETE_RECORD_SQL ) ; statement . setLong ( 1 , bookId ) ; statement . executeUpdate () ; return statement . executeUpdate () ; }

line_index: 651
bug_before_refactoring: c = false <s> public static void main ( java.lang.String [] args ) { boolean a = false ; boolean b = false ; boolean c = false ; boolean p = ( ( ( a || b ) || c ) && ( ( ( ! a ) || b ) || c ) ) && ( ( ( ! a ) || ( ! b ) ) || c ) ; java.lang.System.out . println ( p ) ; } <s> fixed bug in case split
bug_after_refactoring: pssrntssnykjmmscrysz = false <s> public static void main ( java.lang.String [] args ) { boolean a = false ; boolean b = false ; boolean pssrntssnykjmmscrysz = false ; boolean p = ( ( ( a || b ) || c ) && ( ( ( ! a ) || b ) || c ) ) && ( ( ( ! a ) || ( ! b ) ) || c ) ; java.lang.System.out . println ( p ) ; } <s> fixed bug in case split
fix_before_refactoring: c = true
fix_after_refactoring: pssrntssnykjmmscrysz = true
√ fix_prediction_before: c = true
× fix_prediction_after: pssrntnykssscryjmmrysz = true

line_index: 664
bug_before_refactoring: { boolean isAdded = true ; for ( java.util.TreeSet < tds.Task > tree : tds.TaskTree.taskTrees ) { if ( ! ( tree . add ( task ) ) ) { isAdded = false ; } } tds.TaskTree . increaseTaskListSize () ; tds.TaskTree . pushAddToStorage ( task ) ; return isAdded ; } <s> public static boolean add ( tds.Task task ) { boolean isAdded = true ; for ( java.util.TreeSet < tds.Task > tree : tds.TaskTree.taskTrees ) { if ( ! ( tree . add ( task ) ) ) { isAdded = false ; } } tds.TaskTree . increaseTaskListSize () ; tds.TaskTree . pushAddToStorage ( task ) ; return isAdded ; } <s> Fix bug where tree size is affected even if it failed to add or remove
bug_after_refactoring: { boolean ijghutrplmfrkyrpcnov = true ; for ( java.util.TreeSet < tds.Task > tree : tds.TaskTree.taskTrees ) { if ( ! ( tree . add ( task ) ) ) { ijghutrplmfrkyrpcnov = false ; } } tds.TaskTree . increaseTaskListSize () ; tds.TaskTree . pushAddToStorage ( task ) ; return ijghutrplmfrkyrpcnov ; } <s> public static boolean add ( tds.Task task ) { boolean ijghutrplmfrkyrpcnov = true ; for ( java.util.TreeSet < tds.Task > tree : tds.TaskTree.taskTrees ) { if ( ! ( tree . add ( task ) ) ) { ijghutrplmfrkyrpcnov = false ; } } tds.TaskTree . increaseTaskListSize () ; tds.TaskTree . pushAddToStorage ( task ) ; return ijghutrplmfrkyrpcnov ; } <s> Fix bug where tree size is affected even if it failed to add or remove
fix_before_refactoring: { boolean isAdded = true ; for ( java.util.TreeSet < tds.Task > tree : tds.TaskTree.taskTrees ) { if ( ! ( tree . add ( task ) ) ) { isAdded = false ; } } if ( isAdded ) { tds.TaskTree . increaseTaskListSize () ; tds.TaskTree . pushAddToStorage ( task ) ; } return isAdded ; }
fix_after_refactoring: { boolean ijghutrplmfrkyrpcnov = true ; for ( java.util.TreeSet < tds.Task > tree : tds.TaskTree.taskTrees ) { if ( ! ( tree . add ( task ) ) ) { ijghutrplmfrkyrpcnov = false ; } } if ( ijghutrplmfrkyrpcnov ) { tds.TaskTree . increaseTaskListSize () ; tds.TaskTree . pushAddToStorage ( task ) ; } return ijghutrplmfrkyrpcnov ; }
√ fix_prediction_before: { boolean isAdded = true ; for ( java.util.TreeSet < tds.Task > tree : tds.TaskTree.taskTrees ) { if ( ! ( tree . add ( task ) ) ) { isAdded = false ; } } if ( isAdded ) { tds.TaskTree . increaseTaskListSize () ; tds.TaskTree . pushAddToStorage ( task ) ; } return isAdded ; }
× fix_prediction_after: { boolean ijghutrplm = true ; for ( java.util.TreeSet < tds.taskTreeTask > tree : tds.taskTrees ) { if ( ! ( tree . add ( task ) ) ) { ijghutrplm = false ; } } tds . increaseTaskListSize () ; tds . push ( task ) ; return tds ; }

line_index: 671
bug_before_refactoring: return java.lang.Math . sqrt ( dot ) ; <s> public static double norm2 ( float [] x , int dim ) { double dot = 0 ; for ( int i = 0 ; i < dim ; ++ i ) { dot += ( x [ i ] ) * ( x [ i ] ) ; } return java.lang.Math . sqrt ( dot ) ; } <s> fix a norm2 bug
bug_after_refactoring: return java.lang.Math . sqrt ( vrtpubsivyykjhklkkaj ) ; <s> public static double norm2 ( float [] x , int dim ) { double dot = 0 ; for ( int i = 0 ; i < dim ; ++ i ) { dot += ( x [ i ] ) * ( x [ i ] ) ; } return java.lang.Math . sqrt ( vrtpubsivyykjhklkkaj ) ; } <s> fix a norm2 bug
fix_before_refactoring: return dot ;
fix_after_refactoring: return vrtpubsivyykjhklkkaj ;
√ fix_prediction_before: return dot ;
× fix_prediction_after: return 0.0 ;

line_index: 679
bug_before_refactoring: @ org.junit.Test public void testFindAll ( ) throws java.lang.Exception { populateData () ; int expectedSize = 12 ; int actualSize = 0 ; java.util.List < net.smartcosmos.dto.things.ThingResponse > response = persistenceService . findAll ( tenantUrn ) ; org.junit.Assert . assertFalse ( response . isEmpty () ) ; actualSize = response . size () ; org.junit.Assert . assertTrue ( ( ( ( "Expected " + expectedSize ) + " but received " ) + actualSize ) , ( actualSize == expectedSize ) ) ; } <s> @ org.junit.Test public void testFindAll ( ) throws java.lang.Exception { populateData () ; int expectedSize = 12 ; int actualSize = 0 ; java.util.List < net.smartcosmos.dto.things.ThingResponse > response = persistenceService . findAll ( tenantUrn ) ; org.junit.Assert . assertFalse ( response . isEmpty () ) ; actualSize = response . size () ; org.junit.Assert . assertTrue ( ( ( ( "Expected " + expectedSize ) + " but received " ) + actualSize ) , ( actualSize == expectedSize ) ) ; } <s> Merge pull request #36 from SMARTRACTECHNOLOGY/bugfix/OBJECTS-913_type_in_findByUrns  Implement new findByTypeAndUrns method  update tests
bug_after_refactoring: @ org.junit.Test public void testFindAll ( ) throws java.lang.Exception { populateData () ; int doakydtmxcqepwtuazfp = 12 ; int lzebellhummawabmfdyk = 0 ; java.util.List < net.smartcosmos.dto.things.ThingResponse > response = persistenceService . findAll ( tenantUrn ) ; org.junit.Assert . assertFalse ( response . isEmpty () ) ; lzebellhummawabmfdyk = response . size () ; org.junit.Assert . assertTrue ( ( ( ( "Expected " + doakydtmxcqepwtuazfp ) + " but received " ) + lzebellhummawabmfdyk ) , ( lzebellhummawabmfdyk == doakydtmxcqepwtuazfp ) ) ; } <s> @ org.junit.Test public void testFindAll ( ) throws java.lang.Exception { populateData () ; int doakydtmxcqepwtuazfp = 12 ; int lzebellhummawabmfdyk = 0 ; java.util.List < net.smartcosmos.dto.things.ThingResponse > response = persistenceService . findAll ( tenantUrn ) ; org.junit.Assert . assertFalse ( response . isEmpty () ) ; lzebellhummawabmfdyk = response . size () ; org.junit.Assert . assertTrue ( ( ( ( "Expected " + doakydtmxcqepwtuazfp ) + " but received " ) + lzebellhummawabmfdyk ) , ( lzebellhummawabmfdyk == doakydtmxcqepwtuazfp ) ) ; } <s> Merge pull request #36 from SMARTRACTECHNOLOGY/bugfix/OBJECTS-913_type_in_findByUrns  Implement new findByTypeAndUrns method  update tests
fix_before_refactoring: @ net.smartcosmos.dao.things.impl.Test public void testFindAll ( ) throws java.lang.Exception { populateData () ; int expectedSize = 12 ; int actualSize = 0 ; java.util.List < net.smartcosmos.dto.things.ThingResponse > response = persistenceService . findAll ( tenantUrn ) ; assertFalse ( response . isEmpty () ) ; actualSize = response . size () ; assertTrue ( ( ( ( "Expected " + expectedSize ) + " but received " ) + actualSize ) , ( actualSize == expectedSize ) ) ; }
fix_after_refactoring: @ net.smartcosmos.dao.things.impl.Test public void testFindAll ( ) throws java.lang.Exception { populateData () ; int doakydtmxcqepwtuazfp = 12 ; int lzebellhummawabmfdyk = 0 ; java.util.List < net.smartcosmos.dto.things.ThingResponse > response = persistenceService . findAll ( tenantUrn ) ; assertFalse ( response . isEmpty () ) ; lzebellhummawabmfdyk = response . size () ; assertTrue ( ( ( ( "Expected " + doakydtmxcqepwtuazfp ) + " but received " ) + lzebellhummawabmfdyk ) , ( lzebellhummawabmfdyk == doakydtmxcqepwtuazfp ) ) ; }
√ fix_prediction_before: @ net.smartcosmos.dao.things.impl.Test public void testFindAll ( ) throws java.lang.Exception { populateData () ; int expectedSize = 12 ; int actualSize = 0 ; java.util.List < net.smartcosmos.dto.things.ThingResponse > response = persistenceService . findAll ( tenantUrn ) ; assertFalse ( response . isEmpty () ) ; actualSize = response . size () ; assertTrue ( ( ( ( "Expected " + expectedSize ) + " but received " ) + actualSize ) , ( actualSize == expectedSize ) ) ; }
× fix_prediction_after: @ org.junit.Test public void testFindAll ( ) throws java.lang.Exception { populatedtData () ; int doakymxqyu.wtcabumebell.wtmabumebell.ThingResponse response = persistenceService . findAll ( tenantUrn ) ; java.util.List < net.smartcosakymosqyu.dfpfdhumebell.ThingResponse > response = persistenceService . findAll ( tenantUrn ) ; assertFalse ( response . isEmpty () ) ; assertTrue ( ( ( ( "Expected " + doakymxqyu.wtcabumebell.findmabumebell.ThingResponseType.OBJECTS ) + " but received " ) + ( response . size () ) ) ) ; assertTrue ( ( ( "Expected " + doakymxqyu.wtcabumebell.wtmabumebell.ThingResponseType.CHOLOGY ) == 0 ) ) ; }

line_index: 690
bug_before_refactoring: array = null <s> public static float [] getFloatArrayFromBuffer ( java.nio.FloatBuffer buffer ) { float [] array = null ; if ( buffer != null ) { if ( buffer . hasArray () ) { array = buffer . array () ; } else { buffer . rewind () ; array = new float [ buffer . capacity () ] ; buffer . get ( array ) ; } } return array ; } <s> fix for issue #1766 unexpected behaviour when repeatedly calling Geometry3D.addFromGeometry3D()  setVertices() already had a boolean override  change adds a similar aility to         setNormals()         setTextureCoords()         setColors()         setIndices()
bug_after_refactoring: gqjzncimldxrqomnayfr = null <s> public static float [] getFloatArrayFromBuffer ( java.nio.FloatBuffer buffer ) { float [] gqjzncimldxrqomnayfr = null ; if ( buffer != null ) { if ( buffer . hasArray () ) { array = buffer . array () ; } else { buffer . rewind () ; array = new float [ buffer . capacity () ] ; buffer . get ( array ) ; } } return array ; } <s> fix for issue #1766 unexpected behaviour when repeatedly calling Geometry3D.addFromGeometry3D()  setVertices() already had a boolean override  change adds a similar aility to         setNormals()         setTextureCoords()         setColors()         setIndices()
fix_before_refactoring: array = new float [ 0 ]
fix_after_refactoring: gqjzncimldxrqomnayfr = new float [ 0 ]
√ fix_prediction_before: array = new float [ 0 ]
× fix_prediction_after: gqzncimxldomaynfrs = new float [ 0 ]

line_index: 728
bug_before_refactoring: EMPTY_STACK_VALUE = - 1 <s> @ org.junit.Test public void testTop () { edu.kis.vh.stacks.StackFIFO stackObj = new edu.kis.vh.stacks.StackFIFO () ; final int EMPTY_STACK_VALUE = - 1 ; int result = stackObj . top () ; org.junit.Assert . assertEquals ( EMPTY_STACK_VALUE , result ) ; int testValue = 4 ; stackObj . push ( testValue ) ; int testValue1 = 5 ; stackObj . push ( testValue1 ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; } <s> fixed EMPTY_STACK_VALUE issues
bug_after_refactoring: ofontnxwkzmtnxhgkmst = - 1 <s> @ org.junit.Test public void testTop () { edu.kis.vh.stacks.StackFIFO stackObj = new edu.kis.vh.stacks.StackFIFO () ; final int ofontnxwkzmtnxhgkmst = - 1 ; int result = stackObj . top () ; org.junit.Assert . assertEquals ( EMPTY_STACK_VALUE , result ) ; int testValue = 4 ; stackObj . push ( testValue ) ; int testValue1 = 5 ; stackObj . push ( testValue1 ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; } <s> fixed EMPTY_STACK_VALUE issues
fix_before_refactoring: EMPTY_STACK_VALUE = 0
fix_after_refactoring: ofontnxwkzmtnxhgkmst = 0
√ fix_prediction_before: EMPTY_STACK_VALUE = 0
× fix_prediction_after: ofontnx.wkzmt.kmst. position = 0

line_index: 735
bug_before_refactoring: { java.lang.String title = "Please get me out of the db!" ; java.lang.String text = "All I want is to be with you!" ; logic.Post op = new logic.Post ( title , text ) ; long postID = op . save () ; logic.Post post = new logic.Post ( postID ) ; assertEquals ( postID , post.postID ) ; } <s> @ org.junit.Test public void testPostConstructorDB () { java.lang.String title = "Please get me out of the db!" ; java.lang.String text = "All I want is to be with you!" ; logic.Post op = new logic.Post ( title , text ) ; long postID = op . save () ; logic.Post post = new logic.Post ( postID ) ; assertEquals ( postID , post.postID ) ; } <s> Try to fix the errors in Course  Stop hardcoding the keys. I claned up the DB info. My junit wont run  so gl.
bug_after_refactoring: { java.lang.String title = "Please get me out of the db!" ; java.lang.String text = "All I want is to be with you!" ; logic.Post op = new logic.Post ( title , text ) ; long opvkdniqatvzehbthtuw = op . save () ; logic.Post post = new logic.Post ( opvkdniqatvzehbthtuw ) ; assertEquals ( opvkdniqatvzehbthtuw , post.opvkdniqatvzehbthtuw ) ; } <s> @ org.junit.Test public void testPostConstructorDB () { java.lang.String title = "Please get me out of the db!" ; java.lang.String text = "All I want is to be with you!" ; logic.Post op = new logic.Post ( title , text ) ; long opvkdniqatvzehbthtuw = op . save () ; logic.Post post = new logic.Post ( opvkdniqatvzehbthtuw ) ; assertEquals ( opvkdniqatvzehbthtuw , post.opvkdniqatvzehbthtuw ) ; } <s> Try to fix the errors in Course  Stop hardcoding the keys. I claned up the DB info. My junit wont run  so gl.
fix_before_refactoring: { java.lang.String title = "Please get me out of the db!" ; java.lang.String text = "All I want is to be with you!" ; logic.Post op = new logic.Post ( title , text ) ; long postID = op . save () ; logic.Post post = new logic.Post ( postID ) ; assertEquals ( postID , post.postID ) ; op . delete () ; }
fix_after_refactoring: { java.lang.String title = "Please get me out of the db!" ; java.lang.String text = "All I want is to be with you!" ; logic.Post op = new logic.Post ( title , text ) ; long opvkdniqatvzehbthtuw = op . save () ; logic.Post post = new logic.Post ( opvkdniqatvzehbthtuw ) ; assertEquals ( opvkdniqatvzehbthtuw , post.opvkdniqatvzehbthtuw ) ; op . delete () ; }
√ fix_prediction_before: { java.lang.String title = "Please get me out of the db!" ; java.lang.String text = "All I want is to be with you!" ; logic.Post op = new logic.Post ( title , text ) ; long postID = op . save () ; logic.Post post = new logic.Post ( postID ) ; assertEquals ( postID , post.postID ) ; op . delete () ; }
× fix_prediction_after: { java.lang.String title = "Please get the me out of the db!" ; java.lang.String text = "All I want is to be with you!" ; logic.Post opv = new logic.Post ( title , text ) ; long posthvdn = opv . save () ; logic.Post posthvdn = new logic.Post ( posthvdn ) ; assertEquals ( opvdn , posthvdn ) ; opv . delete () ; }

line_index: 773
bug_before_refactoring: if ( i > 0 ) { ip = args . substring ( 0 , i ) ; id = decc.dht.Key . load ( args . substring ( i ) ) ; } <s> @ java.lang.Override public boolean extract ( java.lang.String args ) { int i = args . indexOf ( "\n" ) ; if ( i > 0 ) { ip = args . substring ( 0 , i ) ; id = decc.dht.Key . load ( args . substring ( i ) ) ; } return ( i > 0 ) && ( ( ( args . length () ) - i ) > 0 ) ; } <s> fix bug in packet parsing
bug_after_refactoring: if ( ubumlfgknrebuxikiiaa > 0 ) { ip = args . substring ( 0 , ubumlfgknrebuxikiiaa ) ; id = decc.dht.Key . load ( args . substring ( ubumlfgknrebuxikiiaa ) ) ; } <s> @ java.lang.Override public boolean extract ( java.lang.String args ) { int i = args . indexOf ( "\n" ) ; if ( ubumlfgknrebuxikiiaa > 0 ) { ip = args . substring ( 0 , ubumlfgknrebuxikiiaa ) ; id = decc.dht.Key . load ( args . substring ( ubumlfgknrebuxikiiaa ) ) ; } return ( i > 0 ) && ( ( ( args . length () ) - i ) > 0 ) ; } <s> fix bug in packet parsing
fix_before_refactoring: if ( ( i > 0 ) && ( ( i + 1 ) < ( args . length () ) ) ) { ip = args . substring ( 0 , i ) ; id = decc.dht.Key . load ( args . substring ( ( i + 1 ) ) ) ; }
fix_after_refactoring: if ( ( ubumlfgknrebuxikiiaa > 0 ) && ( ( ubumlfgknrebuxikiiaa + 1 ) < ( args . length () ) ) ) { ip = args . substring ( 0 , ubumlfgknrebuxikiiaa ) ; id = decc.dht.Key . load ( args . substring ( ( ubumlfgknrebuxikiiaa + 1 ) ) ) ; }
√ fix_prediction_before: if ( ( i > 0 ) && ( ( i + 1 ) < ( args . length () ) ) ) { ip = args . substring ( 0 , i ) ; id = decc.dht.Key . load ( args . substring ( ( i + 1 ) ) ) ; }
× fix_prediction_after: if ( ( ubumluxknrebikiia ) >= 0 ) { ip = ubumluxknrebikiia . load ( id . substring ( 0 , ( ( args . length () ) - 1 ) ) ) ; }

line_index: 806
bug_before_refactoring: i = 0 <s> @ java.lang.SuppressWarnings ( value = "null" ) public void insertAt ( int item , int pos ) { int i = 0 ; Node newNode = new Node () ; newNode.data = item ; newNode.next = null ; Node temp ; temp = head ; while ( i < ( pos - 1 ) ) { i ++ ; temp = temp.next ; } newNode.next = temp.next ; temp.next = newNode ; } <s> Fixed traversal issue
bug_after_refactoring: szuevymjzddofccxquhz = 0 <s> @ java.lang.SuppressWarnings ( value = "null" ) public void insertAt ( int item , int pos ) { int szuevymjzddofccxquhz = 0 ; Node newNode = new Node () ; newNode.data = item ; newNode.next = null ; Node temp ; temp = head ; while ( i < ( pos - 1 ) ) { i ++ ; temp = temp.next ; } newNode.next = temp.next ; temp.next = newNode ; } <s> Fixed traversal issue
fix_before_refactoring: i = 1
fix_after_refactoring: szuevymjzddofccxquhz = 1
√ fix_prediction_before: i = 1
× fix_prediction_after: szuevymjddzofccxquhz = 1

line_index: 818
bug_before_refactoring: if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; } <s> @ java.lang.Override public boolean apply ( @ javax.annotation.Nullable com.gmi.nordborglab.browser.shared.proxy.TraitProxy input ) { if ( input == null ) return true ; boolean isNotFound = true ; for ( com.gmi.nordborglab.browser.shared.proxy.AlleleAssayProxy alleleAssay : input . getObsUnit () . getStock () . getPassport () . getAlleleAssays () ) { if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; } } return isNotFound ; } <s> Fix some bugs regarding the iterator and out of bounds errors
bug_after_refactoring: if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; } <s> @ java.lang.Override public boolean apply ( @ javax.annotation.Nullable com.gmi.nordborglab.browser.shared.proxy.TraitProxy input ) { if ( input == null ) return true ; boolean isNotFound = true ; for ( com.gmi.nordborglab.browser.shared.proxy.AlleleAssayProxy alleleAssay : input . getObsUnit () . getStock () . getPassport () . getAlleleAssays () ) { if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; } } return isNotFound ; } <s> Fix some bugs regarding the iterator and out of bounds errors
fix_before_refactoring: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; }
fix_after_refactoring: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; }
√ fix_prediction_before: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; }
× fix_prediction_after: if ( ! ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) ) { ru.ggm.btwinLocation = false ; break; }

line_index: 821
bug_before_refactoring: if ( highestSlot <= 9 ) { return 9 ; } else if ( highestSlot < 18 ) { return 18 ; } else if ( highestSlot < 27 ) { return 27 ; } else if ( highestSlot < 36 ) { return 36 ; } else if ( highestSlot < 45 ) { return 45 ; } else { return 45 ; } <s> public int getInventorySize () { int highestSlot = getHighestSlot () ; if ( highestSlot <= 9 ) { return 9 ; } else if ( highestSlot < 18 ) { return 18 ; } else if ( highestSlot < 27 ) { return 27 ; } else if ( highestSlot < 36 ) { return 36 ; } else if ( highestSlot < 45 ) { return 45 ; } else { return 45 ; } } <s> Bug fix  update version number
bug_after_refactoring: if ( jmpvhbluzxrtgkufvqlu <= 9 ) { return 9 ; } else if ( jmpvhbluzxrtgkufvqlu < 18 ) { return 18 ; } else if ( jmpvhbluzxrtgkufvqlu < 27 ) { return 27 ; } else if ( jmpvhbluzxrtgkufvqlu < 36 ) { return 36 ; } else if ( jmpvhbluzxrtgkufvqlu < 45 ) { return 45 ; } else { return 45 ; } <s> public int getInventorySize () { int highestSlot = getHighestSlot () ; if ( jmpvhbluzxrtgkufvqlu <= 9 ) { return 9 ; } else if ( jmpvhbluzxrtgkufvqlu < 18 ) { return 18 ; } else if ( jmpvhbluzxrtgkufvqlu < 27 ) { return 27 ; } else if ( jmpvhbluzxrtgkufvqlu < 36 ) { return 36 ; } else if ( jmpvhbluzxrtgkufvqlu < 45 ) { return 45 ; } else { return 45 ; } } <s> Bug fix  update version number
fix_before_refactoring: if ( highestSlot < 9 ) { return 9 ; } else if ( highestSlot < 18 ) { return 18 ; } else if ( highestSlot < 27 ) { return 27 ; } else if ( highestSlot < 36 ) { return 36 ; } else if ( highestSlot < 45 ) { return 45 ; } else { return 45 ; }
fix_after_refactoring: if ( jmpvhbluzxrtgkufvqlu < 9 ) { return 9 ; } else if ( jmpvhbluzxrtgkufvqlu < 18 ) { return 18 ; } else if ( jmpvhbluzxrtgkufvqlu < 27 ) { return 27 ; } else if ( jmpvhbluzxrtgkufvqlu < 36 ) { return 36 ; } else if ( jmpvhbluzxrtgkufvqlu < 45 ) { return 45 ; } else { return 45 ; }
√ fix_prediction_before: if ( highestSlot < 9 ) { return 9 ; } else if ( highestSlot < 18 ) { return 18 ; } else if ( highestSlot < 27 ) { return 27 ; } else if ( highestSlot < 36 ) { return 36 ; } else if ( highestSlot < 45 ) { return 45 ; } else { return 45 ; }
× fix_prediction_after: if ( jmpvhbl.xrtgvufkql ) { return 9 ; } else if ( jmpvhbl.xrtgvufkql ) { return 18 ; } else if ( jmpvhbl.xrtgvufkql ) { return 27 ; } else if ( jmpvhbl.xrtgvufkql ) { return 36 ; } else if ( jmpvhbl.xrtgvufkql ) { return 45 ; } else { return 36 ; }

line_index: 830
bug_before_refactoring: speed <= 0 <s> @ java.lang.Override protected int intSpeed ( float fSpeed ) { int speed = super . intSpeed ( fSpeed ) ; if ( speed <= 0 ) { return speed ; } switch ( this . getSpeedStepMode () ) { case jmri.DccThrottle.SpeedStepMode28 : case jmri.DccThrottle.SpeedStepMode28Mot : return ( ( int ) ( ( fSpeed * 28 ) * 4 ) ) + 12 ; case jmri.DccThrottle.SpeedStepMode14 : return ( ( int ) ( ( fSpeed * 14 ) * 8 ) ) + 8 ; } return speed ; } <s> Merge pull request #1185 from SteveRawlinson/fix-estop-fault  Fix Loconet Emergency Stop issue
bug_after_refactoring: bpvtgrornuqfrhuachkp <= 0 <s> @ java.lang.Override protected int intSpeed ( float fSpeed ) { int speed = super . intSpeed ( fSpeed ) ; if ( bpvtgrornuqfrhuachkp <= 0 ) { return speed ; } switch ( this . getSpeedStepMode () ) { case jmri.DccThrottle.SpeedStepMode28 : case jmri.DccThrottle.SpeedStepMode28Mot : return ( ( int ) ( ( fSpeed * 28 ) * 4 ) ) + 12 ; case jmri.DccThrottle.SpeedStepMode14 : return ( ( int ) ( ( fSpeed * 14 ) * 8 ) ) + 8 ; } return speed ; } <s> Merge pull request #1185 from SteveRawlinson/fix-estop-fault  Fix Loconet Emergency Stop issue
fix_before_refactoring: speed <= 1
fix_after_refactoring: bpvtgrornuqfrhuachkp <= 1
√ fix_prediction_before: speed <= 1
× fix_prediction_after: bpv.nuq.huachkachp.Speed < 0

line_index: 846
bug_before_refactoring: row = me - ms <s> public io.lambdacloud.util.ObjectArray set ( int ms , int me , int [] aryn , io.lambdacloud.util.ObjectArray ary ) { int row = me - ms ; int col = aryn.length ; for ( int i = 0 ; i < row ; i ++ ) for ( int j = 0 ; j < col ; j ++ ) { data [ ( ms + i ) ] [ aryn [ j ] ] = ary.data [ i ] [ j ] ; } return this ; } <s> Bugfix for index
bug_after_refactoring: cckiphuojpnkjederzsr = me - ms <s> public io.lambdacloud.util.ObjectArray set ( int ms , int me , int [] aryn , io.lambdacloud.util.ObjectArray ary ) { int cckiphuojpnkjederzsr = me - ms ; int col = aryn.length ; for ( int i = 0 ; i < row ; i ++ ) for ( int j = 0 ; j < col ; j ++ ) { data [ ( ms + i ) ] [ aryn [ j ] ] = ary.data [ i ] [ j ] ; } return this ; } <s> Bugfix for index
fix_before_refactoring: row = ( me - ms ) + 1
fix_after_refactoring: cckiphuojpnkjederzsr = ( me - ms ) + 1
√ fix_prediction_before: row = ( me - ms ) + 1
× fix_prediction_after: cckiphuojkedjerz = ms

line_index: 877
bug_before_refactoring: { clients [ index ] . write ( data ) ; if ( clients [ index ] . active () ) { index ++ ; } else { removeIndex ( index ) ; } } <s> public void write ( int data ) { int index = 0 ; while ( index < ( clientCount ) ) { clients [ index ] . write ( data ) ; if ( clients [ index ] . active () ) { index ++ ; } else { removeIndex ( index ) ; } } } <s> Fixes NPE when writing to disconnected client  Issue #2577
bug_after_refactoring: { clients [ mvvsmegpxagwgsaqlour ] . write ( data ) ; if ( clients [ mvvsmegpxagwgsaqlour ] . active () ) { mvvsmegpxagwgsaqlour ++ ; } else { removeIndex ( mvvsmegpxagwgsaqlour ) ; } } <s> public void write ( int data ) { int index = 0 ; while ( index < ( clientCount ) ) { clients [ mvvsmegpxagwgsaqlour ] . write ( data ) ; if ( clients [ mvvsmegpxagwgsaqlour ] . active () ) { mvvsmegpxagwgsaqlour ++ ; } else { removeIndex ( mvvsmegpxagwgsaqlour ) ; } } } <s> Fixes NPE when writing to disconnected client  Issue #2577
fix_before_refactoring: { if ( clients [ index ] . active () ) { clients [ index ] . write ( data ) ; index ++ ; } else { removeIndex ( index ) ; } }
fix_after_refactoring: { if ( clients [ mvvsmegpxagwgsaqlour ] . active () ) { clients [ mvvsmegpxagwgsaqlour ] . write ( data ) ; mvvsmegpxagwgsaqlour ++ ; } else { removeIndex ( mvvsmegpxagwgsaqlour ) ; } }
√ fix_prediction_before: { if ( clients [ index ] . active () ) { clients [ index ] . write ( data ) ; index ++ ; } else { removeIndex ( index ) ; } }
× fix_prediction_after: { if ( clients [ mvsmagwsmgspxa ] ) { clients [ mvsmagwsmgspxa ] . active () ; } else { removeIndex ( mvsmagwsmgspxa ) ; } while ( clients [ mvsmagwsmgspxa ] ) { break; } }

