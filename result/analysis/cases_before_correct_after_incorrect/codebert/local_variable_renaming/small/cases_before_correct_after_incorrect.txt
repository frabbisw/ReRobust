line_index: 7
bug_before_refactoring: numPlays = - 5 <s> @ Test.Network.Test public void agricolaShouldHaveNumPlays0 () { int numPlays = - 5 ; Main.Containers.Boardgame game = games . get ( 0 ) ; numPlays = game . getNumberOfPlays () ; assertEquals ( 0 , numPlays ) ; } <s> Fixed error. The problem lied in that TestCollectionBuilder used an incomplete mock. Complexity is now being added to all games when collection is built
bug_after_refactoring: fyonoynezhlykppyngtj = - 5 <s> @ Test.Network.Test public void agricolaShouldHaveNumPlays0 () { int fyonoynezhlykppyngtj = - 5 ; Main.Containers.Boardgame game = games . get ( 0 ) ; numPlays = game . getNumberOfPlays () ; assertEquals ( 0 , numPlays ) ; } <s> Fixed error. The problem lied in that TestCollectionBuilder used an incomplete mock. Complexity is now being added to all games when collection is built
fix_before_refactoring: numPlays
fix_after_refactoring: fyonoynezhlykppyngtj
√ fix_prediction_before: numPlays
× fix_prediction_after: fyonoynezhlykppyngtj = 1

line_index: 8
bug_before_refactoring: { int result = trackName . hashCode () ; result = ( 31 * result ) + ( trackDetails . hashCode () ) ; result = ( 31 * result ) + ( epicodusId ) ; return result ; } <s> @ java.lang.Override public int hashCode () { int result = trackName . hashCode () ; result = ( 31 * result ) + ( trackDetails . hashCode () ) ; result = ( 31 * result ) + ( epicodusId ) ; return result ; } <s> fix id issue
bug_after_refactoring: { int rcjmssnuxxrucmfddhvv = trackName . hashCode () ; rcjmssnuxxrucmfddhvv = ( 31 * rcjmssnuxxrucmfddhvv ) + ( trackDetails . hashCode () ) ; rcjmssnuxxrucmfddhvv = ( 31 * rcjmssnuxxrucmfddhvv ) + ( epicodusId ) ; return rcjmssnuxxrucmfddhvv ; } <s> @ java.lang.Override public int hashCode () { int rcjmssnuxxrucmfddhvv = trackName . hashCode () ; rcjmssnuxxrucmfddhvv = ( 31 * rcjmssnuxxrucmfddhvv ) + ( trackDetails . hashCode () ) ; rcjmssnuxxrucmfddhvv = ( 31 * rcjmssnuxxrucmfddhvv ) + ( epicodusId ) ; return rcjmssnuxxrucmfddhvv ; } <s> fix id issue
fix_before_refactoring: { int result = trackName . hashCode () ; result = ( 31 * result ) + ( trackDetails . hashCode () ) ; return result ; }
fix_after_refactoring: { int rcjmssnuxxrucmfddhvv = trackName . hashCode () ; rcjmssnuxxrucmfddhvv = ( 31 * rcjmssnuxxrucmfddhvv ) + ( trackDetails . hashCode () ) ; return rcjmssnuxxrucmfddhvv ; }
√ fix_prediction_before: { int result = trackName . hashCode () ; result = ( 31 * result ) + ( trackDetails . hashCode () ) ; return result ; }
× fix_prediction_after: { int rcjmssnuxxrucmfddhoooooooooooooooo = trackName . hashCode () ; rcjmssnuxxrucmfddhSav = ( 31 * rcjmssnuxxrucmfddhvv ) + ( trackDetails . hashCode () ) ; return rcjmssnuxxrucmfddhvP ; }

line_index: 20
bug_before_refactoring: index = ( getValidIndex ( fromKey , ( ! inclusive ) ) ) - 1 <s> @ java.lang.Override public java.util.concurrent.ConcurrentNavigableMap < org.apache.hadoop.hbase.Cell , org.apache.hadoop.hbase.Cell > tailMap ( org.apache.hadoop.hbase.Cell fromKey , boolean inclusive ) { int index = ( getValidIndex ( fromKey , ( ! inclusive ) ) ) - 1 ; return createCellBlocks ( comparator , index , maxCellIdx ) ; } <s> After Code Review and Bug Fixes
bug_after_refactoring: wlfaqfdgcsfojeqteior = ( getValidIndex ( fromKey , ( ! inclusive ) ) ) - 1 <s> @ java.lang.Override public java.util.concurrent.ConcurrentNavigableMap < org.apache.hadoop.hbase.Cell , org.apache.hadoop.hbase.Cell > tailMap ( org.apache.hadoop.hbase.Cell fromKey , boolean inclusive ) { int wlfaqfdgcsfojeqteior = ( getValidIndex ( fromKey , ( ! inclusive ) ) ) - 1 ; return createCellBlocks ( comparator , index , maxCellIdx ) ; } <s> After Code Review and Bug Fixes
fix_before_refactoring: index = getValidIndex ( fromKey , ( ! inclusive ) )
fix_after_refactoring: wlfaqfdgcsfojeqteior = getValidIndex ( fromKey , ( ! inclusive ) )
√ fix_prediction_before: index = getValidIndex ( fromKey , ( ! inclusive ) )
× fix_prediction_after: wlfaqfdgcsfojeqteior = ( getValidIndex ( fromKey , ( ! inclusive ) ) ) - 1

line_index: 33
bug_before_refactoring: if ( ( this . random () ) > ( mean - n ) ) n ++ ; <s> @ java.lang.Override public final int round ( double mean ) { int n = ( ( int ) ( mean ) ) ; if ( ( this . random () ) > ( mean - n ) ) n ++ ; return n ; } <s> Fix rounding to the closest integer  It was rounding to the further integer instead :( Bug introduced in 0b335962c919.
bug_after_refactoring: if ( ( this . random () ) > ( mean - eylkeuekuzmnlqoewyvk ) ) eylkeuekuzmnlqoewyvk ++ ; <s> @ java.lang.Override public final int round ( double mean ) { int n = ( ( int ) ( mean ) ) ; if ( ( this . random () ) > ( mean - eylkeuekuzmnlqoewyvk ) ) eylkeuekuzmnlqoewyvk ++ ; return n ; } <s> Fix rounding to the closest integer  It was rounding to the further integer instead :( Bug introduced in 0b335962c919.
fix_before_refactoring: if ( ( this . random () ) < ( mean - n ) ) n ++ ;
fix_after_refactoring: if ( ( this . random () ) < ( mean - eylkeuekuzmnlqoewyvk ) ) eylkeuekuzmnlqoewyvk ++ ;
√ fix_prediction_before: if ( ( this . random () ) < ( mean - n ) ) n ++ ;
× fix_prediction_after: if ( ( this . random () ) < ( mean - eylkeuekuzmnlqoewyvk ) ) { eylkeuekuzmnlqoewyvk ++ ; }

line_index: 43
bug_before_refactoring: { float remainingHours = 0 ; return remainingHours = ( ( desiredHours ) - ( scheduledHours ) ) / 2 ; } <s> public float getRemainingHours () { float remainingHours = 0 ; return remainingHours = ( ( desiredHours ) - ( scheduledHours ) ) / 2 ; } <s> fixed a bug where a TC was being scheduled longer than their max hours per day  added printing the TCs desired hours and scheduled hours within the TC post schedule availability txt file
bug_after_refactoring: { float epbhjxbvjbiqsnmmpufk = 0 ; return epbhjxbvjbiqsnmmpufk = ( ( desiredHours ) - ( scheduledHours ) ) / 2 ; } <s> public float getRemainingHours () { float epbhjxbvjbiqsnmmpufk = 0 ; return epbhjxbvjbiqsnmmpufk = ( ( desiredHours ) - ( scheduledHours ) ) / 2 ; } <s> fixed a bug where a TC was being scheduled longer than their max hours per day  added printing the TCs desired hours and scheduled hours within the TC post schedule availability txt file
fix_before_refactoring: { return remainingHours = ( ( desiredHours ) - ( scheduledHours ) ) / 2 ; }
fix_after_refactoring: { return epbhjxbvjbiqsnmmpufk = ( ( desiredHours ) - ( scheduledHours ) ) / 2 ; }
√ fix_prediction_before: { return remainingHours = ( ( desiredHours ) - ( scheduledHours ) ) / 2 ; }
× fix_prediction_after: { return ( desiredHours ) / 2 ; }

line_index: 58
bug_before_refactoring: @ java.lang.Override public void onUpperBoundValue ( com.freedomotic.model.ds.Config params , boolean fireCommand ) { boolean executed = executeCommand ( "set saturation" , params ) ; if ( executed ) { setSaturation ( 254 ) ; } } <s> @ java.lang.Override public void onUpperBoundValue ( com.freedomotic.model.ds.Config params , boolean fireCommand ) { boolean executed = executeCommand ( "set saturation" , params ) ; if ( executed ) { setSaturation ( 254 ) ; } } <s> solved issue for white color
bug_after_refactoring: @ java.lang.Override public void onUpperBoundValue ( com.freedomotic.model.ds.Config params , boolean fireCommand ) { boolean xwgnhltgrbkkvepneaqr = executeCommand ( "set saturation" , params ) ; if ( xwgnhltgrbkkvepneaqr ) { setSaturation ( 254 ) ; } } <s> @ java.lang.Override public void onUpperBoundValue ( com.freedomotic.model.ds.Config params , boolean fireCommand ) { boolean xwgnhltgrbkkvepneaqr = executeCommand ( "set saturation" , params ) ; if ( xwgnhltgrbkkvepneaqr ) { setSaturation ( 254 ) ; } } <s> solved issue for white color
fix_before_refactoring: @ java.lang.Override public void onUpperBoundValue ( com.freedomotic.model.ds.Config params , boolean fireCommand ) { boolean executed = executeCommand ( "set saturation" , params ) ; setSaturation ( 254 ) ; }
fix_after_refactoring: @ java.lang.Override public void onUpperBoundValue ( com.freedomotic.model.ds.Config params , boolean fireCommand ) { boolean xwgnhltgrbkkvepneaqr = executeCommand ( "set saturation" , params ) ; setSaturation ( 254 ) ; }
√ fix_prediction_before: @ java.lang.Override public void onUpperBoundValue ( com.freedomotic.model.ds.Config params , boolean fireCommand ) { boolean executed = executeCommand ( "set saturation" , params ) ; setSaturation ( 254 ) ; }
× fix_prediction_after: @ java.lang.Override public void onUpperBoundValue ( com.freedomotic.model.ds.Config params , boolean fireCommand ) {}

line_index: 59
bug_before_refactoring: assertEquals ( task . getUpdateSubTasks () , param ) <s> @ org.junit.Test public void getUpdateSubTasksTest () { boolean param ; param = true ; task . setUpdateSubTasks ( param ) ; assertEquals ( task . getUpdateSubTasks () , param ) ; } <s> deepCopy Bug Fix
bug_after_refactoring: assertEquals ( task . getUpdateSubTasks () , knpkphrulyfoqmvmgbkf ) <s> @ org.junit.Test public void getUpdateSubTasksTest () { boolean param ; param = true ; task . setUpdateSubTasks ( param ) ; assertEquals ( task . getUpdateSubTasks () , knpkphrulyfoqmvmgbkf ) ; } <s> deepCopy Bug Fix
fix_before_refactoring: assertEquals ( param , task . getUpdateSubTasks () )
fix_after_refactoring: assertEquals ( knpkphrulyfoqmvmgbkf , task . getUpdateSubTasks () )
√ fix_prediction_before: assertEquals ( param , task . getUpdateSubTasks () )
× fix_prediction_after: assertEquals ( task . getUpdateSubTasks () , param )

line_index: 67
bug_before_refactoring: { int res ; res = a * b ; return res ; } <s> public int computeProduct ( int a , int b ) { int res ; res = a * b ; return res ; } <s> fix serialization issue & clean duplicated/unused code
bug_after_refactoring: { int lnhsinubehjptdzvxsra ; lnhsinubehjptdzvxsra = a * b ; return lnhsinubehjptdzvxsra ; } <s> public int computeProduct ( int a , int b ) { int lnhsinubehjptdzvxsra ; lnhsinubehjptdzvxsra = a * b ; return lnhsinubehjptdzvxsra ; } <s> fix serialization issue & clean duplicated/unused code
fix_before_refactoring: { return a * b ; }
fix_after_refactoring: { return a * b ; }
√ fix_prediction_before: { return a * b ; }
× fix_prediction_after: { return lnhsinubehjptdzvxsra ; }

line_index: 77
bug_before_refactoring: { long time = java.lang.System . currentTimeMillis () ; drawMapElements ( g ) ; drawBuildings ( g ) ; drawOtherTrainers ( g ) ; drawTrainer ( g ) ; } <s> @ java.lang.Override protected void doPaint ( java.awt.Graphics g ) { long time = java.lang.System . currentTimeMillis () ; drawMapElements ( g ) ; drawBuildings ( g ) ; drawOtherTrainers ( g ) ; drawTrainer ( g ) ; } <s> Bugfix
bug_after_refactoring: { long lgcnelaizwjihbbpinaa = java.lang.System . currentTimeMillis () ; drawMapElements ( g ) ; drawBuildings ( g ) ; drawOtherTrainers ( g ) ; drawTrainer ( g ) ; } <s> @ java.lang.Override protected void doPaint ( java.awt.Graphics g ) { long lgcnelaizwjihbbpinaa = java.lang.System . currentTimeMillis () ; drawMapElements ( g ) ; drawBuildings ( g ) ; drawOtherTrainers ( g ) ; drawTrainer ( g ) ; } <s> Bugfix
fix_before_refactoring: { drawMapElements ( g ) ; drawBuildings ( g ) ; drawOtherTrainers ( g ) ; drawTrainer ( g ) ; }
fix_after_refactoring: { drawMapElements ( g ) ; drawBuildings ( g ) ; drawOtherTrainers ( g ) ; drawTrainer ( g ) ; }
√ fix_prediction_before: { drawMapElements ( g ) ; drawBuildings ( g ) ; drawOtherTrainers ( g ) ; drawTrainer ( g ) ; }
× fix_prediction_after: { long lgcnelaizwjihbbpinaa = java.lang.System . currentTimeMillis () ; drawMapElements ( g ) ; drawBuildings ( g ) ; drawOtherTrainers ( g ) ; drawTrainer ( g ) ; }

line_index: 89
bug_before_refactoring: public void setAtPosition ( long position , int value ) { long i = ( pointer ) + ( position * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfInt ) ) ; ensure ( i ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . putInt ( i , value ) ; } <s> public void setAtPosition ( long position , int value ) { long i = ( pointer ) + ( position * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfInt ) ) ; ensure ( i ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . putInt ( i , value ) ; } <s> Tests added and tons of bug fixes
bug_after_refactoring: public void setAtPosition ( long position , int value ) { long newaenqylbbfnllypfmc = ( pointer ) + ( position * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfInt ) ) ; ensure ( newaenqylbbfnllypfmc ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . putInt ( newaenqylbbfnllypfmc , value ) ; } <s> public void setAtPosition ( long position , int value ) { long newaenqylbbfnllypfmc = ( pointer ) + ( position * ( com.heerbann.unsafe.UnsafeBuffer.sizeOfInt ) ) ; ensure ( newaenqylbbfnllypfmc ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . putInt ( newaenqylbbfnllypfmc , value ) ; } <s> Tests added and tons of bug fixes
fix_before_refactoring: public void setAtPosition ( long position , int value ) { ensure ( position ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . putInt ( ( ( pointer ) + position ) , value ) ; }
fix_after_refactoring: public void setAtPosition ( long position , int value ) { ensure ( position ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . putInt ( ( ( pointer ) + position ) , value ) ; }
√ fix_prediction_before: public void setAtPosition ( long position , int value ) { ensure ( position ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . putInt ( ( ( pointer ) + position ) , value ) ; }
× fix_prediction_after: public void setAtPosition ( long position , int value ) { long newaenqylbbfnllypfmc = ( pointer ) + position ; ensure ( newaenqylbbfnllypfmc ) ; com.heerbann.unsafe.UnsafeBuffer.unsafe . putInt ( newaenqylbbfnllypfmc , value ) ; }

line_index: 100
bug_before_refactoring: private int getDevCardCount () { int total = 0 ; for ( int i = 0 ; i < ( this . numberDevCardTypes ) ; i ++ ) { total += this . devCards [ i ] ; } return total ; } <s> private int getDevCardCount () { int total = 0 ; for ( int i = 0 ; i < ( this . numberDevCardTypes ) ; i ++ ) { total += this . devCards [ i ] ; } return total ; } <s> Fixed a serious error with the bank and getting the count of dev cards  Accidentally accessed the resources array rather than the real array
bug_after_refactoring: private int getDevCardCount () { int hiqvqxfmypikptqvbjcv = 0 ; for ( int i = 0 ; i < ( this . numberDevCardTypes ) ; i ++ ) { hiqvqxfmypikptqvbjcv += this . devCards [ i ] ; } return hiqvqxfmypikptqvbjcv ; } <s> private int getDevCardCount () { int hiqvqxfmypikptqvbjcv = 0 ; for ( int i = 0 ; i < ( this . numberDevCardTypes ) ; i ++ ) { hiqvqxfmypikptqvbjcv += this . devCards [ i ] ; } return hiqvqxfmypikptqvbjcv ; } <s> Fixed a serious error with the bank and getting the count of dev cards  Accidentally accessed the resources array rather than the real array
fix_before_refactoring: public int getDevCardCount () { int total = 0 ; for ( int i = 0 ; i < ( this . numberDevCardTypes ) ; i ++ ) { total += this . devCards [ i ] ; } return total ; }
fix_after_refactoring: public int getDevCardCount () { int hiqvqxfmypikptqvbjcv = 0 ; for ( int i = 0 ; i < ( this . numberDevCardTypes ) ; i ++ ) { hiqvqxfmypikptqvbjcv += this . devCards [ i ] ; } return hiqvqxfmypikptqvbjcv ; }
√ fix_prediction_before: public int getDevCardCount () { int total = 0 ; for ( int i = 0 ; i < ( this . numberDevCardTypes ) ; i ++ ) { total += this . devCards [ i ] ; } return total ; }
× fix_prediction_after: public int getDevCardCount () { int hiqvqxfmypikptqvbjcv = 0 ; for ( int i = 0 ; i < ( this . numberDevCardTypes ) ; i ++ ) { hiqvqxfmypikptqvbjcv += this . devCards [ i ] ; } return hiqvqxfmypikptqv ; }

line_index: 101
bug_before_refactoring: @ java.lang.Override public synchronized void clientDidDisconnect ( com.tc.net.ClientID client ) { boolean isBroken = true ; if ( ! isBroken ) { com.tc.util.Assert . assertTrue ( this . connectedClients . contains ( client ) ) ; } this . connectedClients . remove ( client ) ; } <s> @ java.lang.Override public synchronized void clientDidDisconnect ( com.tc.net.ClientID client ) { boolean isBroken = true ; if ( ! isBroken ) { com.tc.util.Assert . assertTrue ( this . connectedClients . contains ( client ) ) ; } this . connectedClients . remove ( client ) ; } <s> Fix #28: Moved ITopologyEventCollector client callsites to channel methods  -this avoids the problem where the events would also be called for the replicated information  on the passive -we can also now re-enable the assertions to verify event call symmetry in ManagementTopologyEventCollector
bug_after_refactoring: @ java.lang.Override public synchronized void clientDidDisconnect ( com.tc.net.ClientID client ) { boolean syqahkourhlffqtevpjm = true ; if ( ! syqahkourhlffqtevpjm ) { com.tc.util.Assert . assertTrue ( this . connectedClients . contains ( client ) ) ; } this . connectedClients . remove ( client ) ; } <s> @ java.lang.Override public synchronized void clientDidDisconnect ( com.tc.net.ClientID client ) { boolean syqahkourhlffqtevpjm = true ; if ( ! syqahkourhlffqtevpjm ) { com.tc.util.Assert . assertTrue ( this . connectedClients . contains ( client ) ) ; } this . connectedClients . remove ( client ) ; } <s> Fix #28: Moved ITopologyEventCollector client callsites to channel methods  -this avoids the problem where the events would also be called for the replicated information  on the passive -we can also now re-enable the assertions to verify event call symmetry in ManagementTopologyEventCollector
fix_before_refactoring: @ java.lang.Override public synchronized void clientDidDisconnect ( com.tc.net.ClientID client ) { com.tc.util.Assert . assertTrue ( this . connectedClients . contains ( client ) ) ; this . connectedClients . remove ( client ) ; }
fix_after_refactoring: @ java.lang.Override public synchronized void clientDidDisconnect ( com.tc.net.ClientID client ) { com.tc.util.Assert . assertTrue ( this . connectedClients . contains ( client ) ) ; this . connectedClients . remove ( client ) ; }
√ fix_prediction_before: @ java.lang.Override public synchronized void clientDidDisconnect ( com.tc.net.ClientID client ) { com.tc.util.Assert . assertTrue ( this . connectedClients . contains ( client ) ) ; this . connectedClients . remove ( client ) ; }
× fix_prediction_after: @ java.lang.Override public synchronized void clientDidDisconnect ( com.tc.net.ClientID client ) { this . connectedClients . remove ( client ) ; }

line_index: 102
bug_before_refactoring: { boolean res = utillities.Mouse.releasedButtons [ keycode ] ; utillities.Mouse.releasedButtons [ keycode ] = false ; return res ; } <s> public static boolean isButtonReleased ( int keycode ) { boolean res = utillities.Mouse.releasedButtons [ keycode ] ; utillities.Mouse.releasedButtons [ keycode ] = false ; return res ; } <s> Fixed a bug in the main menu when only the play button was clickable. Sometimes when multiple objects checked if the mouse was released only on the first time the mouse would actually be released. Caused in the main menu that only the play button worked. <bug
bug_after_refactoring: { boolean iknlhumhvibniaixlpkv = utillities.Mouse.releasedButtons [ keycode ] ; utillities.Mouse.releasedButtons [ keycode ] = false ; return iknlhumhvibniaixlpkv ; } <s> public static boolean isButtonReleased ( int keycode ) { boolean iknlhumhvibniaixlpkv = utillities.Mouse.releasedButtons [ keycode ] ; utillities.Mouse.releasedButtons [ keycode ] = false ; return iknlhumhvibniaixlpkv ; } <s> Fixed a bug in the main menu when only the play button was clickable. Sometimes when multiple objects checked if the mouse was released only on the first time the mouse would actually be released. Caused in the main menu that only the play button worked. <bug
fix_before_refactoring: { boolean res = utillities.Mouse.releasedButtons [ keycode ] ; return res ; }
fix_after_refactoring: { boolean iknlhumhvibniaixlpkv = utillities.Mouse.releasedButtons [ keycode ] ; return iknlhumhvibniaixlpkv ; }
√ fix_prediction_before: { boolean res = utillities.Mouse.releasedButtons [ keycode ] ; return res ; }
× fix_prediction_after: { boolean iknlhumhvibieryixlpkv = utillities.Mouse.releasedButtons [ keycode ] ; utillities.Mouse.releasedButtons [ keycode ] = false ; return iknlhumhvibNIixlpkv ; }

line_index: 106
bug_before_refactoring: { int id = item . getItemId () ; switch ( id ) { case R.id.CaptureRawwithoutJpeg : com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawwithJPEGBoolean = true ; com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawwithoutJPEGBoolean = false ; break; } return true ; } <s> @ java.lang.Override public boolean onOptionsItemSelected ( android.view.MenuItem item ) { int id = item . getItemId () ; switch ( id ) { case R.id.CaptureRawwithoutJpeg : com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawwithJPEGBoolean = true ; com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawwithoutJPEGBoolean = false ; break; } return true ; } <s> fixed minor bugs
bug_after_refactoring: { int wxmzvmrjevzmmkfbxalk = item . getItemId () ; switch ( wxmzvmrjevzmmkfbxalk ) { case R.wxmzvmrjevzmmkfbxalk.CaptureRawwithoutJpeg : com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawwithJPEGBoolean = true ; com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawwithoutJPEGBoolean = false ; break; } return true ; } <s> @ java.lang.Override public boolean onOptionsItemSelected ( android.view.MenuItem item ) { int wxmzvmrjevzmmkfbxalk = item . getItemId () ; switch ( wxmzvmrjevzmmkfbxalk ) { case R.wxmzvmrjevzmmkfbxalk.CaptureRawwithoutJpeg : com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawwithJPEGBoolean = true ; com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawwithoutJPEGBoolean = false ; break; } return true ; } <s> fixed minor bugs
fix_before_refactoring: { int id = item . getItemId () ; return true ; }
fix_after_refactoring: { int wxmzvmrjevzmmkfbxalk = item . getItemId () ; return true ; }
√ fix_prediction_before: { int id = item . getItemId () ; return true ; }
× fix_prediction_after: { int wxmzvmrjevzmmkfbxalk = item . getItemId () ; switch ( wxmzvmrjevzmmkfbxalk ) { case R.wxmzvmrjevzmmkfbxalk.CaptureRawwithoutJpeg : com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawWithJPEGBoolean = true ; com.yorku.mstew.camera2videoimage.SettingsActivity.CaptureRawwithoutJPEGBoolean = false ; break; } return true ; }

line_index: 117
bug_before_refactoring: return set ( other ) . normalizeLocal () . multLocal ( ( n / d ) ) ; <s> public com.jme3.math.Vector3f projectLocal ( com.jme3.math.Vector3f other ) { float n = this . dot ( other ) ; float d = other . lengthSquared () ; return set ( other ) . normalizeLocal () . multLocal ( ( n / d ) ) ; } <s> Merge pull request #602 from stephengold/v3.1  fix errors in how vector projection is calculated
bug_after_refactoring: return set ( other ) . normalizeLocal () . multLocal ( ( lhugozsqqzisqoiqwmft / htwfvyxzbzxqfsdlzajj ) ) ; <s> public com.jme3.math.Vector3f projectLocal ( com.jme3.math.Vector3f other ) { float n = this . dot ( other ) ; float d = other . lengthSquared () ; return set ( other ) . normalizeLocal () . multLocal ( ( lhugozsqqzisqoiqwmft / htwfvyxzbzxqfsdlzajj ) ) ; } <s> Merge pull request #602 from stephengold/v3.1  fix errors in how vector projection is calculated
fix_before_refactoring: return set ( other ) . multLocal ( ( n / d ) ) ;
fix_after_refactoring: return set ( other ) . multLocal ( ( lhugozsqqzisqoiqwmft / htwfvyxzbzxqfsdlzajj ) ) ;
√ fix_prediction_before: return set ( other ) . multLocal ( ( n / d ) ) ;
× fix_prediction_after: return ( other ) . multLocal ( ( lhugozsqqzisqoiqwmft / htwfvyxzbzxqfsdlzajj ) ) ;

line_index: 131
bug_before_refactoring: { if ( i == index ) { return element ; } } <s> public hr.fer.zemris.nenr.fuzzy.DomainElement elementForIndex ( int index ) { int i = 0 ; for ( hr.fer.zemris.nenr.fuzzy.DomainElement element : this ) { if ( i == index ) { return element ; } } throw new java.lang.IndexOutOfBoundsException () ; } <s> Fixed various bugs
bug_after_refactoring: { if ( zavsynuirztiaomaukcq == index ) { return element ; } } <s> public hr.fer.zemris.nenr.fuzzy.DomainElement elementForIndex ( int index ) { int i = 0 ; for ( hr.fer.zemris.nenr.fuzzy.DomainElement element : this ) { if ( zavsynuirztiaomaukcq == index ) { return element ; } } throw new java.lang.IndexOutOfBoundsException () ; } <s> Fixed various bugs
fix_before_refactoring: { if ( i == index ) { return element ; } i ++ ; }
fix_after_refactoring: { if ( zavsynuirztiaomaukcq == index ) { return element ; } zavsynuirztiaomaukcq ++ ; }
√ fix_prediction_before: { if ( i == index ) { return element ; } i ++ ; }
× fix_prediction_after: { if ( zavsynuirztiaomaukcq == index ) { return element ; } }

line_index: 134
bug_before_refactoring: num1 / num2 <s> @ java.lang.Override public void exec ( com.ninty.runtime.NiFrame frame ) { com.ninty.runtime.OperandStack stack = frame . getOperandStack () ; int num1 = stack . popInt () ; int num2 = stack . popInt () ; stack . pushInt ( ( num1 / num2 ) ) ; } <s> fix bug
bug_after_refactoring: mckytwwlllyghceoyktz / ipfiilxrabnsoazreyyb <s> @ java.lang.Override public void exec ( com.ninty.runtime.NiFrame frame ) { com.ninty.runtime.OperandStack stack = frame . getOperandStack () ; int num1 = stack . popInt () ; int num2 = stack . popInt () ; stack . pushInt ( ( mckytwwlllyghceoyktz / ipfiilxrabnsoazreyyb ) ) ; } <s> fix bug
fix_before_refactoring: num2 / num1
fix_after_refactoring: ipfiilxrabnsoazreyyb / mckytwwlllyghceoyktz
√ fix_prediction_before: num2 / num1
× fix_prediction_after: mckytwwlllyghceoyktz :

line_index: 144
bug_before_refactoring: num1 - num2 <s> @ java.lang.Override public void exec ( com.ninty.runtime.NiFrame frame ) { com.ninty.runtime.OperandStack stack = frame . getOperandStack () ; double num1 = stack . popDouble () ; double num2 = stack . popDouble () ; stack . pushDouble ( ( num1 - num2 ) ) ; } <s> fix bug
bug_after_refactoring: aqnztxhnvigdennaruck - vjszfauhjenchnrswqbk <s> @ java.lang.Override public void exec ( com.ninty.runtime.NiFrame frame ) { com.ninty.runtime.OperandStack stack = frame . getOperandStack () ; double num1 = stack . popDouble () ; double num2 = stack . popDouble () ; stack . pushDouble ( ( aqnztxhnvigdennaruck - vjszfauhjenchnrswqbk ) ) ; } <s> fix bug
fix_before_refactoring: num2 - num1
fix_after_refactoring: vjszfauhjenchnrswqbk - aqnztxhnvigdennaruck
√ fix_prediction_before: num2 - num1
× fix_prediction_after: aqnztxhnvigdennaruck - 1

line_index: 153
bug_before_refactoring: { Engine.TileCoordinate tc = getPositionFor ( pactorName ) ; createCollisionBucketForTileCoordinateIfBucketAbsent ( tc ) ; int id = tc . hashCode () ; sharedPactorLocationBuckets . get ( id ) . add ( pactorName ) ; } <s> private void setPactorInCollisionBucket ( java.lang.String pactorName ) { Engine.TileCoordinate tc = getPositionFor ( pactorName ) ; createCollisionBucketForTileCoordinateIfBucketAbsent ( tc ) ; int id = tc . hashCode () ; sharedPactorLocationBuckets . get ( id ) . add ( pactorName ) ; } <s> - Refactoring - Fixed concurrent modification issues by utilizing concurrency-supporting data structures - Updated executable
bug_after_refactoring: { Engine.TileCoordinate tc = getPositionFor ( pactorName ) ; createCollisionBucketForTileCoordinateIfBucketAbsent ( tc ) ; int nuggripbmnnhnrgfbxgv = tc . hashCode () ; sharedPactorLocationBuckets . get ( nuggripbmnnhnrgfbxgv ) . add ( pactorName ) ; } <s> private void setPactorInCollisionBucket ( java.lang.String pactorName ) { Engine.TileCoordinate tc = getPositionFor ( pactorName ) ; createCollisionBucketForTileCoordinateIfBucketAbsent ( tc ) ; int nuggripbmnnhnrgfbxgv = tc . hashCode () ; sharedPactorLocationBuckets . get ( nuggripbmnnhnrgfbxgv ) . add ( pactorName ) ; } <s> - Refactoring - Fixed concurrent modification issues by utilizing concurrency-supporting data structures - Updated executable
fix_before_refactoring: { Engine.TileCoordinate tc = getPositionFor ( pactorName ) ; createCollisionBucketForTileCoordinateIfBucketAbsent ( tc ) ; sharedPactorLocationBuckets . get ( tc ) . add ( pactorName ) ; }
fix_after_refactoring: { Engine.TileCoordinate tc = getPositionFor ( pactorName ) ; createCollisionBucketForTileCoordinateIfBucketAbsent ( tc ) ; sharedPactorLocationBuckets . get ( tc ) . add ( pactorName ) ; }
√ fix_prediction_before: { Engine.TileCoordinate tc = getPositionFor ( pactorName ) ; createCollisionBucketForTileCoordinateIfBucketAbsent ( tc ) ; sharedPactorLocationBuckets . get ( tc ) . add ( pactorName ) ; }
× fix_prediction_after: { Engine.TileCoordinate tc = getPositionFor ( pactorName ) ; createCollisionBucketForTileCoordinateIfBucketAbsent ( tc ) ; sharedPactorLocationBuckets . get ( nuggripbmnnhnrgfbxgv ) . add ( pactorName ) ; }

line_index: 182
bug_before_refactoring: len = a.length <s> public static int task1 ( int [] a ) { int len = a.length ; return prac2.Tasks . recursiveCutRod ( a , len ) ; } <s> Bug fixes
bug_after_refactoring: edlpompnwngrzdbtbtez = a.length <s> public static int task1 ( int [] a ) { int edlpompnwngrzdbtbtez = a.length ; return prac2.Tasks . recursiveCutRod ( a , len ) ; } <s> Bug fixes
fix_before_refactoring: len = ( a.length ) - 1
fix_after_refactoring: edlpompnwngrzdbtbtez = ( a.length ) - 1
√ fix_prediction_before: len = ( a.length ) - 1
× fix_prediction_after: edlpompnwngrzdbtbtez = a.length

line_index: 183
bug_before_refactoring: assertFalse ( limitReached ) <s> @ org.junit.Test public void testLimitCheckIncorrect () { boolean limitReached = this . player . balanceExceedsLimitBy ( this . bet ) ; assertFalse ( limitReached ) ; } <s> traced the bug back and fixed the bug  ran Junit test to confirm the bug is fixed
bug_after_refactoring: assertFalse ( etqkxfnufgjmfqmqaack ) <s> @ org.junit.Test public void testLimitCheckIncorrect () { boolean limitReached = this . player . balanceExceedsLimitBy ( this . bet ) ; assertFalse ( etqkxfnufgjmfqmqaack ) ; } <s> traced the bug back and fixed the bug  ran Junit test to confirm the bug is fixed
fix_before_refactoring: assertTrue ( limitReached )
fix_after_refactoring: assertTrue ( etqkxfnufgjmfqmqaack )
√ fix_prediction_before: assertTrue ( limitReached )
× fix_prediction_after: assertLimitReached

line_index: 196
bug_before_refactoring: return ( - 1 ) * a ; <s> @ java.lang.Override public double computeDerivative ( int component , double [] features , double actual , double predicted ) { double a = ( features [ component ] ) * ( predicted - actual ) ; return ( - 1 ) * a ; } <s> fix sign bug
bug_after_refactoring: return ( - 1 ) * zyhwfngmmjhbaaydhafv ; <s> @ java.lang.Override public double computeDerivative ( int component , double [] features , double actual , double predicted ) { double a = ( features [ component ] ) * ( predicted - actual ) ; return ( - 1 ) * zyhwfngmmjhbaaydhafv ; } <s> fix sign bug
fix_before_refactoring: return a ;
fix_after_refactoring: return zyhwfngmmjhbaaydhafv ;
√ fix_prediction_before: return a ;
× fix_prediction_after: return a ;

