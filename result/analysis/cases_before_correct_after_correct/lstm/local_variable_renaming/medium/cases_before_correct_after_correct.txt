line_index: 7
bug_before_refactoring: public java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > getConflictResponses () { final java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > servers = new java.util.ArrayList < com.orientechnologies.orient.server.distributed.ODistributedResponse > () ; int bestGroupSoFar = getBestResponsesGroup () ; for ( int i = 0 ; i < ( responseGroups . size () ) ; ++ i ) { if ( i != bestGroupSoFar ) { for ( com.orientechnologies.orient.server.distributed.ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; } } return servers ; } <s> public java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > getConflictResponses () { final java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > servers = new java.util.ArrayList < com.orientechnologies.orient.server.distributed.ODistributedResponse > () ; int bestGroupSoFar = getBestResponsesGroup () ; for ( int i = 0 ; i < ( responseGroups . size () ) ; ++ i ) { if ( i != bestGroupSoFar ) { for ( com.orientechnologies.orient.server.distributed.ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; } } return servers ; } <s> Distributed: fixed issue with timeouts
bug_after_refactoring: public java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > getConflictResponses () { final java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > servers = new java.util.ArrayList < com.orientechnologies.orient.server.distributed.ODistributedResponse > () ; int tbaojmqavdchsxhfrpsw = getBestResponsesGroup () ; for ( int i = 0 ; i < ( responseGroups . size () ) ; ++ i ) { if ( i != tbaojmqavdchsxhfrpsw ) { for ( com.orientechnologies.orient.server.distributed.ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; } } return servers ; } <s> public java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > getConflictResponses () { final java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > servers = new java.util.ArrayList < com.orientechnologies.orient.server.distributed.ODistributedResponse > () ; int tbaojmqavdchsxhfrpsw = getBestResponsesGroup () ; for ( int i = 0 ; i < ( responseGroups . size () ) ; ++ i ) { if ( i != tbaojmqavdchsxhfrpsw ) { for ( com.orientechnologies.orient.server.distributed.ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; } } return servers ; } <s> Distributed: fixed issue with timeouts
fix_before_refactoring: protected java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > getConflictResponses () { final java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > servers = new java.util.ArrayList < com.orientechnologies.orient.server.distributed.ODistributedResponse > () ; int bestGroupSoFar = getBestResponsesGroup () ; for ( int i = 0 ; i < ( responseGroups . size () ) ; ++ i ) { if ( i != bestGroupSoFar ) { for ( com.orientechnologies.orient.server.distributed.ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; } } return servers ; }
fix_after_refactoring: protected java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > getConflictResponses () { final java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > servers = new java.util.ArrayList < com.orientechnologies.orient.server.distributed.ODistributedResponse > () ; int tbaojmqavdchsxhfrpsw = getBestResponsesGroup () ; for ( int i = 0 ; i < ( responseGroups . size () ) ; ++ i ) { if ( i != tbaojmqavdchsxhfrpsw ) { for ( com.orientechnologies.orient.server.distributed.ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; } } return servers ; }
√ fix_prediction_before: protected java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > getConflictResponses () { final java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > servers = new java.util.ArrayList < com.orientechnologies.orient.server.distributed.ODistributedResponse > () ; int bestGroupSoFar = getBestResponsesGroup () ; for ( int i = 0 ; i < ( responseGroups . size () ) ; ++ i ) { if ( i != bestGroupSoFar ) { for ( com.orientechnologies.orient.server.distributed.ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; } } return servers ; }
√ fix_prediction_after: protected java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > getConflictResponses () { final java.util.List < com.orientechnologies.orient.server.distributed.ODistributedResponse > servers = new java.util.ArrayList < com.orientechnologies.orient.server.distributed.ODistributedResponse > () ; int tbaojmqavdchsxhfrpsw = getBestResponsesGroup () ; for ( int i = 0 ; i < ( responseGroups . size () ) ; ++ i ) { if ( i != tbaojmqavdchsxhfrpsw ) { for ( com.orientechnologies.orient.server.distributed.ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; } } return servers ; }

line_index: 84
bug_before_refactoring: { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } } <s> public void testIterFilterLimitOffset () { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } } <s> Fixed compilation error (using SienaFutureProxy instead of SienaFuture)
bug_after_refactoring: { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int ipbcfqoooibbsoxxnwqe = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ ipbcfqoooibbsoxxnwqe ] , PersonIntKey ) ; ipbcfqoooibbsoxxnwqe ++ ; } } <s> public void testIterFilterLimitOffset () { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int ipbcfqoooibbsoxxnwqe = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ ipbcfqoooibbsoxxnwqe ] , PersonIntKey ) ; ipbcfqoooibbsoxxnwqe ++ ; } } <s> Fixed compilation error (using SienaFutureProxy instead of SienaFuture)
fix_before_refactoring: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } }
fix_after_refactoring: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int ipbcfqoooibbsoxxnwqe = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ ipbcfqoooibbsoxxnwqe ] , PersonIntKey ) ; ipbcfqoooibbsoxxnwqe ++ ; } }
√ fix_prediction_before: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } }
√ fix_prediction_after: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int ipbcfqoooibbsoxxnwqe = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ ipbcfqoooibbsoxxnwqe ] , PersonIntKey ) ; ipbcfqoooibbsoxxnwqe ++ ; } }

line_index: 190
bug_before_refactoring: degreeOfFreedom = ( dataset.length ) - 1 <s> public double variance ( double [] dataset ) { double degreeOfFreedom = ( dataset.length ) - 1 ; double var = 0 ; double mean = mean ( dataset ) ; for ( int i = 0 ; i < ( dataset.length ) ; i ++ ) { var += java.lang.Math . pow ( ( ( dataset [ i ] ) - mean ) , 2 ) ; } var /= degreeOfFreedom ; return var ; } <s> bugfix
bug_after_refactoring: tiwadnravhoozasunphp = ( dataset.length ) - 1 <s> public double variance ( double [] dataset ) { double tiwadnravhoozasunphp = ( dataset.length ) - 1 ; double var = 0 ; double mean = mean ( dataset ) ; for ( int i = 0 ; i < ( dataset.length ) ; i ++ ) { var += java.lang.Math . pow ( ( ( dataset [ i ] ) - mean ) , 2 ) ; } var /= degreeOfFreedom ; return var ; } <s> bugfix
fix_before_refactoring: degreeOfFreedom = dataset.length
fix_after_refactoring: tiwadnravhoozasunphp = dataset.length
√ fix_prediction_before: degreeOfFreedom = dataset.length
√ fix_prediction_after: tiwadnravhoozasunphp = dataset.length

line_index: 246
bug_before_refactoring: private java.lang.String receive () { byte [] data = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( data , data.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; } <s> private java.lang.String receive () { byte [] data = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( data , data.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; } <s> - implement listen thread - need to solve the problem of data length
bug_after_refactoring: private java.lang.String receive () { byte [] sucbzfeuioadgafbwtrp = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( sucbzfeuioadgafbwtrp , sucbzfeuioadgafbwtrp.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; } <s> private java.lang.String receive () { byte [] sucbzfeuioadgafbwtrp = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( sucbzfeuioadgafbwtrp , sucbzfeuioadgafbwtrp.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; } <s> - implement listen thread - need to solve the problem of data length
fix_before_refactoring: public java.lang.String receive () { byte [] data = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( data , data.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; }
fix_after_refactoring: public java.lang.String receive () { byte [] sucbzfeuioadgafbwtrp = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( sucbzfeuioadgafbwtrp , sucbzfeuioadgafbwtrp.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; }
√ fix_prediction_before: public java.lang.String receive () { byte [] data = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( data , data.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; }
√ fix_prediction_after: public java.lang.String receive () { byte [] sucbzfeuioadgafbwtrp = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( sucbzfeuioadgafbwtrp , sucbzfeuioadgafbwtrp.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; }

line_index: 291
bug_before_refactoring: private static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int score = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { score += pairTimes . get ( i ) . getPair () . getScore () ; } return score ; } <s> private static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int score = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { score += pairTimes . get ( i ) . getPair () . getScore () ; } return score ; } <s> Added Hungarian unit tests and fixed a minor line matrix bug
bug_after_refactoring: private static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int qiyemvxxwlukvencrhaw = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { qiyemvxxwlukvencrhaw += pairTimes . get ( i ) . getPair () . getScore () ; } return qiyemvxxwlukvencrhaw ; } <s> private static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int qiyemvxxwlukvencrhaw = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { qiyemvxxwlukvencrhaw += pairTimes . get ( i ) . getPair () . getScore () ; } return qiyemvxxwlukvencrhaw ; } <s> Added Hungarian unit tests and fixed a minor line matrix bug
fix_before_refactoring: public static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int score = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { score += pairTimes . get ( i ) . getPair () . getScore () ; } return score ; }
fix_after_refactoring: public static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int qiyemvxxwlukvencrhaw = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { qiyemvxxwlukvencrhaw += pairTimes . get ( i ) . getPair () . getScore () ; } return qiyemvxxwlukvencrhaw ; }
√ fix_prediction_before: public static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int score = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { score += pairTimes . get ( i ) . getPair () . getScore () ; } return score ; }
√ fix_prediction_after: public static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int qiyemvxxwlukvencrhaw = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { qiyemvxxwlukvencrhaw += pairTimes . get ( i ) . getPair () . getScore () ; } return qiyemvxxwlukvencrhaw ; }

line_index: 406
bug_before_refactoring: { int strokeColor = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( strokeColor ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; android.widget.Toast . makeText ( this , ( "Circle: " + ( circle . getTag () . toString () ) ) , Toast.LENGTH_SHORT ) . show () ; } <s> private void ToggleCircleColor ( com.google.android.gms.maps.model.Circle circle ) { int strokeColor = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( strokeColor ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; android.widget.Toast . makeText ( this , ( "Circle: " + ( circle . getTag () . toString () ) ) , Toast.LENGTH_SHORT ) . show () ; } <s> Fix some bugs  on present round-1-day
bug_after_refactoring: { int kkavbzbyyrvuryqozteg = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( kkavbzbyyrvuryqozteg ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; android.widget.Toast . makeText ( this , ( "Circle: " + ( circle . getTag () . toString () ) ) , Toast.LENGTH_SHORT ) . show () ; } <s> private void ToggleCircleColor ( com.google.android.gms.maps.model.Circle circle ) { int kkavbzbyyrvuryqozteg = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( kkavbzbyyrvuryqozteg ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; android.widget.Toast . makeText ( this , ( "Circle: " + ( circle . getTag () . toString () ) ) , Toast.LENGTH_SHORT ) . show () ; } <s> Fix some bugs  on present round-1-day
fix_before_refactoring: { int strokeColor = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( strokeColor ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; }
fix_after_refactoring: { int kkavbzbyyrvuryqozteg = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( kkavbzbyyrvuryqozteg ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; }
√ fix_prediction_before: { int strokeColor = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( strokeColor ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; }
√ fix_prediction_after: { int kkavbzbyyrvuryqozteg = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( kkavbzbyyrvuryqozteg ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; }

line_index: 440
bug_before_refactoring: int planeSize = loci.formats.FormatTools . getPlaneSize ( this ) ; <s> @ java.lang.Override public byte [] openBytes ( int no , byte [] buf , int x , int y , int w , int h ) throws java.io.IOException , loci.formats.FormatException { loci.formats.FormatTools . checkPlaneParameters ( this , no , buf.length , x , y , w , h ) ; int planeSize = loci.formats.FormatTools . getPlaneSize ( this ) ; pixelFile . seek ( ( ( pixelOffset ) + ( no * planeSize ) ) ) ; readPlane ( pixelFile , x , y , w , h , buf ) ; return buf ; } <s> merge develop -Dorg -Sno-error: PR 2345 (Fixes crash when loading large .nii files)
bug_after_refactoring: int jdpygddalayogalbpgvs = loci.formats.FormatTools . getPlaneSize ( this ) ; <s> @ java.lang.Override public byte [] openBytes ( int no , byte [] buf , int x , int y , int w , int h ) throws java.io.IOException , loci.formats.FormatException { loci.formats.FormatTools . checkPlaneParameters ( this , no , buf.length , x , y , w , h ) ; int jdpygddalayogalbpgvs = loci.formats.FormatTools . getPlaneSize ( this ) ; pixelFile . seek ( ( ( pixelOffset ) + ( no * planeSize ) ) ) ; readPlane ( pixelFile , x , y , w , h , buf ) ; return buf ; } <s> merge develop -Dorg -Sno-error: PR 2345 (Fixes crash when loading large .nii files)
fix_before_refactoring: long planeSize = loci.formats.FormatTools . getPlaneSize ( this ) ;
fix_after_refactoring: long jdpygddalayogalbpgvs = loci.formats.FormatTools . getPlaneSize ( this ) ;
√ fix_prediction_before: long planeSize = loci.formats.FormatTools . getPlaneSize ( this ) ;
√ fix_prediction_after: long jdpygddalayogalbpgvs = loci.formats.FormatTools . getPlaneSize ( this ) ;

line_index: 486
bug_before_refactoring: private int getPlayerRank () { int rank = - 1 ; int count = 0 ; for ( int i = 0 ; i < ( Game.HI_SCORES . size () ) ; i ++ ) { if ( ( player . getScore () ) >= ( Game.HI_SCORES . get ( i ) . getScore () ) ) rank = ( Game.HI_SCORES . size () ) - ( ++ count ) ; } return rank ; } <s> private int getPlayerRank () { int rank = - 1 ; int count = 0 ; for ( int i = 0 ; i < ( Game.HI_SCORES . size () ) ; i ++ ) { if ( ( player . getScore () ) >= ( Game.HI_SCORES . get ( i ) . getScore () ) ) rank = ( Game.HI_SCORES . size () ) - ( ++ count ) ; } return rank ; } <s> Fixed bug where player is prompted to enter initials more than once.
bug_after_refactoring: private int getPlayerRank () { int bfplrssybqgqwmutuobl = - 1 ; int vkddoewrjdgbfuggezmf = 0 ; for ( int i = 0 ; i < ( Game.HI_SCORES . size () ) ; i ++ ) { if ( ( player . getScore () ) >= ( Game.HI_SCORES . get ( i ) . getScore () ) ) bfplrssybqgqwmutuobl = ( Game.HI_SCORES . size () ) - ( ++ vkddoewrjdgbfuggezmf ) ; } return bfplrssybqgqwmutuobl ; } <s> private int getPlayerRank () { int bfplrssybqgqwmutuobl = - 1 ; int vkddoewrjdgbfuggezmf = 0 ; for ( int i = 0 ; i < ( Game.HI_SCORES . size () ) ; i ++ ) { if ( ( player . getScore () ) >= ( Game.HI_SCORES . get ( i ) . getScore () ) ) bfplrssybqgqwmutuobl = ( Game.HI_SCORES . size () ) - ( ++ vkddoewrjdgbfuggezmf ) ; } return bfplrssybqgqwmutuobl ; } <s> Fixed bug where player is prompted to enter initials more than once.
fix_before_refactoring: public int getPlayerRank () { int rank = - 1 ; int count = 0 ; for ( int i = 0 ; i < ( Game.HI_SCORES . size () ) ; i ++ ) { if ( ( player . getScore () ) >= ( Game.HI_SCORES . get ( i ) . getScore () ) ) rank = ( Game.HI_SCORES . size () ) - ( ++ count ) ; } return rank ; }
fix_after_refactoring: public int getPlayerRank () { int bfplrssybqgqwmutuobl = - 1 ; int vkddoewrjdgbfuggezmf = 0 ; for ( int i = 0 ; i < ( Game.HI_SCORES . size () ) ; i ++ ) { if ( ( player . getScore () ) >= ( Game.HI_SCORES . get ( i ) . getScore () ) ) bfplrssybqgqwmutuobl = ( Game.HI_SCORES . size () ) - ( ++ vkddoewrjdgbfuggezmf ) ; } return bfplrssybqgqwmutuobl ; }
√ fix_prediction_before: public int getPlayerRank () { int rank = - 1 ; int count = 0 ; for ( int i = 0 ; i < ( Game.HI_SCORES . size () ) ; i ++ ) { if ( ( player . getScore () ) >= ( Game.HI_SCORES . get ( i ) . getScore () ) ) rank = ( Game.HI_SCORES . size () ) - ( ++ count ) ; } return rank ; }
√ fix_prediction_after: public int getPlayerRank () { int bfplrssybqgqwmutuobl = - 1 ; int vkddoewrjdgbfuggezmf = 0 ; for ( int i = 0 ; i < ( Game.HI_SCORES . size () ) ; i ++ ) { if ( ( player . getScore () ) >= ( Game.HI_SCORES . get ( i ) . getScore () ) ) bfplrssybqgqwmutuobl = ( Game.HI_SCORES . size () ) - ( ++ vkddoewrjdgbfuggezmf ) ; } return bfplrssybqgqwmutuobl ; }

line_index: 516
bug_before_refactoring: org.powertac.tournament.beans.Round . getRoundFromId ( roundId , true ) <s> public void afterPropertiesSet ( ) throws java.lang.Exception { int roundId = getRoundId () ; if ( roundId < 1 ) { return; } round = org.powertac.tournament.beans.Round . getRoundFromId ( roundId , true ) ; loadRoundInfo () ; loadParticipantInfo () ; loadCsvLinks () ; loadMaps () ; } <s> Bugfix : load fat round for actionRound
bug_after_refactoring: org.powertac.tournament.beans.Round . getRoundFromId ( dmtrjyevbmrhedowugjc , true ) <s> public void afterPropertiesSet ( ) throws java.lang.Exception { int roundId = getRoundId () ; if ( roundId < 1 ) { return; } round = org.powertac.tournament.beans.Round . getRoundFromId ( dmtrjyevbmrhedowugjc , true ) ; loadRoundInfo () ; loadParticipantInfo () ; loadCsvLinks () ; loadMaps () ; } <s> Bugfix : load fat round for actionRound
fix_before_refactoring: org.powertac.tournament.beans.Round . getRoundFromId ( roundId , false )
fix_after_refactoring: org.powertac.tournament.beans.Round . getRoundFromId ( dmtrjyevbmrhedowugjc , false )
√ fix_prediction_before: org.powertac.tournament.beans.Round . getRoundFromId ( roundId , false )
√ fix_prediction_after: org.powertac.tournament.beans.Round . getRoundFromId ( dmtrjyevbmrhedowugjc , false )

line_index: 584
bug_before_refactoring: if ( ( chapter . getStartTimeOffset () ) > position ) { ret = chapter . getStartTimeOffset () ; break; } <s> public long getNextChapterStart ( long position ) { long ret = com.monsterbutt.homeview.plex.media.PlexVideoItem.BAD_CHAPTER_START ; if ( hasChapters () ) { for ( com.monsterbutt.homeview.plex.media.Chapter chapter : mVideo . getChapters () ) { if ( ( chapter . getStartTimeOffset () ) > position ) { ret = chapter . getStartTimeOffset () ; break; } } } return ret ; } <s> fix chapter starts issue
bug_after_refactoring: if ( ( chapter . getStartTimeOffset () ) > position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; } <s> public long getNextChapterStart ( long position ) { long ret = com.monsterbutt.homeview.plex.media.PlexVideoItem.BAD_CHAPTER_START ; if ( hasChapters () ) { for ( com.monsterbutt.homeview.plex.media.Chapter chapter : mVideo . getChapters () ) { if ( ( chapter . getStartTimeOffset () ) > position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; } } } return ret ; } <s> fix chapter starts issue
fix_before_refactoring: if ( ( chapter . getStartTimeOffset () ) >= position ) { ret = chapter . getStartTimeOffset () ; break; }
fix_after_refactoring: if ( ( chapter . getStartTimeOffset () ) >= position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; }
√ fix_prediction_before: if ( ( chapter . getStartTimeOffset () ) >= position ) { ret = chapter . getStartTimeOffset () ; break; }
√ fix_prediction_after: if ( ( chapter . getStartTimeOffset () ) >= position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; }

line_index: 706
bug_before_refactoring: if ( ( armor > 0 ) || ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; } <s> public int hit ( int armor ) { int damage ; if ( ( armor > 0 ) || ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; } return damage < 0 ? 0 : damage ; } <s> Final Commit of project one. Includes updated main for testing all weapons  debugged weapon factory  and fixed Axe ignoring armor when they werent supposed to bug.   -By Kristopher Doidge
bug_after_refactoring: if ( ( armor > 0 ) || ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; } <s> public int hit ( int armor ) { int damage ; if ( ( armor > 0 ) || ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; } return damage < 0 ? 0 : damage ; } <s> Final Commit of project one. Includes updated main for testing all weapons  debugged weapon factory  and fixed Axe ignoring armor when they werent supposed to bug.   -By Kristopher Doidge
fix_before_refactoring: if ( ( armor > 0 ) && ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; }
fix_after_refactoring: if ( ( armor > 0 ) && ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; }
√ fix_prediction_before: if ( ( armor > 0 ) && ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; }
√ fix_prediction_after: if ( ( armor > 0 ) && ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; }

line_index: 795
bug_before_refactoring: block . setNumBytes ( ( ( ( block . getNumBytes () ) + currLen ) - 4 ) ) <s> public void writeByteBufferImpl ( java.nio.ByteBuffer buf ) throws java.io.IOException { int currLen = buf . remaining () ; assert null != ( sChannel ) : "tcp socket not set yet, null value found." ; sChannel . write ( buf ) ; bufferPool . returnBuffer ( buf ) ; block . setNumBytes ( ( ( ( block . getNumBytes () ) + currLen ) - 4 ) ) ; bufferPool . returnBuffer ( buf ) ; } <s> fix bugs
bug_after_refactoring: block . setNumBytes ( ( ( ( block . getNumBytes () ) + nfrsckmjegkibcesftgh ) - 4 ) ) <s> public void writeByteBufferImpl ( java.nio.ByteBuffer buf ) throws java.io.IOException { int currLen = buf . remaining () ; assert null != ( sChannel ) : "tcp socket not set yet, null value found." ; sChannel . write ( buf ) ; bufferPool . returnBuffer ( buf ) ; block . setNumBytes ( ( ( ( block . getNumBytes () ) + nfrsckmjegkibcesftgh ) - 4 ) ) ; bufferPool . returnBuffer ( buf ) ; } <s> fix bugs
fix_before_refactoring: block . setNumBytes ( ( ( block . getNumBytes () ) + currLen ) )
fix_after_refactoring: block . setNumBytes ( ( ( block . getNumBytes () ) + nfrsckmjegkibcesftgh ) )
√ fix_prediction_before: block . setNumBytes ( ( ( block . getNumBytes () ) + currLen ) )
√ fix_prediction_after: block . setNumBytes ( ( ( block . getNumBytes () ) + nfrsckmjegkibcesftgh ) )

line_index: 873
bug_before_refactoring: public int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int playerRowCount = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { playerRowCount ++ ; } } return playerRowCount ; } <s> public int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int playerRowCount = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { playerRowCount ++ ; } } return playerRowCount ; } <s> Merge pull request #27 from k1s/master  Fixed errors and added some features according 5th module
bug_after_refactoring: public int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int jucjkrfmpojebsgileft = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { jucjkrfmpojebsgileft ++ ; } } return jucjkrfmpojebsgileft ; } <s> public int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int jucjkrfmpojebsgileft = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { jucjkrfmpojebsgileft ++ ; } } return jucjkrfmpojebsgileft ; } <s> Merge pull request #27 from k1s/master  Fixed errors and added some features according 5th module
fix_before_refactoring: private int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int playerRowCount = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { playerRowCount ++ ; } } return playerRowCount ; }
fix_after_refactoring: private int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int jucjkrfmpojebsgileft = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { jucjkrfmpojebsgileft ++ ; } } return jucjkrfmpojebsgileft ; }
√ fix_prediction_before: private int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int playerRowCount = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { playerRowCount ++ ; } } return playerRowCount ; }
√ fix_prediction_after: private int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int jucjkrfmpojebsgileft = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { jucjkrfmpojebsgileft ++ ; } } return jucjkrfmpojebsgileft ; }

