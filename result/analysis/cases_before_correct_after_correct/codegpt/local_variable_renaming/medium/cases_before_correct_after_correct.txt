line_index: 3
bug_before_refactoring: { int result = ( ( color ) != null ) ? color . hashCode () : 0 ; result = ( 31 * result ) + ( type . hashCode () ) ; result = ( 31 * result ) + ( ( image ) != null ? image . hashCode () : 0 ) ; result = ( 31 * result ) + ( position ) ; return result ; } <s> @ java.lang.Override public int hashCode () { int result = ( ( color ) != null ) ? color . hashCode () : 0 ; result = ( 31 * result ) + ( type . hashCode () ) ; result = ( 31 * result ) + ( ( image ) != null ? image . hashCode () : 0 ) ; result = ( 31 * result ) + ( position ) ; return result ; } <s> Fixed bug with position checks
bug_after_refactoring: { int ankegjzqhvhcnclzbekl = ( ( color ) != null ) ? color . hashCode () : 0 ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( type . hashCode () ) ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( ( image ) != null ? image . hashCode () : 0 ) ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( position ) ; return ankegjzqhvhcnclzbekl ; } <s> @ java.lang.Override public int hashCode () { int ankegjzqhvhcnclzbekl = ( ( color ) != null ) ? color . hashCode () : 0 ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( type . hashCode () ) ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( ( image ) != null ? image . hashCode () : 0 ) ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( position ) ; return ankegjzqhvhcnclzbekl ; } <s> Fixed bug with position checks
fix_before_refactoring: { int result = ( ( color ) != null ) ? color . hashCode () : 0 ; result = ( 31 * result ) + ( type . hashCode () ) ; result = ( 31 * result ) + ( ( image ) != null ? image . hashCode () : 0 ) ; return result ; }
fix_after_refactoring: { int ankegjzqhvhcnclzbekl = ( ( color ) != null ) ? color . hashCode () : 0 ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( type . hashCode () ) ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( ( image ) != null ? image . hashCode () : 0 ) ; return ankegjzqhvhcnclzbekl ; }
√ fix_prediction_before: { int result = ( ( color ) != null ) ? color . hashCode () : 0 ; result = ( 31 * result ) + ( type . hashCode () ) ; result = ( 31 * result ) + ( ( image ) != null ? image . hashCode () : 0 ) ; return result ; }
√ fix_prediction_after: { int ankegjzqhvhcnclzbekl = ( ( color ) != null ) ? color . hashCode () : 0 ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( type . hashCode () ) ; ankegjzqhvhcnclzbekl = ( 31 * ankegjzqhvhcnclzbekl ) + ( ( image ) != null ? image . hashCode () : 0 ) ; return ankegjzqhvhcnclzbekl ; }

line_index: 35
bug_before_refactoring: for ( int i = index - ( side ) ; i < ( index + ( side ) ) ; i ++ ) { retArr [ j ] = array [ i ] ; j ++ ; } <s> private float [] cutArray ( int index ) { float [] retArr = new float [ filterSize ] ; int j = 0 ; for ( int i = index - ( side ) ; i < ( index + ( side ) ) ; i ++ ) { retArr [ j ] = array [ i ] ; j ++ ; } return retArr ; } <s> fixed out by one error  seemingly working parallelisation
bug_after_refactoring: for ( int i = index - ( side ) ; i < ( index + ( side ) ) ; i ++ ) { wzbaedbhlagvngtsjrqi [ ahlmzlddupaplqezsijj ] = array [ i ] ; ahlmzlddupaplqezsijj ++ ; } <s> private float [] cutArray ( int index ) { float [] retArr = new float [ filterSize ] ; int j = 0 ; for ( int i = index - ( side ) ; i < ( index + ( side ) ) ; i ++ ) { wzbaedbhlagvngtsjrqi [ ahlmzlddupaplqezsijj ] = array [ i ] ; ahlmzlddupaplqezsijj ++ ; } return retArr ; } <s> fixed out by one error  seemingly working parallelisation
fix_before_refactoring: for ( int i = index - ( side ) ; i <= ( index + ( side ) ) ; i ++ ) { retArr [ j ] = array [ i ] ; j ++ ; }
fix_after_refactoring: for ( int i = index - ( side ) ; i <= ( index + ( side ) ) ; i ++ ) { wzbaedbhlagvngtsjrqi [ ahlmzlddupaplqezsijj ] = array [ i ] ; ahlmzlddupaplqezsijj ++ ; }
√ fix_prediction_before: for ( int i = index - ( side ) ; i <= ( index + ( side ) ) ; i ++ ) { retArr [ j ] = array [ i ] ; j ++ ; }
√ fix_prediction_after: for ( int i = index - ( side ) ; i <= ( index + ( side ) ) ; i ++ ) { wzbaedbhlagvngtsjrqi [ ahlmzlddupaplqezsijj ] = array [ i ] ; ahlmzlddupaplqezsijj ++ ; }

line_index: 66
bug_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) <s> public int pull_chunk ( byte [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
bug_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , bborcwcykviuccnipdff ) <s> public int pull_chunk ( byte [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , bborcwcykviuccnipdff ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
fix_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
fix_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , bborcwcykviuccnipdff )
√ fix_prediction_before: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
√ fix_prediction_after: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , bborcwcykviuccnipdff )

line_index: 90
bug_before_refactoring: com.hp.autonomy.frontend.selenium.framework.state.TestStateAssert . verifyThat ( "Only one message showing at the bottom of search results" , occurrences , org.hamcrest.core.Is . is ( 1 ) ) <s> @ org.junit.Test @ com.hp.autonomy.frontend.selenium.framework.logging.ResolvedBug ( value = "FIND-93" ) public void testNoResults () { final com.autonomy.abc.selenium.find.results.ListView results = findService . search ( "thissearchwillalmostcertainlyreturnnoresults" ) ; new org.openqa.selenium.support.ui.WebDriverWait ( getDriver () , 60L ) . withMessage ( "No results message should appear" ) . until ( org.openqa.selenium.support.ui.ExpectedConditions . textToBePresentInElement ( results . resultsDiv () , "No results found" ) ) ; findPage . scrollToBottom () ; final int occurrences = org.apache.commons.lang3.StringUtils . countMatches ( results . resultsDiv () . getText () , "results found" ) ; com.hp.autonomy.frontend.selenium.framework.state.TestStateAssert . verifyThat ( "Only one message showing at the bottom of search results" , occurrences , org.hamcrest.core.Is . is ( 1 ) ) ; } <s> [FIND-719  FIND-1122] Marked ActiveBugs as resolved in ITs.  [rev: ivo.miller]
bug_after_refactoring: com.hp.autonomy.frontend.selenium.framework.state.TestStateAssert . verifyThat ( "Only one message showing at the bottom of search results" , agizvcxofjgcwblpftys , org.hamcrest.core.Is . is ( 1 ) ) <s> @ org.junit.Test @ com.hp.autonomy.frontend.selenium.framework.logging.ResolvedBug ( value = "FIND-93" ) public void testNoResults () { final com.autonomy.abc.selenium.find.results.ListView results = findService . search ( "thissearchwillalmostcertainlyreturnnoresults" ) ; new org.openqa.selenium.support.ui.WebDriverWait ( getDriver () , 60L ) . withMessage ( "No results message should appear" ) . until ( org.openqa.selenium.support.ui.ExpectedConditions . textToBePresentInElement ( results . resultsDiv () , "No results found" ) ) ; findPage . scrollToBottom () ; final int occurrences = org.apache.commons.lang3.StringUtils . countMatches ( results . resultsDiv () . getText () , "results found" ) ; com.hp.autonomy.frontend.selenium.framework.state.TestStateAssert . verifyThat ( "Only one message showing at the bottom of search results" , agizvcxofjgcwblpftys , org.hamcrest.core.Is . is ( 1 ) ) ; } <s> [FIND-719  FIND-1122] Marked ActiveBugs as resolved in ITs.  [rev: ivo.miller]
fix_before_refactoring: verifyThat ( "Only one message showing at the bottom of search results" , occurrences , org.hamcrest.core.Is . is ( 1 ) )
fix_after_refactoring: verifyThat ( "Only one message showing at the bottom of search results" , agizvcxofjgcwblpftys , org.hamcrest.core.Is . is ( 1 ) )
√ fix_prediction_before: verifyThat ( "Only one message showing at the bottom of search results" , occurrences , org.hamcrest.core.Is . is ( 1 ) )
√ fix_prediction_after: verifyThat ( "Only one message showing at the bottom of search results" , agizvcxofjgcwblpftys , org.hamcrest.core.Is . is ( 1 ) )

line_index: 96
bug_before_refactoring: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] time = tp . GetInput ( str ) ; java.lang.System.out . println ( time [ 0 ] ) ; java.util.Date date0 = new java.util.Date ( time [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; } <s> public java.lang.String getFormattedDate ( java.lang.String str ) { com.github.TimeParser tp = new com.github.TimeParser () ; long [] time = tp . GetInput ( str ) ; java.lang.System.out . println ( time [ 0 ] ) ; java.util.Date date0 = new java.util.Date ( time [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; } <s> Added comments and fixed the colon bug
bug_after_refactoring: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] ipnwblghnlbzacxwgtxx = tp . GetInput ( str ) ; java.lang.System.out . println ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.util.Date date0 = new java.util.Date ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; } <s> public java.lang.String getFormattedDate ( java.lang.String str ) { com.github.TimeParser tp = new com.github.TimeParser () ; long [] ipnwblghnlbzacxwgtxx = tp . GetInput ( str ) ; java.lang.System.out . println ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.util.Date date0 = new java.util.Date ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; } <s> Added comments and fixed the colon bug
fix_before_refactoring: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] time = tp . GetInput ( str ) ; java.util.Date date0 = new java.util.Date ( time [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; }
fix_after_refactoring: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] ipnwblghnlbzacxwgtxx = tp . GetInput ( str ) ; java.util.Date date0 = new java.util.Date ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; }
√ fix_prediction_before: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] time = tp . GetInput ( str ) ; java.util.Date date0 = new java.util.Date ( time [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; }
√ fix_prediction_after: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] ipnwblghnlbzacxwgtxx = tp . GetInput ( str ) ; java.util.Date date0 = new java.util.Date ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; }

line_index: 99
bug_before_refactoring: new workSQL.Employee ( hold , "" , "" , "" ) <s> public void actionPerformed ( java.awt.event.ActionEvent event ) { int hold = 0 ; newEmployee = new workSQL.Employee ( hold , "" , "" , "" ) ; workSQL.EmployeeDetailDialog addD = new workSQL.EmployeeDetailDialog ( thisFrame , thisFrame , "Add a new employee" , true , newEmployee ) ; addD.updateButton . setEnabled ( false ) ; addD.deleteButton . setEnabled ( false ) ; addD.employeeNumberField . setEnabled ( false ) ; addD . setVisible ( true ) ; } <s> Some errors have been fixed but lots of work left to do inorder to configure it with the final database.
bug_after_refactoring: new workSQL.Employee ( kvjcucfcidbpfwupcbxb , "" , "" , "" ) <s> public void actionPerformed ( java.awt.event.ActionEvent event ) { int hold = 0 ; newEmployee = new workSQL.Employee ( kvjcucfcidbpfwupcbxb , "" , "" , "" ) ; workSQL.EmployeeDetailDialog addD = new workSQL.EmployeeDetailDialog ( thisFrame , thisFrame , "Add a new employee" , true , newEmployee ) ; addD.updateButton . setEnabled ( false ) ; addD.deleteButton . setEnabled ( false ) ; addD.employeeNumberField . setEnabled ( false ) ; addD . setVisible ( true ) ; } <s> Some errors have been fixed but lots of work left to do inorder to configure it with the final database.
fix_before_refactoring: new workSQL.Employee ( hold , "" , "" , "" , "" )
fix_after_refactoring: new workSQL.Employee ( kvjcucfcidbpfwupcbxb , "" , "" , "" , "" )
√ fix_prediction_before: new workSQL.Employee ( hold , "" , "" , "" , "" )
√ fix_prediction_after: new workSQL.Employee ( kvjcucfcidbpfwupcbxb , "" , "" , "" , "" )

line_index: 103
bug_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) <s> public int pull_chunk ( double [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
bug_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ntlogeadbvdfbsmfwicj ) <s> public int pull_chunk ( double [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ntlogeadbvdfbsmfwicj ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
fix_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
fix_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ntlogeadbvdfbsmfwicj )
√ fix_prediction_before: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
√ fix_prediction_after: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ntlogeadbvdfbsmfwicj )

line_index: 123
bug_before_refactoring: currentY = maxY - 1 <s> public void computeSegments () { int maxX = ( graph . dimX () ) - 1 ; int maxY = ( graph . dimY () ) - 1 ; for ( int currentY = maxY - 1 ; currentY >= 0 ; currentY -- ) { currentWindow = sbr.Range . TwoDimensionalRange ( 0 , maxX , currentY , maxY ) ; computeSegmentsInRange () ; for ( sbr.Segment seg : segments ) assert ! ( seg . getLinks () . isEmpty () ) ; } } <s> Fix 1x1 Noc unit test  A 1x1 NoC has the same start/terminal vertice. Also  the error when catching left/right vertices was fixed. Commit:Fix TaskNumber:#48
bug_after_refactoring: currentY = lqaogcpijbvsszccxesd - 1 <s> public void computeSegments () { int maxX = ( graph . dimX () ) - 1 ; int maxY = ( graph . dimY () ) - 1 ; for ( int currentY = lqaogcpijbvsszccxesd - 1 ; currentY >= 0 ; currentY -- ) { currentWindow = sbr.Range . TwoDimensionalRange ( 0 , maxX , currentY , maxY ) ; computeSegmentsInRange () ; for ( sbr.Segment seg : segments ) assert ! ( seg . getLinks () . isEmpty () ) ; } } <s> Fix 1x1 Noc unit test  A 1x1 NoC has the same start/terminal vertice. Also  the error when catching left/right vertices was fixed. Commit:Fix TaskNumber:#48
fix_before_refactoring: currentY = maxY
fix_after_refactoring: currentY = lqaogcpijbvsszccxesd
√ fix_prediction_before: currentY = maxY
√ fix_prediction_after: currentY = lqaogcpijbvsszccxesd

line_index: 156
bug_before_refactoring: { java.lang.System.out . println ( ( ( ( me . getSceneX () ) + ", " ) + ( ( me . getSceneY () ) - 55 ) ) ) ; int x = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int y = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( x , y , image ) ; } } <s> public void handle ( javafx.scene.input.MouseEvent me ) { java.lang.System.out . println ( ( ( ( me . getSceneX () ) + ", " ) + ( ( me . getSceneY () ) - 55 ) ) ) ; int x = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int y = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( x , y , image ) ; } } <s> Fixed board not refreshing when no more moves left in Time trial and click bug further < bug
bug_after_refactoring: { java.lang.System.out . println ( ( ( ( me . getSceneX () ) + ", " ) + ( ( me . getSceneY () ) - 55 ) ) ) ; int vqfadzupjesfrbrapvzk = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int qzogguxohovmhrdomjbw = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( vqfadzupjesfrbrapvzk , qzogguxohovmhrdomjbw , image ) ; } } <s> public void handle ( javafx.scene.input.MouseEvent me ) { java.lang.System.out . println ( ( ( ( me . getSceneX () ) + ", " ) + ( ( me . getSceneY () ) - 55 ) ) ) ; int vqfadzupjesfrbrapvzk = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int qzogguxohovmhrdomjbw = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( vqfadzupjesfrbrapvzk , qzogguxohovmhrdomjbw , image ) ; } } <s> Fixed board not refreshing when no more moves left in Time trial and click bug further < bug
fix_before_refactoring: { int x = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int y = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( x , y , image ) ; } }
fix_after_refactoring: { int vqfadzupjesfrbrapvzk = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int qzogguxohovmhrdomjbw = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( vqfadzupjesfrbrapvzk , qzogguxohovmhrdomjbw , image ) ; } }
√ fix_prediction_before: { int x = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int y = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( x , y , image ) ; } }
√ fix_prediction_after: { int vqfadzupjesfrbrapvzk = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int qzogguxohovmhrdomjbw = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( vqfadzupjesfrbrapvzk , qzogguxohovmhrdomjbw , image ) ; } }

line_index: 180
bug_before_refactoring: short ct = 1 ; <s> public static void addTable ( br.com.mvbos.mymer.el.TableElement te , java.lang.StringBuilder sb ) { br.com.mvbos.mymer.sync.Differ.entityToScript . setMode ( IEntityToScript.Mode.PLAIN ) ; br.com.mvbos.mymer.sync.Differ.entityToScript . addTable ( te , sb ) ; short ct = 1 ; for ( br.com.mvbos.mymer.xml.field.Field f : te . getFields () ) { br.com.mvbos.mymer.sync.Differ.entityToScript . addField ( te , f , ( ct ++ ) , sb ) ; } } <s> Revert "Bug fix"  This reverts commit 8b136ce6229b5f592e1b385898e5f57571389ec7.
bug_after_refactoring: short asyhrdxrctantntcugkc = 1 ; <s> public static void addTable ( br.com.mvbos.mymer.el.TableElement te , java.lang.StringBuilder sb ) { br.com.mvbos.mymer.sync.Differ.entityToScript . setMode ( IEntityToScript.Mode.PLAIN ) ; br.com.mvbos.mymer.sync.Differ.entityToScript . addTable ( te , sb ) ; short asyhrdxrctantntcugkc = 1 ; for ( br.com.mvbos.mymer.xml.field.Field f : te . getFields () ) { br.com.mvbos.mymer.sync.Differ.entityToScript . addField ( te , f , ( ct ++ ) , sb ) ; } } <s> Revert "Bug fix"  This reverts commit 8b136ce6229b5f592e1b385898e5f57571389ec7.
fix_before_refactoring: int ct = 1 ;
fix_after_refactoring: int asyhrdxrctantntcugkc = 1 ;
√ fix_prediction_before: int ct = 1 ;
√ fix_prediction_after: int asyhrdxrctantntcugkc = 1 ;

line_index: 186
bug_before_refactoring: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( minutes - ( oter . getTime () ) ) ) ; android.util.Log . e ( "Wakeup" , ( ( minutes - ( oter . getTime () ) ) + "" ) ) ; } <s> @ java.lang.Override public void processResults ( org.json.JSONObject result ) { int minutes = getTime ( result ) ; if ( minutes <= ( oter . getTime () ) ) { com.joebruzek.oter.utilities.SmsSender . sendText ( oter ) ; oterLayer . removeOter ( oter ) ; } else { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( minutes - ( oter . getTime () ) ) ) ; android.util.Log . e ( "Wakeup" , ( ( minutes - ( oter . getTime () ) ) + "" ) ) ; } this . stopSelf () ; } <s> Fixed bug with SendOterService wakeup
bug_after_refactoring: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) ) ; android.util.Log . e ( "Wakeup" , ( ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) + "" ) ) ; } <s> @ java.lang.Override public void processResults ( org.json.JSONObject result ) { int minutes = getTime ( result ) ; if ( minutes <= ( oter . getTime () ) ) { com.joebruzek.oter.utilities.SmsSender . sendText ( oter ) ; oterLayer . removeOter ( oter ) ; } else { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) ) ; android.util.Log . e ( "Wakeup" , ( ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) + "" ) ) ; } this . stopSelf () ; } <s> Fixed bug with SendOterService wakeup
fix_before_refactoring: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( minutes - ( oter . getTime () ) ) ) ; }
fix_after_refactoring: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) ) ; }
√ fix_prediction_before: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( minutes - ( oter . getTime () ) ) ) ; }
√ fix_prediction_after: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) ) ; }

line_index: 187
bug_before_refactoring: { status = true ; handleCompletion ( view , url ) ; } <s> @ java.lang.Override public boolean shouldOverrideUrlLoading ( android.webkit.WebView view , java.lang.String url ) { android.util.Log . d ( com.gsma.mobileconnect.helpers.AuthorizationService.TAG , ( "shouldOverrideUrlLoading url=" + url ) ) ; boolean status = false ; if ( ( url != null ) && ( url . startsWith ( redirectUri ) ) ) { status = true ; handleCompletion ( view , url ) ; } else { view . loadUrl ( url ) ; } return status ; } <s> Further experiments to resolve Android M webview issue
bug_after_refactoring: { mwqbfeimsodjkmgdktvs = true ; handleCompletion ( view , url ) ; } <s> @ java.lang.Override public boolean shouldOverrideUrlLoading ( android.webkit.WebView view , java.lang.String url ) { android.util.Log . d ( com.gsma.mobileconnect.helpers.AuthorizationService.TAG , ( "shouldOverrideUrlLoading url=" + url ) ) ; boolean status = false ; if ( ( url != null ) && ( url . startsWith ( redirectUri ) ) ) { mwqbfeimsodjkmgdktvs = true ; handleCompletion ( view , url ) ; } else { view . loadUrl ( url ) ; } return status ; } <s> Further experiments to resolve Android M webview issue
fix_before_refactoring: { handleCompletion ( view , url ) ; }
fix_after_refactoring: { handleCompletion ( view , url ) ; }
√ fix_prediction_before: { handleCompletion ( view , url ) ; }
√ fix_prediction_after: { handleCompletion ( view , url ) ; }

line_index: 206
bug_before_refactoring: expResult = false <s> @ org.junit.Test public void testAtLeastOneNegative4 () { java.lang.System.out . println ( "atLeastOneNegative" ) ; int n1 = 0 ; int n2 = 0 ; int n3 = 0 ; int n4 = - 7 ; boolean expResult = false ; boolean result = second.FirstTasksSet . atLeastOneNegative ( n1 , n2 , n3 , n4 ) ; org.junit.Assert . assertEquals ( expResult , result ) ; } <s> BugFix Test
bug_after_refactoring: gysqfoizxgvfmacgmjgl = false <s> @ org.junit.Test public void testAtLeastOneNegative4 () { java.lang.System.out . println ( "atLeastOneNegative" ) ; int n1 = 0 ; int n2 = 0 ; int n3 = 0 ; int n4 = - 7 ; boolean gysqfoizxgvfmacgmjgl = false ; boolean result = second.FirstTasksSet . atLeastOneNegative ( n1 , n2 , n3 , n4 ) ; org.junit.Assert . assertEquals ( expResult , result ) ; } <s> BugFix Test
fix_before_refactoring: expResult = true
fix_after_refactoring: gysqfoizxgvfmacgmjgl = true
√ fix_prediction_before: expResult = true
√ fix_prediction_after: gysqfoizxgvfmacgmjgl = true

line_index: 207
bug_before_refactoring: minWayId = wayId + 1 <s> public void process ( org.openstreetmap.osmosis.core.container.v0_6.WayContainer wayContainer ) { org.openstreetmap.osmosis.core.domain.v0_6.Way way ; long wayId ; flushNodes ( true ) ; way = wayContainer . getEntity () ; wayId = way . getId () ; if ( wayId >= ( maxWayId ) ) { maxWayId = wayId + 1 ; } if ( wayId < ( minWayId ) ) { minWayId = wayId + 1 ; } wayBuffer . add ( way ) ; flushWays ( false ) ; } <s> apidb: Fix one-off error in current way/relation loading  The previous patch had a minor bug where the minimum way and relation ids being loaded into the current tables were one-off and therefore missing the first id to be loaded.
bug_after_refactoring: minWayId = vnvcnjaylfchzeclfwkq + 1 <s> public void process ( org.openstreetmap.osmosis.core.container.v0_6.WayContainer wayContainer ) { org.openstreetmap.osmosis.core.domain.v0_6.Way way ; long wayId ; flushNodes ( true ) ; way = wayContainer . getEntity () ; wayId = way . getId () ; if ( wayId >= ( maxWayId ) ) { maxWayId = wayId + 1 ; } if ( wayId < ( minWayId ) ) { minWayId = vnvcnjaylfchzeclfwkq + 1 ; } wayBuffer . add ( way ) ; flushWays ( false ) ; } <s> apidb: Fix one-off error in current way/relation loading  The previous patch had a minor bug where the minimum way and relation ids being loaded into the current tables were one-off and therefore missing the first id to be loaded.
fix_before_refactoring: minWayId = wayId
fix_after_refactoring: minWayId = vnvcnjaylfchzeclfwkq
√ fix_prediction_before: minWayId = wayId
√ fix_prediction_after: minWayId = vnvcnjaylfchzeclfwkq

line_index: 222
bug_before_refactoring: { java.lang.System.out . println ( "I'm in it" ) ; getQueryMap . setFirstTimestamp ( timeStamp ) ; java.lang.System.out . println ( ( ( ChannelCode + '\t' ) + timeStamp ) ) ; isFirst = false ; } <s> @ java.lang.Override public void execute ( backtype.storm.tuple.Tuple tuple ) { java.lang.String ChannelCode = tuple . getStringByField ( "channelCode" ) ; long timeStamp = tuple . getLongByField ( "timeStamp" ) ; float value = tuple . getFloatByField ( "value" ) ; if ( channelSet . contains ( ChannelCode ) ) { if ( isFirst ) { java.lang.System.out . println ( "I'm in it" ) ; getQueryMap . setFirstTimestamp ( timeStamp ) ; java.lang.System.out . println ( ( ( ChannelCode + '\t' ) + timeStamp ) ) ; isFirst = false ; } _collector . emit ( new backtype.storm.tuple.Values ( ChannelCode , timeStamp , value ) ) ; } } <s> fix some bugs  pass build  remaining logic errors in SliceManager
bug_after_refactoring: { java.lang.System.out . println ( "I'm in it" ) ; getQueryMap . setFirstTimestamp ( ggpvpsmgwxwulsxsillt ) ; java.lang.System.out . println ( ( ( ChannelCode + '\t' ) + ggpvpsmgwxwulsxsillt ) ) ; isFirst = false ; } <s> @ java.lang.Override public void execute ( backtype.storm.tuple.Tuple tuple ) { java.lang.String ChannelCode = tuple . getStringByField ( "channelCode" ) ; long timeStamp = tuple . getLongByField ( "timeStamp" ) ; float value = tuple . getFloatByField ( "value" ) ; if ( channelSet . contains ( ChannelCode ) ) { if ( isFirst ) { java.lang.System.out . println ( "I'm in it" ) ; getQueryMap . setFirstTimestamp ( ggpvpsmgwxwulsxsillt ) ; java.lang.System.out . println ( ( ( ChannelCode + '\t' ) + ggpvpsmgwxwulsxsillt ) ) ; isFirst = false ; } _collector . emit ( new backtype.storm.tuple.Values ( ChannelCode , timeStamp , value ) ) ; } } <s> fix some bugs  pass build  remaining logic errors in SliceManager
fix_before_refactoring: { getQueryMap . setFirstTimestamp ( timeStamp ) ; isFirst = false ; }
fix_after_refactoring: { getQueryMap . setFirstTimestamp ( ggpvpsmgwxwulsxsillt ) ; isFirst = false ; }
√ fix_prediction_before: { getQueryMap . setFirstTimestamp ( timeStamp ) ; isFirst = false ; }
√ fix_prediction_after: { getQueryMap . setFirstTimestamp ( ggpvpsmgwxwulsxsillt ) ; isFirst = false ; }

line_index: 228
bug_before_refactoring: count = 1 <s> protected int nearMinesCount ( int line , int place ) { int count = 1 ; for ( int [] near : net.patttern.minesweeper.proto.bases.BaseArea.nears ) { count += ( cellMined ( ( line + ( near [ 0 ] ) ) , ( place + ( near [ 1 ] ) ) ) ) ? 1 : 0 ; } return count ; } <s> Bugfix
bug_after_refactoring: fofznveiednztfjbbgwu = 1 <s> protected int nearMinesCount ( int line , int place ) { int fofznveiednztfjbbgwu = 1 ; for ( int [] near : net.patttern.minesweeper.proto.bases.BaseArea.nears ) { count += ( cellMined ( ( line + ( near [ 0 ] ) ) , ( place + ( near [ 1 ] ) ) ) ) ? 1 : 0 ; } return count ; } <s> Bugfix
fix_before_refactoring: count = 0
fix_after_refactoring: fofznveiednztfjbbgwu = 0
√ fix_prediction_before: count = 0
√ fix_prediction_after: fofznveiednztfjbbgwu = 0

line_index: 244
bug_before_refactoring: if ( random_instance > ( used.length ) ) random_instance = 0 ; <s> private int findRandomInstance () { int random_instance = ( ( int ) ( ( java.lang.Math . random () ) * ( used.length ) ) ) ; while ( used [ random_instance ] ) { random_instance ++ ; if ( random_instance > ( used.length ) ) random_instance = 0 ; } used [ random_instance ] = true ; return random_instance ; } <s> documentation and bug-fix
bug_after_refactoring: if ( gearxqlwaasuvzmyfmfc > ( used.length ) ) gearxqlwaasuvzmyfmfc = 0 ; <s> private int findRandomInstance () { int random_instance = ( ( int ) ( ( java.lang.Math . random () ) * ( used.length ) ) ) ; while ( used [ random_instance ] ) { random_instance ++ ; if ( gearxqlwaasuvzmyfmfc > ( used.length ) ) gearxqlwaasuvzmyfmfc = 0 ; } used [ random_instance ] = true ; return random_instance ; } <s> documentation and bug-fix
fix_before_refactoring: if ( random_instance >= ( used.length ) ) random_instance = 0 ;
fix_after_refactoring: if ( gearxqlwaasuvzmyfmfc >= ( used.length ) ) gearxqlwaasuvzmyfmfc = 0 ;
√ fix_prediction_before: if ( random_instance >= ( used.length ) ) random_instance = 0 ;
√ fix_prediction_after: if ( gearxqlwaasuvzmyfmfc >= ( used.length ) ) gearxqlwaasuvzmyfmfc = 0 ;

line_index: 246
bug_before_refactoring: private java.lang.String receive () { byte [] data = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( data , data.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; } <s> private java.lang.String receive () { byte [] data = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( data , data.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; } <s> - implement listen thread - need to solve the problem of data length
bug_after_refactoring: private java.lang.String receive () { byte [] sucbzfeuioadgafbwtrp = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( sucbzfeuioadgafbwtrp , sucbzfeuioadgafbwtrp.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; } <s> private java.lang.String receive () { byte [] sucbzfeuioadgafbwtrp = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( sucbzfeuioadgafbwtrp , sucbzfeuioadgafbwtrp.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; } <s> - implement listen thread - need to solve the problem of data length
fix_before_refactoring: public java.lang.String receive () { byte [] data = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( data , data.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; }
fix_after_refactoring: public java.lang.String receive () { byte [] sucbzfeuioadgafbwtrp = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( sucbzfeuioadgafbwtrp , sucbzfeuioadgafbwtrp.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; }
√ fix_prediction_before: public java.lang.String receive () { byte [] data = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( data , data.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; }
√ fix_prediction_after: public java.lang.String receive () { byte [] sucbzfeuioadgafbwtrp = new byte [ 1024 ] ; java.net.DatagramPacket packet = new java.net.DatagramPacket ( sucbzfeuioadgafbwtrp , sucbzfeuioadgafbwtrp.length ) ; try { socket . receive ( packet ) ; } catch ( java.io.IOException e ) { e . printStackTrace () ; } java.lang.String message = new java.lang.String ( packet . getData () ) ; return message ; }

line_index: 291
bug_before_refactoring: private static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int score = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { score += pairTimes . get ( i ) . getPair () . getScore () ; } return score ; } <s> private static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int score = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { score += pairTimes . get ( i ) . getPair () . getScore () ; } return score ; } <s> Added Hungarian unit tests and fixed a minor line matrix bug
bug_after_refactoring: private static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int qiyemvxxwlukvencrhaw = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { qiyemvxxwlukvencrhaw += pairTimes . get ( i ) . getPair () . getScore () ; } return qiyemvxxwlukvencrhaw ; } <s> private static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int qiyemvxxwlukvencrhaw = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { qiyemvxxwlukvencrhaw += pairTimes . get ( i ) . getPair () . getScore () ; } return qiyemvxxwlukvencrhaw ; } <s> Added Hungarian unit tests and fixed a minor line matrix bug
fix_before_refactoring: public static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int score = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { score += pairTimes . get ( i ) . getPair () . getScore () ; } return score ; }
fix_after_refactoring: public static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int qiyemvxxwlukvencrhaw = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { qiyemvxxwlukvencrhaw += pairTimes . get ( i ) . getPair () . getScore () ; } return qiyemvxxwlukvencrhaw ; }
√ fix_prediction_before: public static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int score = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { score += pairTimes . get ( i ) . getPair () . getScore () ; } return score ; }
√ fix_prediction_after: public static int calculateScore ( java.util.ArrayList < PairTime > pairTimes ) { int qiyemvxxwlukvencrhaw = 0 ; for ( int i = 0 ; i < ( pairTimes . size () ) ; i ++ ) { qiyemvxxwlukvencrhaw += pairTimes . get ( i ) . getPair () . getScore () ; } return qiyemvxxwlukvencrhaw ; }

line_index: 319
bug_before_refactoring: { final java.util.Calendar c = java.util.Calendar . getInstance () ; int hour = c . get ( java.util.Calendar.HOUR_OF_DAY ) ; int minute = c . get ( java.util.Calendar.MINUTE ) ; hourOfDay = "" ; return new android.app.TimePickerDialog ( getActivity () , this , hour , minute , android.text.format.DateFormat . is24HourFormat ( getActivity () ) ) ; } <s> @ java.lang.Override public android.app.Dialog onCreateDialog ( android.os.Bundle savedInstanceState ) { final java.util.Calendar c = java.util.Calendar . getInstance () ; int hour = c . get ( java.util.Calendar.HOUR_OF_DAY ) ; int minute = c . get ( java.util.Calendar.MINUTE ) ; hourOfDay = "" ; return new android.app.TimePickerDialog ( getActivity () , this , hour , minute , android.text.format.DateFormat . is24HourFormat ( getActivity () ) ) ; } <s> fixing calendar bugs
bug_after_refactoring: { final java.util.Calendar c = java.util.Calendar . getInstance () ; int umqnblhryqddkuaqnnfv = c . get ( java.util.Calendar.HOUR_OF_DAY ) ; int kkwdbxougybzdxnouzgo = c . get ( java.util.Calendar.MINUTE ) ; hourOfDay = "" ; return new android.app.TimePickerDialog ( getActivity () , this , umqnblhryqddkuaqnnfv , kkwdbxougybzdxnouzgo , android.text.format.DateFormat . is24HourFormat ( getActivity () ) ) ; } <s> @ java.lang.Override public android.app.Dialog onCreateDialog ( android.os.Bundle savedInstanceState ) { final java.util.Calendar c = java.util.Calendar . getInstance () ; int umqnblhryqddkuaqnnfv = c . get ( java.util.Calendar.HOUR_OF_DAY ) ; int kkwdbxougybzdxnouzgo = c . get ( java.util.Calendar.MINUTE ) ; hourOfDay = "" ; return new android.app.TimePickerDialog ( getActivity () , this , umqnblhryqddkuaqnnfv , kkwdbxougybzdxnouzgo , android.text.format.DateFormat . is24HourFormat ( getActivity () ) ) ; } <s> fixing calendar bugs
fix_before_refactoring: { final java.util.Calendar c = java.util.Calendar . getInstance () ; int hour = c . get ( java.util.Calendar.HOUR_OF_DAY ) ; int minute = c . get ( java.util.Calendar.MINUTE ) ; return new android.app.TimePickerDialog ( getActivity () , this , hour , minute , android.text.format.DateFormat . is24HourFormat ( getActivity () ) ) ; }
fix_after_refactoring: { final java.util.Calendar c = java.util.Calendar . getInstance () ; int umqnblhryqddkuaqnnfv = c . get ( java.util.Calendar.HOUR_OF_DAY ) ; int kkwdbxougybzdxnouzgo = c . get ( java.util.Calendar.MINUTE ) ; return new android.app.TimePickerDialog ( getActivity () , this , umqnblhryqddkuaqnnfv , kkwdbxougybzdxnouzgo , android.text.format.DateFormat . is24HourFormat ( getActivity () ) ) ; }
√ fix_prediction_before: { final java.util.Calendar c = java.util.Calendar . getInstance () ; int hour = c . get ( java.util.Calendar.HOUR_OF_DAY ) ; int minute = c . get ( java.util.Calendar.MINUTE ) ; return new android.app.TimePickerDialog ( getActivity () , this , hour , minute , android.text.format.DateFormat . is24HourFormat ( getActivity () ) ) ; }
√ fix_prediction_after: { final java.util.Calendar c = java.util.Calendar . getInstance () ; int umqnblhryqddkuaqnnfv = c . get ( java.util.Calendar.HOUR_OF_DAY ) ; int kkwdbxougybzdxnouzgo = c . get ( java.util.Calendar.MINUTE ) ; return new android.app.TimePickerDialog ( getActivity () , this , umqnblhryqddkuaqnnfv , kkwdbxougybzdxnouzgo , android.text.format.DateFormat . is24HourFormat ( getActivity () ) ) ; }

line_index: 328
bug_before_refactoring: if ( value > ( end ) ) { long diffInBuckets = ( value - ( end ) ) / ( bucketSpanMillis ) ; long move = ( diffInBuckets + 1 ) * ( bucketSpanMillis ) ; start += move ; end += move ; triggerPurge = true ; lowestPurgeableTimeBucket += diffInBuckets ; } <s> public long getTimeBucketAndAdjustBoundaries ( long value ) { if ( value < ( start ) ) { return - 1 ; } long diffFromStart = value - ( fixedStart ) ; long key = diffFromStart / ( bucketSpanMillis ) ; if ( value > ( end ) ) { long diffInBuckets = ( value - ( end ) ) / ( bucketSpanMillis ) ; long move = ( diffInBuckets + 1 ) * ( bucketSpanMillis ) ; start += move ; end += move ; triggerPurge = true ; lowestPurgeableTimeBucket += diffInBuckets ; } return key ; } <s> APEXMALHAR-2299 TimeBasedDedupOperator. Fixing edge case bug in time bucket assignment
bug_after_refactoring: if ( value > ( end ) ) { long dvvtoubmibvlrqbxbjdy = ( value - ( end ) ) / ( bucketSpanMillis ) ; long ipkzscnpgfkwzdtnjbgs = ( dvvtoubmibvlrqbxbjdy + 1 ) * ( bucketSpanMillis ) ; start += ipkzscnpgfkwzdtnjbgs ; end += ipkzscnpgfkwzdtnjbgs ; triggerPurge = true ; lowestPurgeableTimeBucket += dvvtoubmibvlrqbxbjdy ; } <s> public long getTimeBucketAndAdjustBoundaries ( long value ) { if ( value < ( start ) ) { return - 1 ; } long diffFromStart = value - ( fixedStart ) ; long key = diffFromStart / ( bucketSpanMillis ) ; if ( value > ( end ) ) { long dvvtoubmibvlrqbxbjdy = ( value - ( end ) ) / ( bucketSpanMillis ) ; long ipkzscnpgfkwzdtnjbgs = ( dvvtoubmibvlrqbxbjdy + 1 ) * ( bucketSpanMillis ) ; start += ipkzscnpgfkwzdtnjbgs ; end += ipkzscnpgfkwzdtnjbgs ; triggerPurge = true ; lowestPurgeableTimeBucket += dvvtoubmibvlrqbxbjdy ; } return key ; } <s> APEXMALHAR-2299 TimeBasedDedupOperator. Fixing edge case bug in time bucket assignment
fix_before_refactoring: if ( value >= ( end ) ) { long diffInBuckets = ( value - ( end ) ) / ( bucketSpanMillis ) ; long move = ( diffInBuckets + 1 ) * ( bucketSpanMillis ) ; start += move ; end += move ; triggerPurge = true ; lowestPurgeableTimeBucket += diffInBuckets ; }
fix_after_refactoring: if ( value >= ( end ) ) { long dvvtoubmibvlrqbxbjdy = ( value - ( end ) ) / ( bucketSpanMillis ) ; long ipkzscnpgfkwzdtnjbgs = ( dvvtoubmibvlrqbxbjdy + 1 ) * ( bucketSpanMillis ) ; start += ipkzscnpgfkwzdtnjbgs ; end += ipkzscnpgfkwzdtnjbgs ; triggerPurge = true ; lowestPurgeableTimeBucket += dvvtoubmibvlrqbxbjdy ; }
√ fix_prediction_before: if ( value >= ( end ) ) { long diffInBuckets = ( value - ( end ) ) / ( bucketSpanMillis ) ; long move = ( diffInBuckets + 1 ) * ( bucketSpanMillis ) ; start += move ; end += move ; triggerPurge = true ; lowestPurgeableTimeBucket += diffInBuckets ; }
√ fix_prediction_after: if ( value >= ( end ) ) { long dvvtoubmibvlrqbxbjdy = ( value - ( end ) ) / ( bucketSpanMillis ) ; long ipkzscnpgfkwzdtnjbgs = ( dvvtoubmibvlrqbxbjdy + 1 ) * ( bucketSpanMillis ) ; start += ipkzscnpgfkwzdtnjbgs ; end += ipkzscnpgfkwzdtnjbgs ; triggerPurge = true ; lowestPurgeableTimeBucket += dvvtoubmibvlrqbxbjdy ; }

line_index: 343
bug_before_refactoring: { int largestImageDimension = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int bestImageResolution = java.lang.Math . min ( largestImageDimension , resolution ) ; android.util.Log . d ( gov.nasa.jpl.hi.marsimages.models.ImageQuad.TAG , ( "Texture res: " + ( gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ) ) ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ; } <s> private int computeBestTextureResolution ( int resolution ) { int largestImageDimension = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int bestImageResolution = java.lang.Math . min ( largestImageDimension , resolution ) ; android.util.Log . d ( gov.nasa.jpl.hi.marsimages.models.ImageQuad.TAG , ( "Texture res: " + ( gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ) ) ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ; } <s> Fixed bug with loading locations earlier than the latest site in the mosaic view
bug_after_refactoring: { int ykhjbbqyosxepobtiqpd = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int xweuymeaebjwcdsfmwsk = java.lang.Math . min ( ykhjbbqyosxepobtiqpd , resolution ) ; android.util.Log . d ( gov.nasa.jpl.hi.marsimages.models.ImageQuad.TAG , ( "Texture res: " + ( gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ) ) ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ; } <s> private int computeBestTextureResolution ( int resolution ) { int ykhjbbqyosxepobtiqpd = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int xweuymeaebjwcdsfmwsk = java.lang.Math . min ( ykhjbbqyosxepobtiqpd , resolution ) ; android.util.Log . d ( gov.nasa.jpl.hi.marsimages.models.ImageQuad.TAG , ( "Texture res: " + ( gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ) ) ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ; } <s> Fixed bug with loading locations earlier than the latest site in the mosaic view
fix_before_refactoring: { int largestImageDimension = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int bestImageResolution = java.lang.Math . min ( largestImageDimension , resolution ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ; }
fix_after_refactoring: { int ykhjbbqyosxepobtiqpd = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int xweuymeaebjwcdsfmwsk = java.lang.Math . min ( ykhjbbqyosxepobtiqpd , resolution ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ; }
√ fix_prediction_before: { int largestImageDimension = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int bestImageResolution = java.lang.Math . min ( largestImageDimension , resolution ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ; }
√ fix_prediction_after: { int ykhjbbqyosxepobtiqpd = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int xweuymeaebjwcdsfmwsk = java.lang.Math . min ( ykhjbbqyosxepobtiqpd , resolution ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ; }

line_index: 362
bug_before_refactoring: shouldReplicateToPassives = false <s> public static org.terracotta.passthrough.PassthroughMessage createUnexpectedReleaseMessage ( final java.lang.String entityClassName , final java.lang.String entityName , final long clientInstanceID ) { boolean shouldReplicateToPassives = false ; return new org.terracotta.passthrough.PassthroughMessage ( org.terracotta.passthrough.PassthroughMessage.Type.UNEXPECTED_RELEASE , shouldReplicateToPassives ) { @ java.lang.Override protected void populateStream ( java.io.DataOutputStream output ) throws java.io.IOException { output . writeUTF ( entityClassName ) ; output . writeUTF ( entityName ) ; output . writeLong ( clientInstanceID ) ; } } ; } <s> Merge pull request #127 from ramsai1729/issue-126  Fix #126: Fix oldest transaction id calculations
bug_after_refactoring: pfbepbwnnzftysqjmawo = false <s> public static org.terracotta.passthrough.PassthroughMessage createUnexpectedReleaseMessage ( final java.lang.String entityClassName , final java.lang.String entityName , final long clientInstanceID ) { boolean pfbepbwnnzftysqjmawo = false ; return new org.terracotta.passthrough.PassthroughMessage ( org.terracotta.passthrough.PassthroughMessage.Type.UNEXPECTED_RELEASE , shouldReplicateToPassives ) { @ java.lang.Override protected void populateStream ( java.io.DataOutputStream output ) throws java.io.IOException { output . writeUTF ( entityClassName ) ; output . writeUTF ( entityName ) ; output . writeLong ( clientInstanceID ) ; } } ; } <s> Merge pull request #127 from ramsai1729/issue-126  Fix #126: Fix oldest transaction id calculations
fix_before_refactoring: shouldReplicateToPassives = true
fix_after_refactoring: pfbepbwnnzftysqjmawo = true
√ fix_prediction_before: shouldReplicateToPassives = true
√ fix_prediction_after: pfbepbwnnzftysqjmawo = true

line_index: 378
bug_before_refactoring: { resources.noteblock.Song generate = Noteblock.iPodSongs . get ( resources.NumberUtils . randomNumber ( size ) ) ; if ( ! ( theweekend.cosmetics.ipod.Radio.queuedSongs . contains ( generate ) ) ) ; { theweekend.cosmetics.ipod.Radio.queuedSongs . add ( generate ) ; } } <s> public static void updateQueue () { while ( ( theweekend.cosmetics.ipod.Radio.queuedSongs . size () ) < 5 ) { int size = Noteblock.iPodSongs . size () ; if ( size > 0 ) { resources.noteblock.Song generate = Noteblock.iPodSongs . get ( resources.NumberUtils . randomNumber ( size ) ) ; if ( ! ( theweekend.cosmetics.ipod.Radio.queuedSongs . contains ( generate ) ) ) ; { theweekend.cosmetics.ipod.Radio.queuedSongs . add ( generate ) ; } } } theweekend.cosmetics.ipod.Radio.songPosition = 0 ; theweekend.cosmetics.ipod.Radio . playRadioSong () ; } <s> fixed errors
bug_after_refactoring: { resources.noteblock.Song generate = Noteblock.iPodSongs . get ( resources.NumberUtils . randomNumber ( nivlsoyndoavikjzinfn ) ) ; if ( ! ( theweekend.cosmetics.ipod.Radio.queuedSongs . contains ( generate ) ) ) ; { theweekend.cosmetics.ipod.Radio.queuedSongs . add ( generate ) ; } } <s> public static void updateQueue () { while ( ( theweekend.cosmetics.ipod.Radio.queuedSongs . size () ) < 5 ) { int size = Noteblock.iPodSongs . size () ; if ( size > 0 ) { resources.noteblock.Song generate = Noteblock.iPodSongs . get ( resources.NumberUtils . randomNumber ( nivlsoyndoavikjzinfn ) ) ; if ( ! ( theweekend.cosmetics.ipod.Radio.queuedSongs . contains ( generate ) ) ) ; { theweekend.cosmetics.ipod.Radio.queuedSongs . add ( generate ) ; } } } theweekend.cosmetics.ipod.Radio.songPosition = 0 ; theweekend.cosmetics.ipod.Radio . playRadioSong () ; } <s> fixed errors
fix_before_refactoring: { resources.noteblock.Song generate = Noteblock.iPodSongs . get ( resources.NumberUtils . randomNumber ( size ) ) ; if ( ! ( theweekend.cosmetics.ipod.Radio.queuedSongs . contains ( generate ) ) ) { theweekend.cosmetics.ipod.Radio.queuedSongs . add ( generate ) ; } }
fix_after_refactoring: { resources.noteblock.Song generate = Noteblock.iPodSongs . get ( resources.NumberUtils . randomNumber ( nivlsoyndoavikjzinfn ) ) ; if ( ! ( theweekend.cosmetics.ipod.Radio.queuedSongs . contains ( generate ) ) ) { theweekend.cosmetics.ipod.Radio.queuedSongs . add ( generate ) ; } }
√ fix_prediction_before: { resources.noteblock.Song generate = Noteblock.iPodSongs . get ( resources.NumberUtils . randomNumber ( size ) ) ; if ( ! ( theweekend.cosmetics.ipod.Radio.queuedSongs . contains ( generate ) ) ) { theweekend.cosmetics.ipod.Radio.queuedSongs . add ( generate ) ; } }
√ fix_prediction_after: { resources.noteblock.Song generate = Noteblock.iPodSongs . get ( resources.NumberUtils . randomNumber ( nivlsoyndoavikjzinfn ) ) ; if ( ! ( theweekend.cosmetics.ipod.Radio.queuedSongs . contains ( generate ) ) ) { theweekend.cosmetics.ipod.Radio.queuedSongs . add ( generate ) ; } }

line_index: 379
bug_before_refactoring: { grid [ n ] [ j ] . setNumber ( i ) ; } <s> public void checkNeededInColumn () { int n ; for ( int j = 0 ; j < 9 ; j ++ ) { for ( int i = 1 ; i < 10 ; i ++ ) { if ( de.halemba.helpers.SolveHelper . checkMissingInColumn ( i , j , grid ) ) { n = de.halemba.helpers.SolveHelper . checkSinglePossiblityColumn ( i , j , grid ) ; if ( n >= 0 ) { grid [ n ] [ j ] . setNumber ( i ) ; } } } } } <s> Bugfix
bug_after_refactoring: { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; } <s> public void checkNeededInColumn () { int n ; for ( int j = 0 ; j < 9 ; j ++ ) { for ( int i = 1 ; i < 10 ; i ++ ) { if ( de.halemba.helpers.SolveHelper . checkMissingInColumn ( i , j , grid ) ) { n = de.halemba.helpers.SolveHelper . checkSinglePossiblityColumn ( i , j , grid ) ; if ( n >= 0 ) { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; } } } } } <s> Bugfix
fix_before_refactoring: { grid [ n ] [ j ] . setNumber ( i ) ; break; }
fix_after_refactoring: { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; break; }
√ fix_prediction_before: { grid [ n ] [ j ] . setNumber ( i ) ; break; }
√ fix_prediction_after: { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; break; }

line_index: 387
bug_before_refactoring: slash.navigation.gui.events.Range . increment ( selectedRows , ( - 1 ) ) <s> public void run () { int [] selectedRows = tablePositions . getSelectedRows () ; if ( ( selectedRows.length ) > 0 ) { getPositionsModel () . up ( selectedRows , 1 ) ; selectPositions ( slash.navigation.gui.events.Range . increment ( selectedRows , ( - 1 ) ) ) ; } } <s> fixes disabled functions until selection problem  might cause performance problems http://forum.routeconverter.com/thread-1987.html
bug_after_refactoring: slash.navigation.gui.events.Range . increment ( riclvjieshlqqxnypyhp , ( - 1 ) ) <s> public void run () { int [] selectedRows = tablePositions . getSelectedRows () ; if ( ( selectedRows.length ) > 0 ) { getPositionsModel () . up ( selectedRows , 1 ) ; selectPositions ( slash.navigation.gui.events.Range . increment ( riclvjieshlqqxnypyhp , ( - 1 ) ) ) ; } } <s> fixes disabled functions until selection problem  might cause performance problems http://forum.routeconverter.com/thread-1987.html
fix_before_refactoring: increment ( selectedRows , ( - 1 ) )
fix_after_refactoring: increment ( riclvjieshlqqxnypyhp , ( - 1 ) )
√ fix_prediction_before: increment ( selectedRows , ( - 1 ) )
√ fix_prediction_after: increment ( riclvjieshlqqxnypyhp , ( - 1 ) )

line_index: 389
bug_before_refactoring: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int today = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; java.lang.System.out . println ( daysBitString ) ; if ( frequencyDays . substring ( today , ( today + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } } <s> public void setFrequencyDays ( java.lang.String daysBitString ) { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int today = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; java.lang.System.out . println ( daysBitString ) ; if ( frequencyDays . substring ( today , ( today + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } } <s> Fix reminder times bug
bug_after_refactoring: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int ydcofxtbgbmbaqovsmdw = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; java.lang.System.out . println ( daysBitString ) ; if ( frequencyDays . substring ( ydcofxtbgbmbaqovsmdw , ( ydcofxtbgbmbaqovsmdw + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } } <s> public void setFrequencyDays ( java.lang.String daysBitString ) { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int ydcofxtbgbmbaqovsmdw = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; java.lang.System.out . println ( daysBitString ) ; if ( frequencyDays . substring ( ydcofxtbgbmbaqovsmdw , ( ydcofxtbgbmbaqovsmdw + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } } <s> Fix reminder times bug
fix_before_refactoring: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int today = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; if ( frequencyDays . substring ( today , ( today + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } }
fix_after_refactoring: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int ydcofxtbgbmbaqovsmdw = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; if ( frequencyDays . substring ( ydcofxtbgbmbaqovsmdw , ( ydcofxtbgbmbaqovsmdw + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } }
√ fix_prediction_before: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int today = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; if ( frequencyDays . substring ( today , ( today + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } }
√ fix_prediction_after: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int ydcofxtbgbmbaqovsmdw = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; if ( frequencyDays . substring ( ydcofxtbgbmbaqovsmdw , ( ydcofxtbgbmbaqovsmdw + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } }

line_index: 406
bug_before_refactoring: { int strokeColor = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( strokeColor ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; android.widget.Toast . makeText ( this , ( "Circle: " + ( circle . getTag () . toString () ) ) , Toast.LENGTH_SHORT ) . show () ; } <s> private void ToggleCircleColor ( com.google.android.gms.maps.model.Circle circle ) { int strokeColor = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( strokeColor ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; android.widget.Toast . makeText ( this , ( "Circle: " + ( circle . getTag () . toString () ) ) , Toast.LENGTH_SHORT ) . show () ; } <s> Fix some bugs  on present round-1-day
bug_after_refactoring: { int kkavbzbyyrvuryqozteg = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( kkavbzbyyrvuryqozteg ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; android.widget.Toast . makeText ( this , ( "Circle: " + ( circle . getTag () . toString () ) ) , Toast.LENGTH_SHORT ) . show () ; } <s> private void ToggleCircleColor ( com.google.android.gms.maps.model.Circle circle ) { int kkavbzbyyrvuryqozteg = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( kkavbzbyyrvuryqozteg ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; android.widget.Toast . makeText ( this , ( "Circle: " + ( circle . getTag () . toString () ) ) , Toast.LENGTH_SHORT ) . show () ; } <s> Fix some bugs  on present round-1-day
fix_before_refactoring: { int strokeColor = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( strokeColor ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; }
fix_after_refactoring: { int kkavbzbyyrvuryqozteg = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( kkavbzbyyrvuryqozteg ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; }
√ fix_prediction_before: { int strokeColor = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( strokeColor ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; }
√ fix_prediction_after: { int kkavbzbyyrvuryqozteg = ( circle . getStrokeColor () ) ^ 52224 ; circle . setStrokeColor ( kkavbzbyyrvuryqozteg ) ; circle . setStrokeWidth ( ( ( circle . getStrokeWidth () ) == 3 ? 6 : 3 ) ) ; }

line_index: 408
bug_before_refactoring: { digilib.image.ImageJobDescription.logger . debug ( "get_scaleQual()" ) ; int qual = dlConfig . getAsInt ( "default-quality" ) ; if ( hasOption ( "q0" ) ) qual = 0 ; else if ( hasOption ( "q1" ) ) qual = 1 ; else if ( hasOption ( "q2" ) ) qual = 2 ; return qual ; } <s> public int getScaleQual () { digilib.image.ImageJobDescription.logger . debug ( "get_scaleQual()" ) ; int qual = dlConfig . getAsInt ( "default-quality" ) ; if ( hasOption ( "q0" ) ) qual = 0 ; else if ( hasOption ( "q1" ) ) qual = 1 ; else if ( hasOption ( "q2" ) ) qual = 2 ; return qual ; } <s> fixed black-last-pixel bug by rounding up scale factor in ImageLoaderDocuImage.scale(). added comments and formatting.  --HG-- branch : new_scaling
bug_after_refactoring: { digilib.image.ImageJobDescription.logger . debug ( "get_scaleQual()" ) ; int gvzibkulivqryamzdxzm = dlConfig . getAsInt ( "default-quality" ) ; if ( hasOption ( "q0" ) ) gvzibkulivqryamzdxzm = 0 ; else if ( hasOption ( "q1" ) ) gvzibkulivqryamzdxzm = 1 ; else if ( hasOption ( "q2" ) ) gvzibkulivqryamzdxzm = 2 ; return gvzibkulivqryamzdxzm ; } <s> public int getScaleQual () { digilib.image.ImageJobDescription.logger . debug ( "get_scaleQual()" ) ; int gvzibkulivqryamzdxzm = dlConfig . getAsInt ( "default-quality" ) ; if ( hasOption ( "q0" ) ) gvzibkulivqryamzdxzm = 0 ; else if ( hasOption ( "q1" ) ) gvzibkulivqryamzdxzm = 1 ; else if ( hasOption ( "q2" ) ) gvzibkulivqryamzdxzm = 2 ; return gvzibkulivqryamzdxzm ; } <s> fixed black-last-pixel bug by rounding up scale factor in ImageLoaderDocuImage.scale(). added comments and formatting.  --HG-- branch : new_scaling
fix_before_refactoring: { int qual = dlConfig . getAsInt ( "default-quality" ) ; if ( hasOption ( "q0" ) ) qual = 0 ; else if ( hasOption ( "q1" ) ) qual = 1 ; else if ( hasOption ( "q2" ) ) qual = 2 ; return qual ; }
fix_after_refactoring: { int gvzibkulivqryamzdxzm = dlConfig . getAsInt ( "default-quality" ) ; if ( hasOption ( "q0" ) ) gvzibkulivqryamzdxzm = 0 ; else if ( hasOption ( "q1" ) ) gvzibkulivqryamzdxzm = 1 ; else if ( hasOption ( "q2" ) ) gvzibkulivqryamzdxzm = 2 ; return gvzibkulivqryamzdxzm ; }
√ fix_prediction_before: { int qual = dlConfig . getAsInt ( "default-quality" ) ; if ( hasOption ( "q0" ) ) qual = 0 ; else if ( hasOption ( "q1" ) ) qual = 1 ; else if ( hasOption ( "q2" ) ) qual = 2 ; return qual ; }
√ fix_prediction_after: { int gvzibkulivqryamzdxzm = dlConfig . getAsInt ( "default-quality" ) ; if ( hasOption ( "q0" ) ) gvzibkulivqryamzdxzm = 0 ; else if ( hasOption ( "q1" ) ) gvzibkulivqryamzdxzm = 1 ; else if ( hasOption ( "q2" ) ) gvzibkulivqryamzdxzm = 2 ; return gvzibkulivqryamzdxzm ; }

line_index: 409
bug_before_refactoring: { super . onResume () ; int orderId = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; java.lang.System.out . println ( ( "Intent with order ID " + orderId ) ) ; if ( orderId != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( orderId ) ) ) ; } <s> @ java.lang.Override protected void onResume () { super . onResume () ; int orderId = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; java.lang.System.out . println ( ( "Intent with order ID " + orderId ) ) ; if ( orderId != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( orderId ) ) ) ; } <s> Fixed sidebar rotation bug
bug_after_refactoring: { super . onResume () ; int mblkstxlgakrqeurrpkc = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; java.lang.System.out . println ( ( "Intent with order ID " + mblkstxlgakrqeurrpkc ) ) ; if ( mblkstxlgakrqeurrpkc != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( mblkstxlgakrqeurrpkc ) ) ) ; } <s> @ java.lang.Override protected void onResume () { super . onResume () ; int mblkstxlgakrqeurrpkc = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; java.lang.System.out . println ( ( "Intent with order ID " + mblkstxlgakrqeurrpkc ) ) ; if ( mblkstxlgakrqeurrpkc != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( mblkstxlgakrqeurrpkc ) ) ) ; } <s> Fixed sidebar rotation bug
fix_before_refactoring: { super . onResume () ; int orderId = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; if ( orderId != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( orderId ) ) ) ; }
fix_after_refactoring: { super . onResume () ; int mblkstxlgakrqeurrpkc = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; if ( mblkstxlgakrqeurrpkc != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( mblkstxlgakrqeurrpkc ) ) ) ; }
√ fix_prediction_before: { super . onResume () ; int orderId = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; if ( orderId != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( orderId ) ) ) ; }
√ fix_prediction_after: { super . onResume () ; int mblkstxlgakrqeurrpkc = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; if ( mblkstxlgakrqeurrpkc != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( mblkstxlgakrqeurrpkc ) ) ) ; }

line_index: 417
bug_before_refactoring: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / higherValue ) ) ) ; java.lang.System.out . println ( ( "Ordenado: " + ( q . getThreeYearTotal () ) ) ) ; } <s> private static void calculateDiscount () { java.util.Collections . sort ( Constants.quotes ) ; double higherValue = Constants.quotes . get ( 0 ) . getThreeYearTotal () ; if ( higherValue > 0 ) { for ( com.amazon.proposalcalculator.bean.Quote q : com.amazon.proposalcalculator.utils.Constants.quotes ) { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / higherValue ) ) ) ; java.lang.System.out . println ( ( "Ordenado: " + ( q . getThreeYearTotal () ) ) ) ; } } } <s> Bug fix
bug_after_refactoring: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / ubulzylmnwmntivrjhha ) ) ) ; java.lang.System.out . println ( ( "Ordenado: " + ( q . getThreeYearTotal () ) ) ) ; } <s> private static void calculateDiscount () { java.util.Collections . sort ( Constants.quotes ) ; double higherValue = Constants.quotes . get ( 0 ) . getThreeYearTotal () ; if ( higherValue > 0 ) { for ( com.amazon.proposalcalculator.bean.Quote q : com.amazon.proposalcalculator.utils.Constants.quotes ) { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / ubulzylmnwmntivrjhha ) ) ) ; java.lang.System.out . println ( ( "Ordenado: " + ( q . getThreeYearTotal () ) ) ) ; } } } <s> Bug fix
fix_before_refactoring: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / higherValue ) ) ) ; }
fix_after_refactoring: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / ubulzylmnwmntivrjhha ) ) ) ; }
√ fix_prediction_before: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / higherValue ) ) ) ; }
√ fix_prediction_after: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / ubulzylmnwmntivrjhha ) ) ) ; }

line_index: 434
bug_before_refactoring: { tagName = tagName . toLowerCase () ; boolean usesAttributes = ! ( ( ( tagName . equals ( "cfset" ) ) || ( tagName . equals ( "cfif" ) ) ) || ( tagName . equals ( "cfelseif" ) ) ) ; java.lang.System.out . println ( ( ( ( "usesAttributes: " + tagName ) + ":" ) + usesAttributes ) ) ; return usesAttributes ; } <s> @ java.lang.Override public boolean usesAttributes ( java.lang.String tagName ) { tagName = tagName . toLowerCase () ; boolean usesAttributes = ! ( ( ( tagName . equals ( "cfset" ) ) || ( tagName . equals ( "cfif" ) ) ) || ( tagName . equals ( "cfelseif" ) ) ) ; java.lang.System.out . println ( ( ( ( "usesAttributes: " + tagName ) + ":" ) + usesAttributes ) ) ; return usesAttributes ; } <s> https://github.com/cflint/CFLint/issues/261  fixed the semi checking. and cleanup some sysouts
bug_after_refactoring: { tagName = tagName . toLowerCase () ; boolean qbbujtkijiqsdnmrqinf = ! ( ( ( tagName . equals ( "cfset" ) ) || ( tagName . equals ( "cfif" ) ) ) || ( tagName . equals ( "cfelseif" ) ) ) ; java.lang.System.out . println ( ( ( ( "qbbujtkijiqsdnmrqinf: " + tagName ) + ":" ) + qbbujtkijiqsdnmrqinf ) ) ; return qbbujtkijiqsdnmrqinf ; } <s> @ java.lang.Override public boolean usesAttributes ( java.lang.String tagName ) { tagName = tagName . toLowerCase () ; boolean qbbujtkijiqsdnmrqinf = ! ( ( ( tagName . equals ( "cfset" ) ) || ( tagName . equals ( "cfif" ) ) ) || ( tagName . equals ( "cfelseif" ) ) ) ; java.lang.System.out . println ( ( ( ( "qbbujtkijiqsdnmrqinf: " + tagName ) + ":" ) + qbbujtkijiqsdnmrqinf ) ) ; return qbbujtkijiqsdnmrqinf ; } <s> https://github.com/cflint/CFLint/issues/261  fixed the semi checking. and cleanup some sysouts
fix_before_refactoring: { tagName = tagName . toLowerCase () ; boolean usesAttributes = ! ( ( ( tagName . equals ( "cfset" ) ) || ( tagName . equals ( "cfif" ) ) ) || ( tagName . equals ( "cfelseif" ) ) ) ; return usesAttributes ; }
fix_after_refactoring: { tagName = tagName . toLowerCase () ; boolean qbbujtkijiqsdnmrqinf = ! ( ( ( tagName . equals ( "cfset" ) ) || ( tagName . equals ( "cfif" ) ) ) || ( tagName . equals ( "cfelseif" ) ) ) ; return qbbujtkijiqsdnmrqinf ; }
√ fix_prediction_before: { tagName = tagName . toLowerCase () ; boolean usesAttributes = ! ( ( ( tagName . equals ( "cfset" ) ) || ( tagName . equals ( "cfif" ) ) ) || ( tagName . equals ( "cfelseif" ) ) ) ; return usesAttributes ; }
√ fix_prediction_after: { tagName = tagName . toLowerCase () ; boolean qbbujtkijiqsdnmrqinf = ! ( ( ( tagName . equals ( "cfset" ) ) || ( tagName . equals ( "cfif" ) ) ) || ( tagName . equals ( "cfelseif" ) ) ) ; return qbbujtkijiqsdnmrqinf ; }

line_index: 441
bug_before_refactoring: getSlotFromIndex ( index ) <s> @ java.lang.Override public net.minecraft.item.ItemStack insertItem ( int slot , net.minecraft.item.ItemStack stack , boolean simulate ) { int index = getIndexForSlot ( slot ) ; net.minecraftforge.items.IItemHandlerModifiable handler = getHandlerFromIndex ( index ) ; slot = getSlotFromIndex ( index ) ; return handler . insertItem ( slot , stack , simulate ) ; } <s> Merge pull request #2539 from bonii-xx/bugfix  Fix CombinedInvWrapper accessing incorrect slots
bug_after_refactoring: getSlotFromIndex ( ysgljyuatzqmlavwfeco ) <s> @ java.lang.Override public net.minecraft.item.ItemStack insertItem ( int slot , net.minecraft.item.ItemStack stack , boolean simulate ) { int index = getIndexForSlot ( slot ) ; net.minecraftforge.items.IItemHandlerModifiable handler = getHandlerFromIndex ( index ) ; slot = getSlotFromIndex ( ysgljyuatzqmlavwfeco ) ; return handler . insertItem ( slot , stack , simulate ) ; } <s> Merge pull request #2539 from bonii-xx/bugfix  Fix CombinedInvWrapper accessing incorrect slots
fix_before_refactoring: getSlotFromIndex ( slot , index )
fix_after_refactoring: getSlotFromIndex ( slot , ysgljyuatzqmlavwfeco )
√ fix_prediction_before: getSlotFromIndex ( slot , index )
√ fix_prediction_after: getSlotFromIndex ( slot , ysgljyuatzqmlavwfeco )

line_index: 454
bug_before_refactoring: lastOut += given <s> @ java.lang.Override public int requestEnergy ( int energy , boolean simulate ) { int given = this . storage . extractEnergy ( energy , simulate ) ; if ( ! simulate ) { this . markDirty () ; if ( ! ( worldObj.isRemote ) ) { lastOut += given ; } } return given ; } <s> actually fixes the debug text on the entangler
bug_after_refactoring: lastOut += okdphjtilixrcgtukjyg <s> @ java.lang.Override public int requestEnergy ( int energy , boolean simulate ) { int given = this . storage . extractEnergy ( energy , simulate ) ; if ( ! simulate ) { this . markDirty () ; if ( ! ( worldObj.isRemote ) ) { lastOut += okdphjtilixrcgtukjyg ; } } return given ; } <s> actually fixes the debug text on the entangler
fix_before_refactoring: this . lastOut += given
fix_after_refactoring: this . lastOut += okdphjtilixrcgtukjyg
√ fix_prediction_before: this . lastOut += given
√ fix_prediction_after: this . lastOut += okdphjtilixrcgtukjyg

line_index: 460
bug_before_refactoring: { java.lang.System.out . println ( "aa0" ) ; double [] gen = new double [ xp.length ] ; double [] gradient = new double [ coeffs.length ] ; double [] diffY = new double [ xp.length ] ; double sumDiff = calcGradient ( coeffs , gen , gradient , diffY ) ; java.lang.System.out . println ( ( "poly coeffs=" + ( java.util.Arrays . toString ( coeffs ) ) ) ) ; java.lang.System.out . println ( ( " diff=" + sumDiff ) ) ; return sumDiff ; } <s> @ java.lang.Override public double f ( double [] coeffs ) { java.lang.System.out . println ( "aa0" ) ; double [] gen = new double [ xp.length ] ; double [] gradient = new double [ coeffs.length ] ; double [] diffY = new double [ xp.length ] ; double sumDiff = calcGradient ( coeffs , gen , gradient , diffY ) ; java.lang.System.out . println ( ( "poly coeffs=" + ( java.util.Arrays . toString ( coeffs ) ) ) ) ; java.lang.System.out . println ( ( "  diff=" + sumDiff ) ) ; return sumDiff ; } <s> bug fix to newly ported c++ LBFGS
bug_after_refactoring: { java.lang.System.out . println ( "aa0" ) ; double [] hkugyejefvfcuynmvmow = new double [ xp.length ] ; double [] sncukkvwvlcdcpaklleb = new double [ coeffs.length ] ; double [] kaxqpktsbcsrkfxcpihc = new double [ xp.length ] ; double jhkyagfzaznmckdtmnal = calcGradient ( coeffs , hkugyejefvfcuynmvmow , sncukkvwvlcdcpaklleb , kaxqpktsbcsrkfxcpihc ) ; java.lang.System.out . println ( ( "poly coeffs=" + ( java.util.Arrays . toString ( coeffs ) ) ) ) ; java.lang.System.out . println ( ( " diff=" + jhkyagfzaznmckdtmnal ) ) ; return jhkyagfzaznmckdtmnal ; } <s> @ java.lang.Override public double f ( double [] coeffs ) { java.lang.System.out . println ( "aa0" ) ; double [] gen = new double [ xp.length ] ; double [] gradient = new double [ coeffs.length ] ; double [] diffY = new double [ xp.length ] ; double sumDiff = calcGradient ( coeffs , gen , gradient , diffY ) ; java.lang.System.out . println ( ( "poly coeffs=" + ( java.util.Arrays . toString ( coeffs ) ) ) ) ; java.lang.System.out . println ( ( "  diff=" + sumDiff ) ) ; return sumDiff ; } <s> bug fix to newly ported c++ LBFGS
fix_before_refactoring: { double [] gen = new double [ xp.length ] ; double [] gradient = new double [ coeffs.length ] ; double [] diffY = new double [ xp.length ] ; double sumDiff = calcGradient ( coeffs , gen , gradient , diffY ) ; return sumDiff ; }
fix_after_refactoring: { double [] hkugyejefvfcuynmvmow = new double [ xp.length ] ; double [] sncukkvwvlcdcpaklleb = new double [ coeffs.length ] ; double [] kaxqpktsbcsrkfxcpihc = new double [ xp.length ] ; double jhkyagfzaznmckdtmnal = calcGradient ( coeffs , hkugyejefvfcuynmvmow , sncukkvwvlcdcpaklleb , kaxqpktsbcsrkfxcpihc ) ; return jhkyagfzaznmckdtmnal ; }
√ fix_prediction_before: { double [] gen = new double [ xp.length ] ; double [] gradient = new double [ coeffs.length ] ; double [] diffY = new double [ xp.length ] ; double sumDiff = calcGradient ( coeffs , gen , gradient , diffY ) ; return sumDiff ; }
√ fix_prediction_after: { double [] hkugyejefvfcuynmvmow = new double [ xp.length ] ; double [] sncukkvwvlcdcpaklleb = new double [ coeffs.length ] ; double [] kaxqpktsbcsrkfxcpihc = new double [ xp.length ] ; double jhkyagfzaznmckdtmnal = calcGradient ( coeffs , hkugyejefvfcuynmvmow , sncukkvwvlcdcpaklleb , kaxqpktsbcsrkfxcpihc ) ; return jhkyagfzaznmckdtmnal ; }

line_index: 471
bug_before_refactoring: { int totalProtection = getProtection () ; if ( ( ( getAnchorPoints () . get ( "body" ) ) != null ) && ( ( getAnchorPoints () . get ( "body" ) . getClass () ) == ( game.Armor . class ) ) ) { game.Armor armor = ( ( game.Armor ) ( getAnchorPoints () . get ( "body" ) ) ) ; totalProtection += armor . getActualProtection () ; } return totalProtection ; return 0 > ( ( origin ) / ( master ) ) ; } <s> @ java.lang.Override public int getTotalProtection () { int totalProtection = getProtection () ; if ( ( ( getAnchorPoints () . get ( "body" ) ) != null ) && ( ( getAnchorPoints () . get ( "body" ) . getClass () ) == ( game.Armor . class ) ) ) { game.Armor armor = ( ( game.Armor ) ( getAnchorPoints () . get ( "body" ) ) ) ; totalProtection += armor . getActualProtection () ; } return totalProtection ; return 0 > ( ( origin ) / ( master ) ) ; } <s> merge problems fix
bug_after_refactoring: { int rpvmjmnmmrnrkedavdgj = getProtection () ; if ( ( ( getAnchorPoints () . get ( "body" ) ) != null ) && ( ( getAnchorPoints () . get ( "body" ) . getClass () ) == ( game.Armor . class ) ) ) { game.Armor armor = ( ( game.Armor ) ( getAnchorPoints () . get ( "body" ) ) ) ; rpvmjmnmmrnrkedavdgj += armor . getActualProtection () ; } return rpvmjmnmmrnrkedavdgj ; return 0 > ( ( origin ) / ( master ) ) ; } <s> @ java.lang.Override public int getTotalProtection () { int rpvmjmnmmrnrkedavdgj = getProtection () ; if ( ( ( getAnchorPoints () . get ( "body" ) ) != null ) && ( ( getAnchorPoints () . get ( "body" ) . getClass () ) == ( game.Armor . class ) ) ) { game.Armor armor = ( ( game.Armor ) ( getAnchorPoints () . get ( "body" ) ) ) ; rpvmjmnmmrnrkedavdgj += armor . getActualProtection () ; } return rpvmjmnmmrnrkedavdgj ; return 0 > ( ( origin ) / ( master ) ) ; } <s> merge problems fix
fix_before_refactoring: { int totalProtection = getProtection () ; if ( ( ( getAnchorPoints () . get ( "body" ) ) != null ) && ( ( getAnchorPoints () . get ( "body" ) . getClass () ) == ( game.Armor . class ) ) ) { game.Armor armor = ( ( game.Armor ) ( getAnchorPoints () . get ( "body" ) ) ) ; totalProtection += armor . getActualProtection () ; } return totalProtection ; }
fix_after_refactoring: { int rpvmjmnmmrnrkedavdgj = getProtection () ; if ( ( ( getAnchorPoints () . get ( "body" ) ) != null ) && ( ( getAnchorPoints () . get ( "body" ) . getClass () ) == ( game.Armor . class ) ) ) { game.Armor armor = ( ( game.Armor ) ( getAnchorPoints () . get ( "body" ) ) ) ; rpvmjmnmmrnrkedavdgj += armor . getActualProtection () ; } return rpvmjmnmmrnrkedavdgj ; }
√ fix_prediction_before: { int totalProtection = getProtection () ; if ( ( ( getAnchorPoints () . get ( "body" ) ) != null ) && ( ( getAnchorPoints () . get ( "body" ) . getClass () ) == ( game.Armor . class ) ) ) { game.Armor armor = ( ( game.Armor ) ( getAnchorPoints () . get ( "body" ) ) ) ; totalProtection += armor . getActualProtection () ; } return totalProtection ; }
√ fix_prediction_after: { int rpvmjmnmmrnrkedavdgj = getProtection () ; if ( ( ( getAnchorPoints () . get ( "body" ) ) != null ) && ( ( getAnchorPoints () . get ( "body" ) . getClass () ) == ( game.Armor . class ) ) ) { game.Armor armor = ( ( game.Armor ) ( getAnchorPoints () . get ( "body" ) ) ) ; rpvmjmnmmrnrkedavdgj += armor . getActualProtection () ; } return rpvmjmnmmrnrkedavdgj ; }

line_index: 484
bug_before_refactoring: { android.util.Log . v ( "DLAsync.urlInHashSet" , ( ( ( " just found " + ( url . toString () ) ) + " in " ) + ( set . toString () ) ) ) ; returnBoolean = true ; } <s> private boolean urlInHashSet ( java.net.URL url , java.util.HashSet < java.lang.String > set ) { boolean returnBoolean = false ; for ( java.lang.String setItem : set ) { if ( com.wordpress.httpspandareaktor.scrapetest.NetworkUtils . urlHostPathMatch ( com.wordpress.httpspandareaktor.scrapetest.NetworkUtils . makeURL ( setItem ) , url ) ) { android.util.Log . v ( "DLAsync.urlInHashSet" , ( ( ( " just found " + ( url . toString () ) ) + " in " ) + ( set . toString () ) ) ) ; returnBoolean = true ; } } return returnBoolean ; } <s> -interface might've not been necessary given additional multithreading to solve access to MainActivity views issue from WebView's thread  but leaving it for now -seems to be crawling  tests conclude that UI is being updated with emails and html response -improved regex filter to leave out filenames  and other garbage that was being collected
bug_after_refactoring: { android.util.Log . v ( "DLAsync.urlInHashSet" , ( ( ( " just found " + ( url . toString () ) ) + " in " ) + ( set . toString () ) ) ) ; axxwnjjndweizjsuwfqk = true ; } <s> private boolean urlInHashSet ( java.net.URL url , java.util.HashSet < java.lang.String > set ) { boolean returnBoolean = false ; for ( java.lang.String setItem : set ) { if ( com.wordpress.httpspandareaktor.scrapetest.NetworkUtils . urlHostPathMatch ( com.wordpress.httpspandareaktor.scrapetest.NetworkUtils . makeURL ( setItem ) , url ) ) { android.util.Log . v ( "DLAsync.urlInHashSet" , ( ( ( " just found " + ( url . toString () ) ) + " in " ) + ( set . toString () ) ) ) ; axxwnjjndweizjsuwfqk = true ; } } return returnBoolean ; } <s> -interface might've not been necessary given additional multithreading to solve access to MainActivity views issue from WebView's thread  but leaving it for now -seems to be crawling  tests conclude that UI is being updated with emails and html response -improved regex filter to leave out filenames  and other garbage that was being collected
fix_before_refactoring: { returnBoolean = true ; }
fix_after_refactoring: { axxwnjjndweizjsuwfqk = true ; }
√ fix_prediction_before: { returnBoolean = true ; }
√ fix_prediction_after: { axxwnjjndweizjsuwfqk = true ; }

line_index: 524
bug_before_refactoring: { java.lang.String item = "%d %d 0" ; long curTime = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , curTime , e . getKeyCode () ) ) ; java.lang.System.out . println ( ( ( e . getKeyChar () ) + " 0" ) ) ; } <s> @ java.lang.Override public void keyPressed ( java.awt.event.KeyEvent e ) { if ( ( ( remain . length () ) == 0 ) && ( ( e . getKeyCode () ) != ( java.awt.event.KeyEvent.VK_ENTER ) ) ) { e . consume () ; retype () ; } else { java.lang.String item = "%d %d 0" ; long curTime = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , curTime , e . getKeyCode () ) ) ; java.lang.System.out . println ( ( ( e . getKeyChar () ) + " 0" ) ) ; } } <s> Fix bug that a release event may be captured at beginning of sampling
bug_after_refactoring: { java.lang.String item = "%d %d 0" ; long xuckavxmfiveeicaqjfa = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , xuckavxmfiveeicaqjfa , e . getKeyCode () ) ) ; java.lang.System.out . println ( ( ( e . getKeyChar () ) + " 0" ) ) ; } <s> @ java.lang.Override public void keyPressed ( java.awt.event.KeyEvent e ) { if ( ( ( remain . length () ) == 0 ) && ( ( e . getKeyCode () ) != ( java.awt.event.KeyEvent.VK_ENTER ) ) ) { e . consume () ; retype () ; } else { java.lang.String item = "%d %d 0" ; long xuckavxmfiveeicaqjfa = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , xuckavxmfiveeicaqjfa , e . getKeyCode () ) ) ; java.lang.System.out . println ( ( ( e . getKeyChar () ) + " 0" ) ) ; } } <s> Fix bug that a release event may be captured at beginning of sampling
fix_before_refactoring: { java.lang.String item = "%d %d 0" ; long curTime = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , curTime , e . getKeyCode () ) ) ; }
fix_after_refactoring: { java.lang.String item = "%d %d 0" ; long xuckavxmfiveeicaqjfa = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , xuckavxmfiveeicaqjfa , e . getKeyCode () ) ) ; }
√ fix_prediction_before: { java.lang.String item = "%d %d 0" ; long curTime = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , curTime , e . getKeyCode () ) ) ; }
√ fix_prediction_after: { java.lang.String item = "%d %d 0" ; long xuckavxmfiveeicaqjfa = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , xuckavxmfiveeicaqjfa , e . getKeyCode () ) ) ; }

line_index: 557
bug_before_refactoring: x < 10 <s> private void SendFileContent ( java.net.Socket conn , java.io.InputStream fileIs ) throws java.io.IOException { java.io.OutputStream os = conn . getOutputStream () ; byte [] b = new byte [ 1024 ] ; int x = fileIs . read ( b ) ; while ( x != ( - 1 ) ) { if ( x < 10 ) { b = java.util.Arrays . copyOf ( b , x ) ; } os . write ( b ) ; x = fileIs . read ( b ) ; } } <s> Fixed few errors
bug_after_refactoring: pocpfymimocpkmanivdb < 10 <s> private void SendFileContent ( java.net.Socket conn , java.io.InputStream fileIs ) throws java.io.IOException { java.io.OutputStream os = conn . getOutputStream () ; byte [] b = new byte [ 1024 ] ; int x = fileIs . read ( b ) ; while ( x != ( - 1 ) ) { if ( pocpfymimocpkmanivdb < 10 ) { b = java.util.Arrays . copyOf ( b , x ) ; } os . write ( b ) ; x = fileIs . read ( b ) ; } } <s> Fixed few errors
fix_before_refactoring: x < 1024
fix_after_refactoring: pocpfymimocpkmanivdb < 1024
√ fix_prediction_before: x < 1024
√ fix_prediction_after: pocpfymimocpkmanivdb < 1024

line_index: 584
bug_before_refactoring: if ( ( chapter . getStartTimeOffset () ) > position ) { ret = chapter . getStartTimeOffset () ; break; } <s> public long getNextChapterStart ( long position ) { long ret = com.monsterbutt.homeview.plex.media.PlexVideoItem.BAD_CHAPTER_START ; if ( hasChapters () ) { for ( com.monsterbutt.homeview.plex.media.Chapter chapter : mVideo . getChapters () ) { if ( ( chapter . getStartTimeOffset () ) > position ) { ret = chapter . getStartTimeOffset () ; break; } } } return ret ; } <s> fix chapter starts issue
bug_after_refactoring: if ( ( chapter . getStartTimeOffset () ) > position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; } <s> public long getNextChapterStart ( long position ) { long ret = com.monsterbutt.homeview.plex.media.PlexVideoItem.BAD_CHAPTER_START ; if ( hasChapters () ) { for ( com.monsterbutt.homeview.plex.media.Chapter chapter : mVideo . getChapters () ) { if ( ( chapter . getStartTimeOffset () ) > position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; } } } return ret ; } <s> fix chapter starts issue
fix_before_refactoring: if ( ( chapter . getStartTimeOffset () ) >= position ) { ret = chapter . getStartTimeOffset () ; break; }
fix_after_refactoring: if ( ( chapter . getStartTimeOffset () ) >= position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; }
√ fix_prediction_before: if ( ( chapter . getStartTimeOffset () ) >= position ) { ret = chapter . getStartTimeOffset () ; break; }
√ fix_prediction_after: if ( ( chapter . getStartTimeOffset () ) >= position ) { pldvjjivxhhxvsnwifxf = chapter . getStartTimeOffset () ; break; }

line_index: 595
bug_before_refactoring: if ( t > 10000 ) { t -= 10000 ; type ++ ; } <s> @ java.lang.Override public r48.RubyIO targetToBound ( r48.RubyIO target ) { long t = target.fixnumVal ; long type = 0 ; if ( t > 10000 ) { t -= 10000 ; type ++ ; } r48.RubyIO base = new r48.RubyIO () ; base.arrVal = new r48.RubyIO [ 2 ] ; base.type = '[' ; base.arrVal [ 0 ] = new r48.RubyIO () . setFX ( type ) ; base.arrVal [ 1 ] = new r48.RubyIO () . setFX ( t ) ; return base ; } <s> Fix small editing issues with PPP values
bug_after_refactoring: if ( znithxqdopxksvbmcziq > 10000 ) { znithxqdopxksvbmcziq -= 10000 ; gzilnpdfnymammfqxhkm ++ ; } <s> @ java.lang.Override public r48.RubyIO targetToBound ( r48.RubyIO target ) { long t = target.fixnumVal ; long type = 0 ; if ( znithxqdopxksvbmcziq > 10000 ) { znithxqdopxksvbmcziq -= 10000 ; gzilnpdfnymammfqxhkm ++ ; } r48.RubyIO base = new r48.RubyIO () ; base.arrVal = new r48.RubyIO [ 2 ] ; base.type = '[' ; base.arrVal [ 0 ] = new r48.RubyIO () . setFX ( type ) ; base.arrVal [ 1 ] = new r48.RubyIO () . setFX ( t ) ; return base ; } <s> Fix small editing issues with PPP values
fix_before_refactoring: if ( t >= 10000 ) { t -= 10000 ; type ++ ; }
fix_after_refactoring: if ( znithxqdopxksvbmcziq >= 10000 ) { znithxqdopxksvbmcziq -= 10000 ; gzilnpdfnymammfqxhkm ++ ; }
√ fix_prediction_before: if ( t >= 10000 ) { t -= 10000 ; type ++ ; }
√ fix_prediction_after: if ( znithxqdopxksvbmcziq >= 10000 ) { znithxqdopxksvbmcziq -= 10000 ; gzilnpdfnymammfqxhkm ++ ; }

line_index: 643
bug_before_refactoring: try { iport = java.lang.Integer . parseInt ( port ) ; localServer = server.ServerFactory . createServer ( iport ) ; localServer . startUp () ; this . connect ( "localhost" , ( "" + port ) ) ; } catch ( java.lang.NumberFormatException nfe ) { showFail ( loginScreen , "Please insert a real number at the Port-Field." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "Port is already in use, please enter another Port." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "The specified port is already in use. Please choose another port." ) ; } <s> public void createLocalServer ( java.lang.String port ) { int iport = - 1 ; try { iport = java.lang.Integer . parseInt ( port ) ; localServer = server.ServerFactory . createServer ( iport ) ; localServer . startUp () ; this . connect ( "localhost" , ( "" + port ) ) ; } catch ( java.lang.NumberFormatException nfe ) { showFail ( loginScreen , "Please insert a real number at the Port-Field." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "Port is already in use, please enter another Port." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "The specified port is already in use. Please choose another port." ) ; } } <s> bug fixes new client and server  -fixed bug in server where clients without player status could signal the server that the player has finished playback -fixed bug in new client where the next track label was not updated on a gap list update
bug_after_refactoring: try { kwjfnxxrzfwreibtoggv = java.lang.Integer . parseInt ( port ) ; localServer = server.ServerFactory . createServer ( kwjfnxxrzfwreibtoggv ) ; localServer . startUp () ; this . connect ( "localhost" , ( "" + port ) ) ; } catch ( java.lang.NumberFormatException nfe ) { showFail ( loginScreen , "Please insert a real number at the Port-Field." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "Port is already in use, please enter another Port." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "The specified port is already in use. Please choose another port." ) ; } <s> public void createLocalServer ( java.lang.String port ) { int iport = - 1 ; try { kwjfnxxrzfwreibtoggv = java.lang.Integer . parseInt ( port ) ; localServer = server.ServerFactory . createServer ( kwjfnxxrzfwreibtoggv ) ; localServer . startUp () ; this . connect ( "localhost" , ( "" + port ) ) ; } catch ( java.lang.NumberFormatException nfe ) { showFail ( loginScreen , "Please insert a real number at the Port-Field." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "Port is already in use, please enter another Port." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "The specified port is already in use. Please choose another port." ) ; } } <s> bug fixes new client and server  -fixed bug in server where clients without player status could signal the server that the player has finished playback -fixed bug in new client where the next track label was not updated on a gap list update
fix_before_refactoring: try { iport = java.lang.Integer . parseInt ( port ) ; localServer = server.ServerFactory . createServer ( iport ) ; localServer . startUp () ; this . connect ( "localhost" , ( "" + port ) ) ; } catch ( java.lang.NumberFormatException nfe ) { showFail ( loginScreen , "Please insert a real number at the Port-Field." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "Port is already in use, please enter another Port." ) ; }
fix_after_refactoring: try { kwjfnxxrzfwreibtoggv = java.lang.Integer . parseInt ( port ) ; localServer = server.ServerFactory . createServer ( kwjfnxxrzfwreibtoggv ) ; localServer . startUp () ; this . connect ( "localhost" , ( "" + port ) ) ; } catch ( java.lang.NumberFormatException nfe ) { showFail ( loginScreen , "Please insert a real number at the Port-Field." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "Port is already in use, please enter another Port." ) ; }
√ fix_prediction_before: try { iport = java.lang.Integer . parseInt ( port ) ; localServer = server.ServerFactory . createServer ( iport ) ; localServer . startUp () ; this . connect ( "localhost" , ( "" + port ) ) ; } catch ( java.lang.NumberFormatException nfe ) { showFail ( loginScreen , "Please insert a real number at the Port-Field." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "Port is already in use, please enter another Port." ) ; }
√ fix_prediction_after: try { kwjfnxxrzfwreibtoggv = java.lang.Integer . parseInt ( port ) ; localServer = server.ServerFactory . createServer ( kwjfnxxrzfwreibtoggv ) ; localServer . startUp () ; this . connect ( "localhost" , ( "" + port ) ) ; } catch ( java.lang.NumberFormatException nfe ) { showFail ( loginScreen , "Please insert a real number at the Port-Field." ) ; } catch ( java.net.BindException e ) { showFail ( loginScreen , "Port is already in use, please enter another Port." ) ; }

line_index: 651
bug_before_refactoring: c = false <s> public static void main ( java.lang.String [] args ) { boolean a = false ; boolean b = false ; boolean c = false ; boolean p = ( ( ( a || b ) || c ) && ( ( ( ! a ) || b ) || c ) ) && ( ( ( ! a ) || ( ! b ) ) || c ) ; java.lang.System.out . println ( p ) ; } <s> fixed bug in case split
bug_after_refactoring: pssrntssnykjmmscrysz = false <s> public static void main ( java.lang.String [] args ) { boolean a = false ; boolean b = false ; boolean pssrntssnykjmmscrysz = false ; boolean p = ( ( ( a || b ) || c ) && ( ( ( ! a ) || b ) || c ) ) && ( ( ( ! a ) || ( ! b ) ) || c ) ; java.lang.System.out . println ( p ) ; } <s> fixed bug in case split
fix_before_refactoring: c = true
fix_after_refactoring: pssrntssnykjmmscrysz = true
√ fix_prediction_before: c = true
√ fix_prediction_after: pssrntssnykjmmscrysz = true

line_index: 653
bug_before_refactoring: try { int balance = getOrZero ( userId ) ; balances . put ( userId , ( balance + value ) ) ; writeLog ( "DEPOSIT" , userId , "" , value ) ; return true ; } finally { RWLock . writeLock () . unlock () ; } <s> public boolean deposit ( java.lang.String userId , int value ) { if ( value < 0 ) return false ; RWLock . writeLock () . lock () ; try { int balance = getOrZero ( userId ) ; balances . put ( userId , ( balance + value ) ) ; writeLog ( "DEPOSIT" , userId , "" , value ) ; return true ; } finally { RWLock . writeLock () . unlock () ; } } <s> Fix the bug: write the log but not return true
bug_after_refactoring: try { int pqhawkfuzjcvtphstfbu = getOrZero ( userId ) ; balances . put ( userId , ( pqhawkfuzjcvtphstfbu + value ) ) ; writeLog ( "DEPOSIT" , userId , "" , value ) ; return true ; } finally { RWLock . writeLock () . unlock () ; } <s> public boolean deposit ( java.lang.String userId , int value ) { if ( value < 0 ) return false ; RWLock . writeLock () . lock () ; try { int pqhawkfuzjcvtphstfbu = getOrZero ( userId ) ; balances . put ( userId , ( pqhawkfuzjcvtphstfbu + value ) ) ; writeLog ( "DEPOSIT" , userId , "" , value ) ; return true ; } finally { RWLock . writeLock () . unlock () ; } } <s> Fix the bug: write the log but not return true
fix_before_refactoring: try { int balance = getOrZero ( userId ) ; balances . put ( userId , ( balance + value ) ) ; return true ; } finally { writeLog ( "DEPOSIT" , userId , "" , value ) ; RWLock . writeLock () . unlock () ; }
fix_after_refactoring: try { int pqhawkfuzjcvtphstfbu = getOrZero ( userId ) ; balances . put ( userId , ( pqhawkfuzjcvtphstfbu + value ) ) ; return true ; } finally { writeLog ( "DEPOSIT" , userId , "" , value ) ; RWLock . writeLock () . unlock () ; }
√ fix_prediction_before: try { int balance = getOrZero ( userId ) ; balances . put ( userId , ( balance + value ) ) ; return true ; } finally { writeLog ( "DEPOSIT" , userId , "" , value ) ; RWLock . writeLock () . unlock () ; }
√ fix_prediction_after: try { int pqhawkfuzjcvtphstfbu = getOrZero ( userId ) ; balances . put ( userId , ( pqhawkfuzjcvtphstfbu + value ) ) ; return true ; } finally { writeLog ( "DEPOSIT" , userId , "" , value ) ; RWLock . writeLock () . unlock () ; }

line_index: 692
bug_before_refactoring: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean deleteResult = thisFile . delete () ; java.lang.System.out . println ( deleteResult ) ; return wanted ; } <s> @ java.lang.Override public com.edu.nju.asi.service.serviceImpl.Case uploadOnline ( org.springframework.web.multipart.MultipartFile uploadedFile ) throws java.io.IOException { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean deleteResult = thisFile . delete () ; java.lang.System.out . println ( deleteResult ) ; return wanted ; } <s> Fix: bugs in XMLSereviceImpl
bug_after_refactoring: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean dmnzufziwwhgensrxzbj = thisFile . delete () ; java.lang.System.out . println ( dmnzufziwwhgensrxzbj ) ; return wanted ; } <s> @ java.lang.Override public com.edu.nju.asi.service.serviceImpl.Case uploadOnline ( org.springframework.web.multipart.MultipartFile uploadedFile ) throws java.io.IOException { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean dmnzufziwwhgensrxzbj = thisFile . delete () ; java.lang.System.out . println ( dmnzufziwwhgensrxzbj ) ; return wanted ; } <s> Fix: bugs in XMLSereviceImpl
fix_before_refactoring: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean deleteResult = thisFile . delete () ; return wanted ; }
fix_after_refactoring: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean dmnzufziwwhgensrxzbj = thisFile . delete () ; return wanted ; }
√ fix_prediction_before: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean deleteResult = thisFile . delete () ; return wanted ; }
√ fix_prediction_after: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean dmnzufziwwhgensrxzbj = thisFile . delete () ; return wanted ; }

line_index: 706
bug_before_refactoring: if ( ( armor > 0 ) || ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; } <s> public int hit ( int armor ) { int damage ; if ( ( armor > 0 ) || ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; } return damage < 0 ? 0 : damage ; } <s> Final Commit of project one. Includes updated main for testing all weapons  debugged weapon factory  and fixed Axe ignoring armor when they werent supposed to bug.   -By Kristopher Doidge
bug_after_refactoring: if ( ( armor > 0 ) || ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; } <s> public int hit ( int armor ) { int damage ; if ( ( armor > 0 ) || ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; } return damage < 0 ? 0 : damage ; } <s> Final Commit of project one. Includes updated main for testing all weapons  debugged weapon factory  and fixed Axe ignoring armor when they werent supposed to bug.   -By Kristopher Doidge
fix_before_refactoring: if ( ( armor > 0 ) && ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; }
fix_after_refactoring: if ( ( armor > 0 ) && ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; }
√ fix_prediction_before: if ( ( armor > 0 ) && ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; }
√ fix_prediction_after: if ( ( armor > 0 ) && ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; }

line_index: 728
bug_before_refactoring: EMPTY_STACK_VALUE = - 1 <s> @ org.junit.Test public void testTop () { edu.kis.vh.stacks.StackFIFO stackObj = new edu.kis.vh.stacks.StackFIFO () ; final int EMPTY_STACK_VALUE = - 1 ; int result = stackObj . top () ; org.junit.Assert . assertEquals ( EMPTY_STACK_VALUE , result ) ; int testValue = 4 ; stackObj . push ( testValue ) ; int testValue1 = 5 ; stackObj . push ( testValue1 ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; } <s> fixed EMPTY_STACK_VALUE issues
bug_after_refactoring: ofontnxwkzmtnxhgkmst = - 1 <s> @ org.junit.Test public void testTop () { edu.kis.vh.stacks.StackFIFO stackObj = new edu.kis.vh.stacks.StackFIFO () ; final int ofontnxwkzmtnxhgkmst = - 1 ; int result = stackObj . top () ; org.junit.Assert . assertEquals ( EMPTY_STACK_VALUE , result ) ; int testValue = 4 ; stackObj . push ( testValue ) ; int testValue1 = 5 ; stackObj . push ( testValue1 ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; } <s> fixed EMPTY_STACK_VALUE issues
fix_before_refactoring: EMPTY_STACK_VALUE = 0
fix_after_refactoring: ofontnxwkzmtnxhgkmst = 0
√ fix_prediction_before: EMPTY_STACK_VALUE = 0
√ fix_prediction_after: ofontnxwkzmtnxhgkmst = 0

line_index: 736
bug_before_refactoring: { int idx = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( idx ) ; latestInst . setRelatedObjId ( objId ) ; java.lang.System.out . println ( ( ( ( "Update obj id: " + latestInst ) + " " ) + objId ) ) ; } <s> public void updateObjIdOnStack ( int objId , int traceBack ) { int idx = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( idx ) ; latestInst . setRelatedObjId ( objId ) ; java.lang.System.out . println ( ( ( ( "Update obj id: " + latestInst ) + " " ) + objId ) ) ; } <s> Fix all bugs for avro   Former-commit-id: b6d6e8db19fc29f7b5705a076c019fc75eb98547
bug_after_refactoring: { int eofxgzxevhfglnpwwhfv = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( eofxgzxevhfglnpwwhfv ) ; latestInst . setRelatedObjId ( objId ) ; java.lang.System.out . println ( ( ( ( "Update obj id: " + latestInst ) + " " ) + objId ) ) ; } <s> public void updateObjIdOnStack ( int objId , int traceBack ) { int eofxgzxevhfglnpwwhfv = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( eofxgzxevhfglnpwwhfv ) ; latestInst . setRelatedObjId ( objId ) ; java.lang.System.out . println ( ( ( ( "Update obj id: " + latestInst ) + " " ) + objId ) ) ; } <s> Fix all bugs for avro   Former-commit-id: b6d6e8db19fc29f7b5705a076c019fc75eb98547
fix_before_refactoring: { int idx = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( idx ) ; latestInst . setRelatedObjId ( objId ) ; }
fix_after_refactoring: { int eofxgzxevhfglnpwwhfv = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( eofxgzxevhfglnpwwhfv ) ; latestInst . setRelatedObjId ( objId ) ; }
√ fix_prediction_before: { int idx = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( idx ) ; latestInst . setRelatedObjId ( objId ) ; }
√ fix_prediction_after: { int eofxgzxevhfglnpwwhfv = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( eofxgzxevhfglnpwwhfv ) ; latestInst . setRelatedObjId ( objId ) ; }

line_index: 745
bug_before_refactoring: { de.uni_hildesheim.sse.monitoring.runtime.recordingServer.RecordingStrategiesElement element = elements . remove ( 0 ) ; element . process ( strategy ) ; int id = element . getIdentification () ; element . clear () ; element . release () ; end = ( Constants.ENDSYSTEM ) == id ; } <s> @ java.lang.Override public void run () { boolean end = false ; while ( ! end ) { if ( ( elements . size () ) > 0 ) { de.uni_hildesheim.sse.monitoring.runtime.recordingServer.RecordingStrategiesElement element = elements . remove ( 0 ) ; element . process ( strategy ) ; int id = element . getIdentification () ; element . clear () ; element . release () ; end = ( Constants.ENDSYSTEM ) == id ; } else { java.lang.Thread . yield () ; } } printElementStatistics () ; } <s> Fixed a bug where the instances from the object pool would not get cleared correctly. This led to an overflow of the pool.
bug_after_refactoring: { de.uni_hildesheim.sse.monitoring.runtime.recordingServer.RecordingStrategiesElement element = elements . remove ( 0 ) ; element . process ( strategy ) ; int jvnscuaaqgaewvicmhsw = element . getIdentification () ; element . clear () ; element . release () ; lrvjquxyrgjyhfqbqjgr = ( Constants.ENDSYSTEM ) == jvnscuaaqgaewvicmhsw ; } <s> @ java.lang.Override public void run () { boolean end = false ; while ( ! end ) { if ( ( elements . size () ) > 0 ) { de.uni_hildesheim.sse.monitoring.runtime.recordingServer.RecordingStrategiesElement element = elements . remove ( 0 ) ; element . process ( strategy ) ; int jvnscuaaqgaewvicmhsw = element . getIdentification () ; element . clear () ; element . release () ; lrvjquxyrgjyhfqbqjgr = ( Constants.ENDSYSTEM ) == jvnscuaaqgaewvicmhsw ; } else { java.lang.Thread . yield () ; } } printElementStatistics () ; } <s> Fixed a bug where the instances from the object pool would not get cleared correctly. This led to an overflow of the pool.
fix_before_refactoring: { de.uni_hildesheim.sse.monitoring.runtime.recordingServer.RecordingStrategiesElement element = elements . remove ( 0 ) ; element . process ( strategy ) ; int id = element . getIdentification () ; element . release () ; end = ( Constants.ENDSYSTEM ) == id ; }
fix_after_refactoring: { de.uni_hildesheim.sse.monitoring.runtime.recordingServer.RecordingStrategiesElement element = elements . remove ( 0 ) ; element . process ( strategy ) ; int jvnscuaaqgaewvicmhsw = element . getIdentification () ; element . release () ; lrvjquxyrgjyhfqbqjgr = ( Constants.ENDSYSTEM ) == jvnscuaaqgaewvicmhsw ; }
√ fix_prediction_before: { de.uni_hildesheim.sse.monitoring.runtime.recordingServer.RecordingStrategiesElement element = elements . remove ( 0 ) ; element . process ( strategy ) ; int id = element . getIdentification () ; element . release () ; end = ( Constants.ENDSYSTEM ) == id ; }
√ fix_prediction_after: { de.uni_hildesheim.sse.monitoring.runtime.recordingServer.RecordingStrategiesElement element = elements . remove ( 0 ) ; element . process ( strategy ) ; int jvnscuaaqgaewvicmhsw = element . getIdentification () ; element . release () ; lrvjquxyrgjyhfqbqjgr = ( Constants.ENDSYSTEM ) == jvnscuaaqgaewvicmhsw ; }

line_index: 755
bug_before_refactoring: for ( java.lang.String bPos : wPawns ) zobristKey ^= bZobrist . get ( bPos ) ; <s> long getZobristKey ( java.util.HashSet < java.lang.String > wPawns , java.util.HashSet < java.lang.String > bPawns ) { long zobristKey = 0 ; for ( java.lang.String wPos : wPawns ) zobristKey ^= wZobrist . get ( wPos ) ; for ( java.lang.String bPos : wPawns ) zobristKey ^= bZobrist . get ( bPos ) ; return zobristKey ; } <s> Bug fix
bug_after_refactoring: for ( java.lang.String bPos : wPawns ) fkcrktdlzvjvhghiljth ^= bZobrist . get ( bPos ) ; <s> long getZobristKey ( java.util.HashSet < java.lang.String > wPawns , java.util.HashSet < java.lang.String > bPawns ) { long zobristKey = 0 ; for ( java.lang.String wPos : wPawns ) zobristKey ^= wZobrist . get ( wPos ) ; for ( java.lang.String bPos : wPawns ) fkcrktdlzvjvhghiljth ^= bZobrist . get ( bPos ) ; return zobristKey ; } <s> Bug fix
fix_before_refactoring: for ( java.lang.String bPos : bPawns ) zobristKey ^= bZobrist . get ( bPos ) ;
fix_after_refactoring: for ( java.lang.String bPos : bPawns ) fkcrktdlzvjvhghiljth ^= bZobrist . get ( bPos ) ;
√ fix_prediction_before: for ( java.lang.String bPos : bPawns ) zobristKey ^= bZobrist . get ( bPos ) ;
√ fix_prediction_after: for ( java.lang.String bPos : bPawns ) fkcrktdlzvjvhghiljth ^= bZobrist . get ( bPos ) ;

line_index: 768
bug_before_refactoring: if ( answer == userEnterAnswer ) messageResId = R.string.correct_toast ; else messageResId = R.string.incorrect_toast ; <s> private void checkAnswer ( java.lang.String userEnterAnswer ) { java.lang.String answer = myHiraganaSet [ myCurrentIndex ] . getMyAnswer () ; int messageResId = 0 ; if ( answer == userEnterAnswer ) messageResId = R.string.correct_toast ; else messageResId = R.string.incorrect_toast ; android.widget.Toast . makeText ( this , messageResId , Toast.LENGTH_SHORT ) . show () ; } <s> Bug fixed
bug_after_refactoring: if ( answer == userEnterAnswer ) hugitfxkvulahoquteke = R.string.correct_toast ; else hugitfxkvulahoquteke = R.string.incorrect_toast ; <s> private void checkAnswer ( java.lang.String userEnterAnswer ) { java.lang.String answer = myHiraganaSet [ myCurrentIndex ] . getMyAnswer () ; int messageResId = 0 ; if ( answer == userEnterAnswer ) hugitfxkvulahoquteke = R.string.correct_toast ; else hugitfxkvulahoquteke = R.string.incorrect_toast ; android.widget.Toast . makeText ( this , messageResId , Toast.LENGTH_SHORT ) . show () ; } <s> Bug fixed
fix_before_refactoring: if ( answer . equals ( userEnterAnswer ) ) messageResId = R.string.correct_toast ; else messageResId = R.string.incorrect_toast ;
fix_after_refactoring: if ( answer . equals ( userEnterAnswer ) ) hugitfxkvulahoquteke = R.string.correct_toast ; else hugitfxkvulahoquteke = R.string.incorrect_toast ;
√ fix_prediction_before: if ( answer . equals ( userEnterAnswer ) ) messageResId = R.string.correct_toast ; else messageResId = R.string.incorrect_toast ;
√ fix_prediction_after: if ( answer . equals ( userEnterAnswer ) ) hugitfxkvulahoquteke = R.string.correct_toast ; else hugitfxkvulahoquteke = R.string.incorrect_toast ;

line_index: 780
bug_before_refactoring: isChecked ? childPositions . add ( packedPosition ) : childPositions . remove ( packedPosition ) <s> public boolean putChild ( int groupPosition , int childPosition , long childId , boolean isChecked ) { long packedPosition = android.widget.ExpandableListView . getPackedPositionForChild ( groupPosition , childPosition ) ; if ( hasStableIds () ) { java.lang.Long result = ( isChecked ) ? childIds . put ( childId , packedPosition ) : childIds . remove ( childId ) ; return result != null ; } else { return isChecked ? childPositions . add ( packedPosition ) : childPositions . remove ( packedPosition ) ; } } <s> Ref #38 - Fixed small logic error whereby checking an item when stableIds were disabled didn't always highlight the item row.
bug_after_refactoring: isChecked ? childPositions . add ( xefvqnoyjncdzgbbtruu ) : childPositions . remove ( xefvqnoyjncdzgbbtruu ) <s> public boolean putChild ( int groupPosition , int childPosition , long childId , boolean isChecked ) { long packedPosition = android.widget.ExpandableListView . getPackedPositionForChild ( groupPosition , childPosition ) ; if ( hasStableIds () ) { java.lang.Long result = ( isChecked ) ? childIds . put ( childId , packedPosition ) : childIds . remove ( childId ) ; return result != null ; } else { return isChecked ? childPositions . add ( xefvqnoyjncdzgbbtruu ) : childPositions . remove ( xefvqnoyjncdzgbbtruu ) ; } } <s> Ref #38 - Fixed small logic error whereby checking an item when stableIds were disabled didn't always highlight the item row.
fix_before_refactoring: isChecked ? ! ( childPositions . add ( packedPosition ) ) : childPositions . remove ( packedPosition )
fix_after_refactoring: isChecked ? ! ( childPositions . add ( xefvqnoyjncdzgbbtruu ) ) : childPositions . remove ( xefvqnoyjncdzgbbtruu )
√ fix_prediction_before: isChecked ? ! ( childPositions . add ( packedPosition ) ) : childPositions . remove ( packedPosition )
√ fix_prediction_after: isChecked ? ! ( childPositions . add ( xefvqnoyjncdzgbbtruu ) ) : childPositions . remove ( xefvqnoyjncdzgbbtruu )

line_index: 782
bug_before_refactoring: { int month = dateTimeUnit . getMonth () ; if ( dateTimeUnit . isIso8601 () ) { month = calendar . fromIso ( dateTimeUnit ) . getMonth () ; } switch ( month ) { case 11 : return ( dateTimeUnit . getYear () ) + "NovS1" ; case 5 : return ( dateTimeUnit . getYear () ) + "NovS2" ; default: throw new java.lang.IllegalArgumentException ( ( "Month not valid [11,5] " + month ) ) ; } } <s> @ java.lang.Override public java.lang.String getIsoDate ( org.hisp.dhis.calendar.DateTimeUnit dateTimeUnit , org.hisp.dhis.calendar.Calendar calendar ) { int month = dateTimeUnit . getMonth () ; if ( dateTimeUnit . isIso8601 () ) { month = calendar . fromIso ( dateTimeUnit ) . getMonth () ; } switch ( month ) { case 11 : return ( dateTimeUnit . getYear () ) + "NovS1" ; case 5 : return ( dateTimeUnit . getYear () ) + "NovS2" ; default: throw new java.lang.IllegalArgumentException ( ( "Month not valid [11,5] " + month ) ) ; } } <s> bug fix SixMonthlyNovember period
bug_after_refactoring: { int gylloasajxlnkinvvfwd = dateTimeUnit . getMonth () ; if ( dateTimeUnit . isIso8601 () ) { gylloasajxlnkinvvfwd = calendar . fromIso ( dateTimeUnit ) . getMonth () ; } switch ( gylloasajxlnkinvvfwd ) { case 11 : return ( dateTimeUnit . getYear () ) + "NovS1" ; case 5 : return ( dateTimeUnit . getYear () ) + "NovS2" ; default: throw new java.lang.IllegalArgumentException ( ( "Month not valid [11,5] " + gylloasajxlnkinvvfwd ) ) ; } } <s> @ java.lang.Override public java.lang.String getIsoDate ( org.hisp.dhis.calendar.DateTimeUnit dateTimeUnit , org.hisp.dhis.calendar.Calendar calendar ) { int gylloasajxlnkinvvfwd = dateTimeUnit . getMonth () ; if ( dateTimeUnit . isIso8601 () ) { gylloasajxlnkinvvfwd = calendar . fromIso ( dateTimeUnit ) . getMonth () ; } switch ( gylloasajxlnkinvvfwd ) { case 11 : return ( dateTimeUnit . getYear () ) + "NovS1" ; case 5 : return ( dateTimeUnit . getYear () ) + "NovS2" ; default: throw new java.lang.IllegalArgumentException ( ( "Month not valid [11,5] " + gylloasajxlnkinvvfwd ) ) ; } } <s> bug fix SixMonthlyNovember period
fix_before_refactoring: { int month = dateTimeUnit . getMonth () ; switch ( month ) { case 11 : return ( dateTimeUnit . getYear () ) + "NovS1" ; case 5 : return ( dateTimeUnit . getYear () ) + "NovS2" ; default: throw new java.lang.IllegalArgumentException ( ( "Month not valid [11,5] " + month ) ) ; } }
fix_after_refactoring: { int gylloasajxlnkinvvfwd = dateTimeUnit . getMonth () ; switch ( gylloasajxlnkinvvfwd ) { case 11 : return ( dateTimeUnit . getYear () ) + "NovS1" ; case 5 : return ( dateTimeUnit . getYear () ) + "NovS2" ; default: throw new java.lang.IllegalArgumentException ( ( "Month not valid [11,5] " + gylloasajxlnkinvvfwd ) ) ; } }
√ fix_prediction_before: { int month = dateTimeUnit . getMonth () ; switch ( month ) { case 11 : return ( dateTimeUnit . getYear () ) + "NovS1" ; case 5 : return ( dateTimeUnit . getYear () ) + "NovS2" ; default: throw new java.lang.IllegalArgumentException ( ( "Month not valid [11,5] " + month ) ) ; } }
√ fix_prediction_after: { int gylloasajxlnkinvvfwd = dateTimeUnit . getMonth () ; switch ( gylloasajxlnkinvvfwd ) { case 11 : return ( dateTimeUnit . getYear () ) + "NovS1" ; case 5 : return ( dateTimeUnit . getYear () ) + "NovS2" ; default: throw new java.lang.IllegalArgumentException ( ( "Month not valid [11,5] " + gylloasajxlnkinvvfwd ) ) ; } }

line_index: 787
bug_before_refactoring: { int py = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { py -= 110 ; py /= 50 ; } else { py -= 15 + 50 ; py /= 50 ; } java.lang.System.out . println ( py ) ; return py ; } <s> public int extractY ( int y ) { int py = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { py -= 110 ; py /= 50 ; } else { py -= 15 + 50 ; py /= 50 ; } java.lang.System.out . println ( py ) ; return py ; } <s> Fixed a bug; Code cleanup
bug_after_refactoring: { int pmeplteizahfgiswuedb = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { pmeplteizahfgiswuedb -= 110 ; pmeplteizahfgiswuedb /= 50 ; } else { pmeplteizahfgiswuedb -= 15 + 50 ; pmeplteizahfgiswuedb /= 50 ; } java.lang.System.out . println ( pmeplteizahfgiswuedb ) ; return pmeplteizahfgiswuedb ; } <s> public int extractY ( int y ) { int pmeplteizahfgiswuedb = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { pmeplteizahfgiswuedb -= 110 ; pmeplteizahfgiswuedb /= 50 ; } else { pmeplteizahfgiswuedb -= 15 + 50 ; pmeplteizahfgiswuedb /= 50 ; } java.lang.System.out . println ( pmeplteizahfgiswuedb ) ; return pmeplteizahfgiswuedb ; } <s> Fixed a bug; Code cleanup
fix_before_refactoring: { int py = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { py -= 110 ; py /= 50 ; } else { py -= 15 + 50 ; py /= 50 ; } return py ; }
fix_after_refactoring: { int pmeplteizahfgiswuedb = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { pmeplteizahfgiswuedb -= 110 ; pmeplteizahfgiswuedb /= 50 ; } else { pmeplteizahfgiswuedb -= 15 + 50 ; pmeplteizahfgiswuedb /= 50 ; } return pmeplteizahfgiswuedb ; }
√ fix_prediction_before: { int py = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { py -= 110 ; py /= 50 ; } else { py -= 15 + 50 ; py /= 50 ; } return py ; }
√ fix_prediction_after: { int pmeplteizahfgiswuedb = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { pmeplteizahfgiswuedb -= 110 ; pmeplteizahfgiswuedb /= 50 ; } else { pmeplteizahfgiswuedb -= 15 + 50 ; pmeplteizahfgiswuedb /= 50 ; } return pmeplteizahfgiswuedb ; }

line_index: 806
bug_before_refactoring: i = 0 <s> @ java.lang.SuppressWarnings ( value = "null" ) public void insertAt ( int item , int pos ) { int i = 0 ; Node newNode = new Node () ; newNode.data = item ; newNode.next = null ; Node temp ; temp = head ; while ( i < ( pos - 1 ) ) { i ++ ; temp = temp.next ; } newNode.next = temp.next ; temp.next = newNode ; } <s> Fixed traversal issue
bug_after_refactoring: szuevymjzddofccxquhz = 0 <s> @ java.lang.SuppressWarnings ( value = "null" ) public void insertAt ( int item , int pos ) { int szuevymjzddofccxquhz = 0 ; Node newNode = new Node () ; newNode.data = item ; newNode.next = null ; Node temp ; temp = head ; while ( i < ( pos - 1 ) ) { i ++ ; temp = temp.next ; } newNode.next = temp.next ; temp.next = newNode ; } <s> Fixed traversal issue
fix_before_refactoring: i = 1
fix_after_refactoring: szuevymjzddofccxquhz = 1
√ fix_prediction_before: i = 1
√ fix_prediction_after: szuevymjzddofccxquhz = 1

line_index: 808
bug_before_refactoring: { int userEdited = 0 ; for ( int i = 0 ; i < ( backup.length ) ; i ++ ) { if ( ( ( backup [ i ] ) != ( Cell.NONE ) ) && ( ! ( mCells [ i ] . isLocked () ) ) ) { backup [ i ] = Cell.NONE ; userEdited ++ ; } } android.util.Log . i ( "SUDOKU" , ( ( "Removed " + userEdited ) + " user edits and restarted the queue" ) ) ; } <s> private void clearUserEdits ( int [] backup ) { int userEdited = 0 ; for ( int i = 0 ; i < ( backup.length ) ; i ++ ) { if ( ( ( backup [ i ] ) != ( Cell.NONE ) ) && ( ! ( mCells [ i ] . isLocked () ) ) ) { backup [ i ] = Cell.NONE ; userEdited ++ ; } } android.util.Log . i ( "SUDOKU" , ( ( "Removed " + userEdited ) + " user edits and restarted the queue" ) ) ; } <s> fixed bug with crashing  while cancelling a solveThread
bug_after_refactoring: { int bwugjvppxbzszkzohwpj = 0 ; for ( int i = 0 ; i < ( backup.length ) ; i ++ ) { if ( ( ( backup [ i ] ) != ( Cell.NONE ) ) && ( ! ( mCells [ i ] . isLocked () ) ) ) { backup [ i ] = Cell.NONE ; bwugjvppxbzszkzohwpj ++ ; } } android.util.Log . i ( "SUDOKU" , ( ( "Removed " + bwugjvppxbzszkzohwpj ) + " user edits and restarted the queue" ) ) ; } <s> private void clearUserEdits ( int [] backup ) { int bwugjvppxbzszkzohwpj = 0 ; for ( int i = 0 ; i < ( backup.length ) ; i ++ ) { if ( ( ( backup [ i ] ) != ( Cell.NONE ) ) && ( ! ( mCells [ i ] . isLocked () ) ) ) { backup [ i ] = Cell.NONE ; bwugjvppxbzszkzohwpj ++ ; } } android.util.Log . i ( "SUDOKU" , ( ( "Removed " + bwugjvppxbzszkzohwpj ) + " user edits and restarted the queue" ) ) ; } <s> fixed bug with crashing  while cancelling a solveThread
fix_before_refactoring: { int userEdited = 0 ; for ( int i = 0 ; i < ( backup.length ) ; i ++ ) { if ( ( ( backup [ i ] ) != ( Cell.NONE ) ) && ( ! ( mCells [ i ] . isLocked () ) ) ) { backup [ i ] = Cell.NONE ; userEdited ++ ; } } }
fix_after_refactoring: { int bwugjvppxbzszkzohwpj = 0 ; for ( int i = 0 ; i < ( backup.length ) ; i ++ ) { if ( ( ( backup [ i ] ) != ( Cell.NONE ) ) && ( ! ( mCells [ i ] . isLocked () ) ) ) { backup [ i ] = Cell.NONE ; bwugjvppxbzszkzohwpj ++ ; } } }
√ fix_prediction_before: { int userEdited = 0 ; for ( int i = 0 ; i < ( backup.length ) ; i ++ ) { if ( ( ( backup [ i ] ) != ( Cell.NONE ) ) && ( ! ( mCells [ i ] . isLocked () ) ) ) { backup [ i ] = Cell.NONE ; userEdited ++ ; } } }
√ fix_prediction_after: { int bwugjvppxbzszkzohwpj = 0 ; for ( int i = 0 ; i < ( backup.length ) ; i ++ ) { if ( ( ( backup [ i ] ) != ( Cell.NONE ) ) && ( ! ( mCells [ i ] . isLocked () ) ) ) { backup [ i ] = Cell.NONE ; bwugjvppxbzszkzohwpj ++ ; } } }

line_index: 818
bug_before_refactoring: if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; } <s> @ java.lang.Override public boolean apply ( @ javax.annotation.Nullable com.gmi.nordborglab.browser.shared.proxy.TraitProxy input ) { if ( input == null ) return true ; boolean isNotFound = true ; for ( com.gmi.nordborglab.browser.shared.proxy.AlleleAssayProxy alleleAssay : input . getObsUnit () . getStock () . getPassport () . getAlleleAssays () ) { if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; } } return isNotFound ; } <s> Fix some bugs regarding the iterator and out of bounds errors
bug_after_refactoring: if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; } <s> @ java.lang.Override public boolean apply ( @ javax.annotation.Nullable com.gmi.nordborglab.browser.shared.proxy.TraitProxy input ) { if ( input == null ) return true ; boolean isNotFound = true ; for ( com.gmi.nordborglab.browser.shared.proxy.AlleleAssayProxy alleleAssay : input . getObsUnit () . getStock () . getPassport () . getAlleleAssays () ) { if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; } } return isNotFound ; } <s> Fix some bugs regarding the iterator and out of bounds errors
fix_before_refactoring: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; }
fix_after_refactoring: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; }
√ fix_prediction_before: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; }
√ fix_prediction_after: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; }

line_index: 833
bug_before_refactoring: ( asciiCount [ i ] ) > 0 <s> public boolean isEveryCharacterUniqueUsingHistogram () { int [] asciiCount = new int [ 128 ] ; for ( int i = 0 ; i < ( string . length () ) ; i ++ ) { ( asciiCount [ string . charAt ( i ) ] ) ++ ; } for ( int i = 0 ; i < ( asciiCount.length ) ; i ++ ) { if ( ( asciiCount [ i ] ) > 0 ) { return false ; } } return true ; } <s> Fixing a bug
bug_after_refactoring: ( usujkxeuwmyegwqnjhrs [ i ] ) > 0 <s> public boolean isEveryCharacterUniqueUsingHistogram () { int [] asciiCount = new int [ 128 ] ; for ( int i = 0 ; i < ( string . length () ) ; i ++ ) { ( asciiCount [ string . charAt ( i ) ] ) ++ ; } for ( int i = 0 ; i < ( asciiCount.length ) ; i ++ ) { if ( ( usujkxeuwmyegwqnjhrs [ i ] ) > 0 ) { return false ; } } return true ; } <s> Fixing a bug
fix_before_refactoring: ( asciiCount [ i ] ) > 1
fix_after_refactoring: ( usujkxeuwmyegwqnjhrs [ i ] ) > 1
√ fix_prediction_before: ( asciiCount [ i ] ) > 1
√ fix_prediction_after: ( usujkxeuwmyegwqnjhrs [ i ] ) > 1

line_index: 858
bug_before_refactoring: { if ( notebook == null ) { throw new java.lang.IllegalArgumentException ( "Passing NULL NOTEBOOK, imbecile" ) ; } long id = db . getWritableDatabase () . insert ( DBConstants.TABLE_NOTEBOOK , null , this . getContentValues ( notebook ) ) ; notebook . setId ( id ) ; db . close () ; db = null ; return id ; } <s> public long insert ( io.keepcoding.rgs.everpobre.model.Notebook notebook ) { if ( notebook == null ) { throw new java.lang.IllegalArgumentException ( "Passing NULL NOTEBOOK, imbecile" ) ; } long id = db . getWritableDatabase () . insert ( DBConstants.TABLE_NOTEBOOK , null , this . getContentValues ( notebook ) ) ; notebook . setId ( id ) ; db . close () ; db = null ; return id ; } <s> Bug-fixed Front end created notebook height
bug_after_refactoring: { if ( notebook == null ) { throw new java.lang.IllegalArgumentException ( "Passing NULL NOTEBOOK, imbecile" ) ; } long teuuewgrorhwturcxgpb = db . getWritableDatabase () . insert ( DBConstants.TABLE_NOTEBOOK , null , this . getContentValues ( notebook ) ) ; notebook . setId ( teuuewgrorhwturcxgpb ) ; db . close () ; db = null ; return teuuewgrorhwturcxgpb ; } <s> public long insert ( io.keepcoding.rgs.everpobre.model.Notebook notebook ) { if ( notebook == null ) { throw new java.lang.IllegalArgumentException ( "Passing NULL NOTEBOOK, imbecile" ) ; } long teuuewgrorhwturcxgpb = db . getWritableDatabase () . insert ( DBConstants.TABLE_NOTEBOOK , null , this . getContentValues ( notebook ) ) ; notebook . setId ( teuuewgrorhwturcxgpb ) ; db . close () ; db = null ; return teuuewgrorhwturcxgpb ; } <s> Bug-fixed Front end created notebook height
fix_before_refactoring: { if ( notebook == null ) { throw new java.lang.IllegalArgumentException ( "Passing NULL NOTEBOOK, imbecile" ) ; } long id = db . getWritableDatabase () . insert ( DBConstants.TABLE_NOTEBOOK , null , this . getContentValues ( notebook ) ) ; notebook . setId ( id ) ; db . close () ; return id ; }
fix_after_refactoring: { if ( notebook == null ) { throw new java.lang.IllegalArgumentException ( "Passing NULL NOTEBOOK, imbecile" ) ; } long teuuewgrorhwturcxgpb = db . getWritableDatabase () . insert ( DBConstants.TABLE_NOTEBOOK , null , this . getContentValues ( notebook ) ) ; notebook . setId ( teuuewgrorhwturcxgpb ) ; db . close () ; return teuuewgrorhwturcxgpb ; }
√ fix_prediction_before: { if ( notebook == null ) { throw new java.lang.IllegalArgumentException ( "Passing NULL NOTEBOOK, imbecile" ) ; } long id = db . getWritableDatabase () . insert ( DBConstants.TABLE_NOTEBOOK , null , this . getContentValues ( notebook ) ) ; notebook . setId ( id ) ; db . close () ; return id ; }
√ fix_prediction_after: { if ( notebook == null ) { throw new java.lang.IllegalArgumentException ( "Passing NULL NOTEBOOK, imbecile" ) ; } long teuuewgrorhwturcxgpb = db . getWritableDatabase () . insert ( DBConstants.TABLE_NOTEBOOK , null , this . getContentValues ( notebook ) ) ; notebook . setId ( teuuewgrorhwturcxgpb ) ; db . close () ; return teuuewgrorhwturcxgpb ; }

line_index: 873
bug_before_refactoring: public int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int playerRowCount = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { playerRowCount ++ ; } } return playerRowCount ; } <s> public int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int playerRowCount = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { playerRowCount ++ ; } } return playerRowCount ; } <s> Merge pull request #27 from k1s/master  Fixed errors and added some features according 5th module
bug_after_refactoring: public int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int jucjkrfmpojebsgileft = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { jucjkrfmpojebsgileft ++ ; } } return jucjkrfmpojebsgileft ; } <s> public int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int jucjkrfmpojebsgileft = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { jucjkrfmpojebsgileft ++ ; } } return jucjkrfmpojebsgileft ; } <s> Merge pull request #27 from k1s/master  Fixed errors and added some features according 5th module
fix_before_refactoring: private int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int playerRowCount = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { playerRowCount ++ ; } } return playerRowCount ; }
fix_after_refactoring: private int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int jucjkrfmpojebsgileft = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { jucjkrfmpojebsgileft ++ ; } } return jucjkrfmpojebsgileft ; }
√ fix_prediction_before: private int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int playerRowCount = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { playerRowCount ++ ; } } return playerRowCount ; }
√ fix_prediction_after: private int getPlayerForLine ( final int row , final java.lang.String playerFigure ) { int jucjkrfmpojebsgileft = 0 ; for ( int i = 0 ; i < ( board . getRowLength ( row ) ) ; i ++ ) { if ( ( ( board . getFigure ( row , i ) ) != null ) && ( ( board . getFigure ( row , i ) . toString () ) == playerFigure ) ) { jucjkrfmpojebsgileft ++ ; } } return jucjkrfmpojebsgileft ; }

