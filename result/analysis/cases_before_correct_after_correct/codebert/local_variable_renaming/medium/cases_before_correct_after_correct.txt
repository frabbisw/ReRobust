line_index: 18
bug_before_refactoring: { java.lang.String nombreVar = ctx . getChild ( 0 ) . getText () ; int locationSave = java.lang.Integer . parseInt ( ctx . getChild ( 2 ) . getText () ) ; java.lang.System.out . println ( ( "ArrayVariable called " + ( ctx . getText () ) ) ) ; java.util.ArrayList returnArray = new java.util.ArrayList () ; returnArray . add ( nombreVar ) ; returnArray . add ( locationSave ) ; return returnArray ; } <s> @ java.lang.Override public java.lang.Object visitArrayVariable ( DECAF2.DECAF2Parser.ArrayVariableContext ctx ) { java.lang.String nombreVar = ctx . getChild ( 0 ) . getText () ; int locationSave = java.lang.Integer . parseInt ( ctx . getChild ( 2 ) . getText () ) ; java.lang.System.out . println ( ( "ArrayVariable called " + ( ctx . getText () ) ) ) ; java.util.ArrayList returnArray = new java.util.ArrayList () ; returnArray . add ( nombreVar ) ; returnArray . add ( locationSave ) ; return returnArray ; } <s> Fix: pequeños errores en generación de tablas
bug_after_refactoring: { java.lang.String nombreVar = ctx . getChild ( 0 ) . getText () ; int mvvfhfjdcvinpflqnzdn = java.lang.Integer . parseInt ( ctx . getChild ( 2 ) . getText () ) ; java.lang.System.out . println ( ( "ArrayVariable called " + ( ctx . getText () ) ) ) ; java.util.ArrayList returnArray = new java.util.ArrayList () ; returnArray . add ( nombreVar ) ; returnArray . add ( mvvfhfjdcvinpflqnzdn ) ; return returnArray ; } <s> @ java.lang.Override public java.lang.Object visitArrayVariable ( DECAF2.DECAF2Parser.ArrayVariableContext ctx ) { java.lang.String nombreVar = ctx . getChild ( 0 ) . getText () ; int mvvfhfjdcvinpflqnzdn = java.lang.Integer . parseInt ( ctx . getChild ( 2 ) . getText () ) ; java.lang.System.out . println ( ( "ArrayVariable called " + ( ctx . getText () ) ) ) ; java.util.ArrayList returnArray = new java.util.ArrayList () ; returnArray . add ( nombreVar ) ; returnArray . add ( mvvfhfjdcvinpflqnzdn ) ; return returnArray ; } <s> Fix: pequeños errores en generación de tablas
fix_before_refactoring: { java.lang.String nombreVar = ctx . getChild ( 0 ) . getText () ; int locationSave = java.lang.Integer . parseInt ( ctx . getChild ( 2 ) . getText () ) ; java.util.ArrayList returnArray = new java.util.ArrayList () ; returnArray . add ( nombreVar ) ; returnArray . add ( locationSave ) ; return returnArray ; }
fix_after_refactoring: { java.lang.String nombreVar = ctx . getChild ( 0 ) . getText () ; int mvvfhfjdcvinpflqnzdn = java.lang.Integer . parseInt ( ctx . getChild ( 2 ) . getText () ) ; java.util.ArrayList returnArray = new java.util.ArrayList () ; returnArray . add ( nombreVar ) ; returnArray . add ( mvvfhfjdcvinpflqnzdn ) ; return returnArray ; }
√ fix_prediction_before: { java.lang.String nombreVar = ctx . getChild ( 0 ) . getText () ; int locationSave = java.lang.Integer . parseInt ( ctx . getChild ( 2 ) . getText () ) ; java.util.ArrayList returnArray = new java.util.ArrayList () ; returnArray . add ( nombreVar ) ; returnArray . add ( locationSave ) ; return returnArray ; }
√ fix_prediction_after: { java.lang.String nombreVar = ctx . getChild ( 0 ) . getText () ; int mvvfhfjdcvinpflqnzdn = java.lang.Integer . parseInt ( ctx . getChild ( 2 ) . getText () ) ; java.util.ArrayList returnArray = new java.util.ArrayList () ; returnArray . add ( nombreVar ) ; returnArray . add ( mvvfhfjdcvinpflqnzdn ) ; return returnArray ; }

line_index: 62
bug_before_refactoring: { final int MIN_OPPONENTS = 1 ; final int MAX_OPPONENTS = 1 ; android.os.Bundle autoMatchCriteria = com.google.android.gms.games.multiplayer.realtime.RoomConfig . createAutoMatchCriteria ( MIN_OPPONENTS , MAX_OPPONENTS , 0 ) ; com.google.android.gms.games.multiplayer.realtime.RoomConfig.Builder rtmConfigBuilder = com.google.android.gms.games.multiplayer.realtime.RoomConfig . builder ( this ) ; rtmConfigBuilder . setMessageReceivedListener ( this ) ; rtmConfigBuilder . setRoomStatusUpdateListener ( this ) ; rtmConfigBuilder . setAutoMatchCriteria ( autoMatchCriteria ) ; switchToScreen ( R.id.screen_wait ) ; keepScreenOn () ; resetGameVars () ; Games.RealTimeMultiplayer . create ( mGoogleApiClient , rtmConfigBuilder . build () ) ; } <s> private void startQuickGame () { final int MIN_OPPONENTS = 1 ; final int MAX_OPPONENTS = 1 ; android.os.Bundle autoMatchCriteria = com.google.android.gms.games.multiplayer.realtime.RoomConfig . createAutoMatchCriteria ( MIN_OPPONENTS , MAX_OPPONENTS , 0 ) ; com.google.android.gms.games.multiplayer.realtime.RoomConfig.Builder rtmConfigBuilder = com.google.android.gms.games.multiplayer.realtime.RoomConfig . builder ( this ) ; rtmConfigBuilder . setMessageReceivedListener ( this ) ; rtmConfigBuilder . setRoomStatusUpdateListener ( this ) ; rtmConfigBuilder . setAutoMatchCriteria ( autoMatchCriteria ) ; switchToScreen ( R.id.screen_wait ) ; keepScreenOn () ; resetGameVars () ; Games.RealTimeMultiplayer . create ( mGoogleApiClient , rtmConfigBuilder . build () ) ; } <s> Fixed player count bugs  added scoreboard (in-game and winner)  changed in-game UI  added end-game functionality (exiting etc..)  added chat for lobby  in-game and end-game
bug_after_refactoring: { final int eyvprkipnyfuzqbdyypt = 1 ; final int xypranatcazmehbcxqjv = 1 ; android.os.Bundle autoMatchCriteria = com.google.android.gms.games.multiplayer.realtime.RoomConfig . createAutoMatchCriteria ( eyvprkipnyfuzqbdyypt , xypranatcazmehbcxqjv , 0 ) ; com.google.android.gms.games.multiplayer.realtime.RoomConfig.Builder rtmConfigBuilder = com.google.android.gms.games.multiplayer.realtime.RoomConfig . builder ( this ) ; rtmConfigBuilder . setMessageReceivedListener ( this ) ; rtmConfigBuilder . setRoomStatusUpdateListener ( this ) ; rtmConfigBuilder . setAutoMatchCriteria ( autoMatchCriteria ) ; switchToScreen ( R.id.screen_wait ) ; keepScreenOn () ; resetGameVars () ; Games.RealTimeMultiplayer . create ( mGoogleApiClient , rtmConfigBuilder . build () ) ; } <s> private void startQuickGame () { final int eyvprkipnyfuzqbdyypt = 1 ; final int xypranatcazmehbcxqjv = 1 ; android.os.Bundle autoMatchCriteria = com.google.android.gms.games.multiplayer.realtime.RoomConfig . createAutoMatchCriteria ( eyvprkipnyfuzqbdyypt , xypranatcazmehbcxqjv , 0 ) ; com.google.android.gms.games.multiplayer.realtime.RoomConfig.Builder rtmConfigBuilder = com.google.android.gms.games.multiplayer.realtime.RoomConfig . builder ( this ) ; rtmConfigBuilder . setMessageReceivedListener ( this ) ; rtmConfigBuilder . setRoomStatusUpdateListener ( this ) ; rtmConfigBuilder . setAutoMatchCriteria ( autoMatchCriteria ) ; switchToScreen ( R.id.screen_wait ) ; keepScreenOn () ; resetGameVars () ; Games.RealTimeMultiplayer . create ( mGoogleApiClient , rtmConfigBuilder . build () ) ; } <s> Fixed player count bugs  added scoreboard (in-game and winner)  changed in-game UI  added end-game functionality (exiting etc..)  added chat for lobby  in-game and end-game
fix_before_refactoring: { final int MIN_OPPONENTS = 1 ; final int MAX_OPPONENTS = 1 ; android.os.Bundle autoMatchCriteria = com.google.android.gms.games.multiplayer.realtime.RoomConfig . createAutoMatchCriteria ( MIN_OPPONENTS , MAX_OPPONENTS , 0 ) ; com.google.android.gms.games.multiplayer.realtime.RoomConfig.Builder rtmConfigBuilder = com.google.android.gms.games.multiplayer.realtime.RoomConfig . builder ( this ) ; rtmConfigBuilder . setMessageReceivedListener ( this ) ; rtmConfigBuilder . setRoomStatusUpdateListener ( this ) ; rtmConfigBuilder . setAutoMatchCriteria ( autoMatchCriteria ) ; switchToScreen ( R.id.screen_wait ) ; keepScreenOn () ; Games.RealTimeMultiplayer . create ( mGoogleApiClient , rtmConfigBuilder . build () ) ; }
fix_after_refactoring: { final int eyvprkipnyfuzqbdyypt = 1 ; final int xypranatcazmehbcxqjv = 1 ; android.os.Bundle autoMatchCriteria = com.google.android.gms.games.multiplayer.realtime.RoomConfig . createAutoMatchCriteria ( eyvprkipnyfuzqbdyypt , xypranatcazmehbcxqjv , 0 ) ; com.google.android.gms.games.multiplayer.realtime.RoomConfig.Builder rtmConfigBuilder = com.google.android.gms.games.multiplayer.realtime.RoomConfig . builder ( this ) ; rtmConfigBuilder . setMessageReceivedListener ( this ) ; rtmConfigBuilder . setRoomStatusUpdateListener ( this ) ; rtmConfigBuilder . setAutoMatchCriteria ( autoMatchCriteria ) ; switchToScreen ( R.id.screen_wait ) ; keepScreenOn () ; Games.RealTimeMultiplayer . create ( mGoogleApiClient , rtmConfigBuilder . build () ) ; }
√ fix_prediction_before: { final int MIN_OPPONENTS = 1 ; final int MAX_OPPONENTS = 1 ; android.os.Bundle autoMatchCriteria = com.google.android.gms.games.multiplayer.realtime.RoomConfig . createAutoMatchCriteria ( MIN_OPPONENTS , MAX_OPPONENTS , 0 ) ; com.google.android.gms.games.multiplayer.realtime.RoomConfig.Builder rtmConfigBuilder = com.google.android.gms.games.multiplayer.realtime.RoomConfig . builder ( this ) ; rtmConfigBuilder . setMessageReceivedListener ( this ) ; rtmConfigBuilder . setRoomStatusUpdateListener ( this ) ; rtmConfigBuilder . setAutoMatchCriteria ( autoMatchCriteria ) ; switchToScreen ( R.id.screen_wait ) ; keepScreenOn () ; Games.RealTimeMultiplayer . create ( mGoogleApiClient , rtmConfigBuilder . build () ) ; }
√ fix_prediction_after: { final int eyvprkipnyfuzqbdyypt = 1 ; final int xypranatcazmehbcxqjv = 1 ; android.os.Bundle autoMatchCriteria = com.google.android.gms.games.multiplayer.realtime.RoomConfig . createAutoMatchCriteria ( eyvprkipnyfuzqbdyypt , xypranatcazmehbcxqjv , 0 ) ; com.google.android.gms.games.multiplayer.realtime.RoomConfig.Builder rtmConfigBuilder = com.google.android.gms.games.multiplayer.realtime.RoomConfig . builder ( this ) ; rtmConfigBuilder . setMessageReceivedListener ( this ) ; rtmConfigBuilder . setRoomStatusUpdateListener ( this ) ; rtmConfigBuilder . setAutoMatchCriteria ( autoMatchCriteria ) ; switchToScreen ( R.id.screen_wait ) ; keepScreenOn () ; Games.RealTimeMultiplayer . create ( mGoogleApiClient , rtmConfigBuilder . build () ) ; }

line_index: 66
bug_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) <s> public int pull_chunk ( byte [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
bug_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , bborcwcykviuccnipdff ) <s> public int pull_chunk ( byte [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , bborcwcykviuccnipdff ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
fix_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
fix_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , bborcwcykviuccnipdff )
√ fix_prediction_before: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
√ fix_prediction_after: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_c ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , bborcwcykviuccnipdff )

line_index: 83
bug_before_refactoring: newBits [ bits.length ] <s> public final BinaryNum shiftLeft () { final boolean [] newBits = new boolean [ bits.length ] ; for ( int i = 1 ; i < ( bits.length ) ; i ++ ) { newBits [ ( i - 1 ) ] = bits [ i ] ; } newBits [ bits.length ] = false ; return new BinaryNum ( newBits ) ; } <s> Fixed bugs in BinaryNum
bug_after_refactoring: jqxldvdojwjdzhuwzrde [ bits.length ] <s> public final BinaryNum shiftLeft () { final boolean [] newBits = new boolean [ bits.length ] ; for ( int i = 1 ; i < ( bits.length ) ; i ++ ) { newBits [ ( i - 1 ) ] = bits [ i ] ; } jqxldvdojwjdzhuwzrde [ bits.length ] = false ; return new BinaryNum ( newBits ) ; } <s> Fixed bugs in BinaryNum
fix_before_refactoring: newBits [ ( ( bits.length ) - 1 ) ]
fix_after_refactoring: jqxldvdojwjdzhuwzrde [ ( ( bits.length ) - 1 ) ]
√ fix_prediction_before: newBits [ ( ( bits.length ) - 1 ) ]
√ fix_prediction_after: jqxldvdojwjdzhuwzrde [ ( ( bits.length ) - 1 ) ]

line_index: 84
bug_before_refactoring: { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } } <s> public void testIterFilterLimitOffset () { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } } <s> Fixed compilation error (using SienaFutureProxy instead of SienaFuture)
bug_after_refactoring: { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int ipbcfqoooibbsoxxnwqe = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ ipbcfqoooibbsoxxnwqe ] , PersonIntKey ) ; ipbcfqoooibbsoxxnwqe ++ ; } } <s> public void testIterFilterLimitOffset () { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int ipbcfqoooibbsoxxnwqe = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ ipbcfqoooibbsoxxnwqe ] , PersonIntKey ) ; ipbcfqoooibbsoxxnwqe ++ ; } } <s> Fixed compilation error (using SienaFutureProxy instead of SienaFuture)
fix_before_refactoring: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } }
fix_after_refactoring: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int ipbcfqoooibbsoxxnwqe = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ ipbcfqoooibbsoxxnwqe ] , PersonIntKey ) ; ipbcfqoooibbsoxxnwqe ++ ; } }
√ fix_prediction_before: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } }
√ fix_prediction_after: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 2 , 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_EINSTEIN } ; int ipbcfqoooibbsoxxnwqe = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ ipbcfqoooibbsoxxnwqe ] , PersonIntKey ) ; ipbcfqoooibbsoxxnwqe ++ ; } }

line_index: 96
bug_before_refactoring: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] time = tp . GetInput ( str ) ; java.lang.System.out . println ( time [ 0 ] ) ; java.util.Date date0 = new java.util.Date ( time [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; } <s> public java.lang.String getFormattedDate ( java.lang.String str ) { com.github.TimeParser tp = new com.github.TimeParser () ; long [] time = tp . GetInput ( str ) ; java.lang.System.out . println ( time [ 0 ] ) ; java.util.Date date0 = new java.util.Date ( time [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; } <s> Added comments and fixed the colon bug
bug_after_refactoring: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] ipnwblghnlbzacxwgtxx = tp . GetInput ( str ) ; java.lang.System.out . println ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.util.Date date0 = new java.util.Date ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; } <s> public java.lang.String getFormattedDate ( java.lang.String str ) { com.github.TimeParser tp = new com.github.TimeParser () ; long [] ipnwblghnlbzacxwgtxx = tp . GetInput ( str ) ; java.lang.System.out . println ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.util.Date date0 = new java.util.Date ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; } <s> Added comments and fixed the colon bug
fix_before_refactoring: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] time = tp . GetInput ( str ) ; java.util.Date date0 = new java.util.Date ( time [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; }
fix_after_refactoring: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] ipnwblghnlbzacxwgtxx = tp . GetInput ( str ) ; java.util.Date date0 = new java.util.Date ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; }
√ fix_prediction_before: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] time = tp . GetInput ( str ) ; java.util.Date date0 = new java.util.Date ( time [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; }
√ fix_prediction_after: { com.github.TimeParser tp = new com.github.TimeParser () ; long [] ipnwblghnlbzacxwgtxx = tp . GetInput ( str ) ; java.util.Date date0 = new java.util.Date ( ipnwblghnlbzacxwgtxx [ 0 ] ) ; java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; sdf . setTimeZone ( java.util.TimeZone . getTimeZone ( "GMT-4" ) ) ; java.lang.String formattedDate = sdf . format ( date0 ) ; return formattedDate ; }

line_index: 103
bug_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) <s> public int pull_chunk ( double [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ec ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
bug_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ntlogeadbvdfbsmfwicj ) <s> public int pull_chunk ( double [] data_buffer , double [] timestamp_buffer , double timeout ) throws java.lang.Exception { int [] ec = new int [] { 0 } ; long res = edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , ( ( long ) ( data_buffer.length ) ) , ( ( long ) ( timestamp_buffer.length ) ) , timeout , ntlogeadbvdfbsmfwicj ) ; edu.ucsd.sccn.LSL . check_error ( ec ) ; return ( ( int ) ( res ) ) ; } <s> Updated liblsl-Java to work with current lsl_h.c. Fixed crash bugs with opening streams on Linux.
fix_before_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
fix_after_refactoring: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ntlogeadbvdfbsmfwicj )
√ fix_prediction_before: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ec )
√ fix_prediction_after: edu.ucsd.sccn.LSL.inst . lsl_pull_chunk_d ( obj , data_buffer , timestamp_buffer , data_buffer.length , timestamp_buffer.length , timeout , ntlogeadbvdfbsmfwicj )

line_index: 141
bug_before_refactoring: if ( ( currPitInfoIndex ) >= 0 ) { try { boolean tempValue = pit_auto_high_goal_Button . isChecked () ; if ( ( currTeam . getBoolean ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL ) ) != tempValue ) { currTeam . put ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL , tempValue ) ; if ( ! ( fillingPitInfo ) ) { dbHelper . updatePitInfo ( currTeam ) ; } } } catch ( org.json.JSONException e ) {} } <s> @ java.lang.Override public void onCheckedChanged ( android.widget.CompoundButton buttonView , boolean isChecked ) { if ( ( currPitInfoIndex ) >= 0 ) { try { boolean tempValue = pit_auto_high_goal_Button . isChecked () ; if ( ( currTeam . getBoolean ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL ) ) != tempValue ) { currTeam . put ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL , tempValue ) ; if ( ! ( fillingPitInfo ) ) { dbHelper . updatePitInfo ( currTeam ) ; } } } catch ( org.json.JSONException e ) {} } } <s> Clayton fixed crashing bug with switching tabs. currTeam gets set to null when you come back from another tab  and it wasn't being checked for.
bug_after_refactoring: if ( ( currPitInfoIndex ) >= 0 ) { try { boolean tfermiefuwoywiobvigh = pit_auto_high_goal_Button . isChecked () ; if ( ( currTeam . getBoolean ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL ) ) != tfermiefuwoywiobvigh ) { currTeam . put ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL , tfermiefuwoywiobvigh ) ; if ( ! ( fillingPitInfo ) ) { dbHelper . updatePitInfo ( currTeam ) ; } } } catch ( org.json.JSONException e ) {} } <s> @ java.lang.Override public void onCheckedChanged ( android.widget.CompoundButton buttonView , boolean isChecked ) { if ( ( currPitInfoIndex ) >= 0 ) { try { boolean tfermiefuwoywiobvigh = pit_auto_high_goal_Button . isChecked () ; if ( ( currTeam . getBoolean ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL ) ) != tfermiefuwoywiobvigh ) { currTeam . put ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL , tfermiefuwoywiobvigh ) ; if ( ! ( fillingPitInfo ) ) { dbHelper . updatePitInfo ( currTeam ) ; } } } catch ( org.json.JSONException e ) {} } } <s> Clayton fixed crashing bug with switching tabs. currTeam gets set to null when you come back from another tab  and it wasn't being checked for.
fix_before_refactoring: if ( ( ( currPitInfoIndex ) >= 0 ) && ( ( currTeam ) != null ) ) { try { boolean tempValue = pit_auto_high_goal_Button . isChecked () ; if ( ( currTeam . getBoolean ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL ) ) != tempValue ) { currTeam . put ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL , tempValue ) ; if ( ! ( fillingPitInfo ) ) { dbHelper . updatePitInfo ( currTeam ) ; } } } catch ( org.json.JSONException e ) {} }
fix_after_refactoring: if ( ( ( currPitInfoIndex ) >= 0 ) && ( ( currTeam ) != null ) ) { try { boolean tfermiefuwoywiobvigh = pit_auto_high_goal_Button . isChecked () ; if ( ( currTeam . getBoolean ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL ) ) != tfermiefuwoywiobvigh ) { currTeam . put ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL , tfermiefuwoywiobvigh ) ; if ( ! ( fillingPitInfo ) ) { dbHelper . updatePitInfo ( currTeam ) ; } } } catch ( org.json.JSONException e ) {} }
√ fix_prediction_before: if ( ( ( currPitInfoIndex ) >= 0 ) && ( ( currTeam ) != null ) ) { try { boolean tempValue = pit_auto_high_goal_Button . isChecked () ; if ( ( currTeam . getBoolean ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL ) ) != tempValue ) { currTeam . put ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL , tempValue ) ; if ( ! ( fillingPitInfo ) ) { dbHelper . updatePitInfo ( currTeam ) ; } } } catch ( org.json.JSONException e ) {} }
√ fix_prediction_after: if ( ( ( currPitInfoIndex ) >= 0 ) && ( ( currTeam ) != null ) ) { try { boolean tfermiefuwoywiobvigh = pit_auto_high_goal_Button . isChecked () ; if ( ( currTeam . getBoolean ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL ) ) != tfermiefuwoywiobvigh ) { currTeam . put ( DBContract.TablePitInfo.COLNAME_PIT_AUTO_HIGH_GOAL , tfermiefuwoywiobvigh ) ; if ( ! ( fillingPitInfo ) ) { dbHelper . updatePitInfo ( currTeam ) ; } } } catch ( org.json.JSONException e ) {} }

line_index: 143
bug_before_refactoring: public void placeFoodBlobs () { int counter = 11 ; while ( counter != 0 ) { java.awt.Point [] foodBlob = makeFoodBlob () ; if ( foodBlob != null ) { for ( java.awt.Point p : foodBlob ) { map . getCell ( p ) . setHasFood ( 5 ) ; } counter -- ; } } } <s> public void placeFoodBlobs () { int counter = 11 ; while ( counter != 0 ) { java.awt.Point [] foodBlob = makeFoodBlob () ; if ( foodBlob != null ) { for ( java.awt.Point p : foodBlob ) { map . getCell ( p ) . setHasFood ( 5 ) ; } counter -- ; } } } <s> Update AntMapGenerator.java  Fixed a bug with the anthills not being placed correctly
bug_after_refactoring: public void placeFoodBlobs () { int tjzdazmqoquoigfwrgut = 11 ; while ( tjzdazmqoquoigfwrgut != 0 ) { java.awt.Point [] foodBlob = makeFoodBlob () ; if ( foodBlob != null ) { for ( java.awt.Point p : foodBlob ) { map . getCell ( p ) . setHasFood ( 5 ) ; } tjzdazmqoquoigfwrgut -- ; } } } <s> public void placeFoodBlobs () { int tjzdazmqoquoigfwrgut = 11 ; while ( tjzdazmqoquoigfwrgut != 0 ) { java.awt.Point [] foodBlob = makeFoodBlob () ; if ( foodBlob != null ) { for ( java.awt.Point p : foodBlob ) { map . getCell ( p ) . setHasFood ( 5 ) ; } tjzdazmqoquoigfwrgut -- ; } } } <s> Update AntMapGenerator.java  Fixed a bug with the anthills not being placed correctly
fix_before_refactoring: private void placeFoodBlobs () { int counter = 11 ; while ( counter != 0 ) { java.awt.Point [] foodBlob = makeFoodBlob () ; if ( foodBlob != null ) { for ( java.awt.Point p : foodBlob ) { map . getCell ( p ) . setHasFood ( 5 ) ; } counter -- ; } } }
fix_after_refactoring: private void placeFoodBlobs () { int tjzdazmqoquoigfwrgut = 11 ; while ( tjzdazmqoquoigfwrgut != 0 ) { java.awt.Point [] foodBlob = makeFoodBlob () ; if ( foodBlob != null ) { for ( java.awt.Point p : foodBlob ) { map . getCell ( p ) . setHasFood ( 5 ) ; } tjzdazmqoquoigfwrgut -- ; } } }
√ fix_prediction_before: private void placeFoodBlobs () { int counter = 11 ; while ( counter != 0 ) { java.awt.Point [] foodBlob = makeFoodBlob () ; if ( foodBlob != null ) { for ( java.awt.Point p : foodBlob ) { map . getCell ( p ) . setHasFood ( 5 ) ; } counter -- ; } } }
√ fix_prediction_after: private void placeFoodBlobs () { int tjzdazmqoquoigfwrgut = 11 ; while ( tjzdazmqoquoigfwrgut != 0 ) { java.awt.Point [] foodBlob = makeFoodBlob () ; if ( foodBlob != null ) { for ( java.awt.Point p : foodBlob ) { map . getCell ( p ) . setHasFood ( 5 ) ; } tjzdazmqoquoigfwrgut -- ; } } }

line_index: 156
bug_before_refactoring: { java.lang.System.out . println ( ( ( ( me . getSceneX () ) + ", " ) + ( ( me . getSceneY () ) - 55 ) ) ) ; int x = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int y = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( x , y , image ) ; } } <s> public void handle ( javafx.scene.input.MouseEvent me ) { java.lang.System.out . println ( ( ( ( me . getSceneX () ) + ", " ) + ( ( me . getSceneY () ) - 55 ) ) ) ; int x = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int y = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( x , y , image ) ; } } <s> Fixed board not refreshing when no more moves left in Time trial and click bug further < bug
bug_after_refactoring: { java.lang.System.out . println ( ( ( ( me . getSceneX () ) + ", " ) + ( ( me . getSceneY () ) - 55 ) ) ) ; int vqfadzupjesfrbrapvzk = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int qzogguxohovmhrdomjbw = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( vqfadzupjesfrbrapvzk , qzogguxohovmhrdomjbw , image ) ; } } <s> public void handle ( javafx.scene.input.MouseEvent me ) { java.lang.System.out . println ( ( ( ( me . getSceneX () ) + ", " ) + ( ( me . getSceneY () ) - 55 ) ) ) ; int vqfadzupjesfrbrapvzk = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int qzogguxohovmhrdomjbw = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( vqfadzupjesfrbrapvzk , qzogguxohovmhrdomjbw , image ) ; } } <s> Fixed board not refreshing when no more moves left in Time trial and click bug further < bug
fix_before_refactoring: { int x = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int y = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( x , y , image ) ; } }
fix_after_refactoring: { int vqfadzupjesfrbrapvzk = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int qzogguxohovmhrdomjbw = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( vqfadzupjesfrbrapvzk , qzogguxohovmhrdomjbw , image ) ; } }
√ fix_prediction_before: { int x = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int y = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( x , y , image ) ; } }
√ fix_prediction_after: { int vqfadzupjesfrbrapvzk = ( ( int ) ( me . getSceneX () ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; int qzogguxohovmhrdomjbw = ( ( int ) ( ( me . getSceneY () ) - 55 ) ) / ( main.gui.BoardPane.SPRITE_SIZE ) ; if ( ! ( animating ) ) { clicked ( vqfadzupjesfrbrapvzk , qzogguxohovmhrdomjbw , image ) ; } }

line_index: 169
bug_before_refactoring: static boolean cypher ( com.intellij.lang.PsiBuilder b , int l ) { if ( ! ( com.intellij.lang.parser.GeneratedParserUtilBase . recursion_guard_ ( b , l , "cypher" ) ) ) return false ; int c = com.intellij.lang.parser.GeneratedParserUtilBase . current_position_ ( b ) ; while ( true ) { if ( ! ( com.neueda.jetbrains.plugin.graphdb.language.cypher.parser.CypherParser . StatementItem ( b , ( l + 1 ) ) ) ) break; if ( ! ( com.intellij.lang.parser.GeneratedParserUtilBase . empty_element_parsed_guard_ ( b , "cypher" , c ) ) ) break; c = com.intellij.lang.parser.GeneratedParserUtilBase . current_position_ ( b ) ; } return true ; } <s> static boolean cypher ( com.intellij.lang.PsiBuilder b , int l ) { if ( ! ( com.intellij.lang.parser.GeneratedParserUtilBase . recursion_guard_ ( b , l , "cypher" ) ) ) return false ; int c = com.intellij.lang.parser.GeneratedParserUtilBase . current_position_ ( b ) ; while ( true ) { if ( ! ( com.neueda.jetbrains.plugin.graphdb.language.cypher.parser.CypherParser . StatementItem ( b , ( l + 1 ) ) ) ) break; if ( ! ( com.intellij.lang.parser.GeneratedParserUtilBase . empty_element_parsed_guard_ ( b , "cypher" , c ) ) ) break; c = com.intellij.lang.parser.GeneratedParserUtilBase . current_position_ ( b ) ; } return true ; } <s> Fix case-sensitivity issues
bug_after_refactoring: static boolean cypher ( com.intellij.lang.PsiBuilder b , int l ) { if ( ! ( com.intellij.lang.parser.GeneratedParserUtilBase . recursion_guard_ ( b , l , "cypher" ) ) ) return false ; int nikxywkvufqomcdcmgjr = com.intellij.lang.parser.GeneratedParserUtilBase . current_position_ ( b ) ; while ( true ) { if ( ! ( com.neueda.jetbrains.plugin.graphdb.language.cypher.parser.CypherParser . StatementItem ( b , ( l + 1 ) ) ) ) break; if ( ! ( com.intellij.lang.parser.GeneratedParserUtilBase . empty_element_parsed_guard_ ( b , "cypher" , nikxywkvufqomcdcmgjr ) ) ) break; nikxywkvufqomcdcmgjr = com.intellij.lang.parser.GeneratedParserUtilBase . current_position_ ( b ) ; } return true ; } <s> static boolean cypher ( com.intellij.lang.PsiBuilder b , int l ) { if ( ! ( com.intellij.lang.parser.GeneratedParserUtilBase . recursion_guard_ ( b , l , "cypher" ) ) ) return false ; int nikxywkvufqomcdcmgjr = com.intellij.lang.parser.GeneratedParserUtilBase . current_position_ ( b ) ; while ( true ) { if ( ! ( com.neueda.jetbrains.plugin.graphdb.language.cypher.parser.CypherParser . StatementItem ( b , ( l + 1 ) ) ) ) break; if ( ! ( com.intellij.lang.parser.GeneratedParserUtilBase . empty_element_parsed_guard_ ( b , "cypher" , nikxywkvufqomcdcmgjr ) ) ) break; nikxywkvufqomcdcmgjr = com.intellij.lang.parser.GeneratedParserUtilBase . current_position_ ( b ) ; } return true ; } <s> Fix case-sensitivity issues
fix_before_refactoring: static boolean cypher ( com.intellij.lang.PsiBuilder b , int l ) { if ( ! ( recursion_guard_ ( b , l , "cypher" ) ) ) return false ; int c = current_position_ ( b ) ; while ( true ) { if ( ! ( com.neueda.jetbrains.plugin.graphdb.language.cypher.parser.CypherParser . StatementItem ( b , ( l + 1 ) ) ) ) break; if ( ! ( empty_element_parsed_guard_ ( b , "cypher" , c ) ) ) break; c = current_position_ ( b ) ; } return true ; }
fix_after_refactoring: static boolean cypher ( com.intellij.lang.PsiBuilder b , int l ) { if ( ! ( recursion_guard_ ( b , l , "cypher" ) ) ) return false ; int nikxywkvufqomcdcmgjr = current_position_ ( b ) ; while ( true ) { if ( ! ( com.neueda.jetbrains.plugin.graphdb.language.cypher.parser.CypherParser . StatementItem ( b , ( l + 1 ) ) ) ) break; if ( ! ( empty_element_parsed_guard_ ( b , "cypher" , nikxywkvufqomcdcmgjr ) ) ) break; nikxywkvufqomcdcmgjr = current_position_ ( b ) ; } return true ; }
√ fix_prediction_before: static boolean cypher ( com.intellij.lang.PsiBuilder b , int l ) { if ( ! ( recursion_guard_ ( b , l , "cypher" ) ) ) return false ; int c = current_position_ ( b ) ; while ( true ) { if ( ! ( com.neueda.jetbrains.plugin.graphdb.language.cypher.parser.CypherParser . StatementItem ( b , ( l + 1 ) ) ) ) break; if ( ! ( empty_element_parsed_guard_ ( b , "cypher" , c ) ) ) break; c = current_position_ ( b ) ; } return true ; }
√ fix_prediction_after: static boolean cypher ( com.intellij.lang.PsiBuilder b , int l ) { if ( ! ( recursion_guard_ ( b , l , "cypher" ) ) ) return false ; int nikxywkvufqomcdcmgjr = current_position_ ( b ) ; while ( true ) { if ( ! ( com.neueda.jetbrains.plugin.graphdb.language.cypher.parser.CypherParser . StatementItem ( b , ( l + 1 ) ) ) ) break; if ( ! ( empty_element_parsed_guard_ ( b , "cypher" , nikxywkvufqomcdcmgjr ) ) ) break; nikxywkvufqomcdcmgjr = current_position_ ( b ) ; } return true ; }

line_index: 185
bug_before_refactoring: if ( timeRequirement <= 0 ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, must be positive whole numbers only" ) ; return false ; } <s> private boolean validateTimeRequirement () { util.Util . clearError ( lblTimeRequirementError ) ; if ( txtTimeRequirement . isMessageDefault () ) { return true ; } try { int timeRequirement = java.lang.Integer . parseInt ( txtTimeRequirement . getText () ) ; if ( timeRequirement <= 0 ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, must be positive whole numbers only" ) ; return false ; } } catch ( java.lang.NumberFormatException e ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, whole numbers only" ) ; return false ; } return true ; } <s> fixed small bug
bug_after_refactoring: if ( emvzgfkmruayixpcqgqn <= 0 ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, must be positive whole numbers only" ) ; return false ; } <s> private boolean validateTimeRequirement () { util.Util . clearError ( lblTimeRequirementError ) ; if ( txtTimeRequirement . isMessageDefault () ) { return true ; } try { int timeRequirement = java.lang.Integer . parseInt ( txtTimeRequirement . getText () ) ; if ( emvzgfkmruayixpcqgqn <= 0 ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, must be positive whole numbers only" ) ; return false ; } } catch ( java.lang.NumberFormatException e ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, whole numbers only" ) ; return false ; } return true ; } <s> fixed small bug
fix_before_refactoring: if ( timeRequirement < 0 ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, must be positive whole numbers only" ) ; return false ; }
fix_after_refactoring: if ( emvzgfkmruayixpcqgqn < 0 ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, must be positive whole numbers only" ) ; return false ; }
√ fix_prediction_before: if ( timeRequirement < 0 ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, must be positive whole numbers only" ) ; return false ; }
√ fix_prediction_after: if ( emvzgfkmruayixpcqgqn < 0 ) { util.Util . setError ( lblTimeRequirementError , "Invalid value, must be positive whole numbers only" ) ; return false ; }

line_index: 186
bug_before_refactoring: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( minutes - ( oter . getTime () ) ) ) ; android.util.Log . e ( "Wakeup" , ( ( minutes - ( oter . getTime () ) ) + "" ) ) ; } <s> @ java.lang.Override public void processResults ( org.json.JSONObject result ) { int minutes = getTime ( result ) ; if ( minutes <= ( oter . getTime () ) ) { com.joebruzek.oter.utilities.SmsSender . sendText ( oter ) ; oterLayer . removeOter ( oter ) ; } else { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( minutes - ( oter . getTime () ) ) ) ; android.util.Log . e ( "Wakeup" , ( ( minutes - ( oter . getTime () ) ) + "" ) ) ; } this . stopSelf () ; } <s> Fixed bug with SendOterService wakeup
bug_after_refactoring: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) ) ; android.util.Log . e ( "Wakeup" , ( ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) + "" ) ) ; } <s> @ java.lang.Override public void processResults ( org.json.JSONObject result ) { int minutes = getTime ( result ) ; if ( minutes <= ( oter . getTime () ) ) { com.joebruzek.oter.utilities.SmsSender . sendText ( oter ) ; oterLayer . removeOter ( oter ) ; } else { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) ) ; android.util.Log . e ( "Wakeup" , ( ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) + "" ) ) ; } this . stopSelf () ; } <s> Fixed bug with SendOterService wakeup
fix_before_refactoring: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( minutes - ( oter . getTime () ) ) ) ; }
fix_after_refactoring: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) ) ; }
√ fix_prediction_before: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( minutes - ( oter . getTime () ) ) ) ; }
√ fix_prediction_after: { com.joebruzek.oter.utilities.AlarmScheduler . scheduleWakeUp ( this , oter , ( cwajfsshwsvahhskckmn - ( oter . getTime () ) ) ) ; }

line_index: 206
bug_before_refactoring: expResult = false <s> @ org.junit.Test public void testAtLeastOneNegative4 () { java.lang.System.out . println ( "atLeastOneNegative" ) ; int n1 = 0 ; int n2 = 0 ; int n3 = 0 ; int n4 = - 7 ; boolean expResult = false ; boolean result = second.FirstTasksSet . atLeastOneNegative ( n1 , n2 , n3 , n4 ) ; org.junit.Assert . assertEquals ( expResult , result ) ; } <s> BugFix Test
bug_after_refactoring: gysqfoizxgvfmacgmjgl = false <s> @ org.junit.Test public void testAtLeastOneNegative4 () { java.lang.System.out . println ( "atLeastOneNegative" ) ; int n1 = 0 ; int n2 = 0 ; int n3 = 0 ; int n4 = - 7 ; boolean gysqfoizxgvfmacgmjgl = false ; boolean result = second.FirstTasksSet . atLeastOneNegative ( n1 , n2 , n3 , n4 ) ; org.junit.Assert . assertEquals ( expResult , result ) ; } <s> BugFix Test
fix_before_refactoring: expResult = true
fix_after_refactoring: gysqfoizxgvfmacgmjgl = true
√ fix_prediction_before: expResult = true
√ fix_prediction_after: gysqfoizxgvfmacgmjgl = true

line_index: 207
bug_before_refactoring: minWayId = wayId + 1 <s> public void process ( org.openstreetmap.osmosis.core.container.v0_6.WayContainer wayContainer ) { org.openstreetmap.osmosis.core.domain.v0_6.Way way ; long wayId ; flushNodes ( true ) ; way = wayContainer . getEntity () ; wayId = way . getId () ; if ( wayId >= ( maxWayId ) ) { maxWayId = wayId + 1 ; } if ( wayId < ( minWayId ) ) { minWayId = wayId + 1 ; } wayBuffer . add ( way ) ; flushWays ( false ) ; } <s> apidb: Fix one-off error in current way/relation loading  The previous patch had a minor bug where the minimum way and relation ids being loaded into the current tables were one-off and therefore missing the first id to be loaded.
bug_after_refactoring: minWayId = vnvcnjaylfchzeclfwkq + 1 <s> public void process ( org.openstreetmap.osmosis.core.container.v0_6.WayContainer wayContainer ) { org.openstreetmap.osmosis.core.domain.v0_6.Way way ; long wayId ; flushNodes ( true ) ; way = wayContainer . getEntity () ; wayId = way . getId () ; if ( wayId >= ( maxWayId ) ) { maxWayId = wayId + 1 ; } if ( wayId < ( minWayId ) ) { minWayId = vnvcnjaylfchzeclfwkq + 1 ; } wayBuffer . add ( way ) ; flushWays ( false ) ; } <s> apidb: Fix one-off error in current way/relation loading  The previous patch had a minor bug where the minimum way and relation ids being loaded into the current tables were one-off and therefore missing the first id to be loaded.
fix_before_refactoring: minWayId = wayId
fix_after_refactoring: minWayId = vnvcnjaylfchzeclfwkq
√ fix_prediction_before: minWayId = wayId
√ fix_prediction_after: minWayId = vnvcnjaylfchzeclfwkq

line_index: 222
bug_before_refactoring: { java.lang.System.out . println ( "I'm in it" ) ; getQueryMap . setFirstTimestamp ( timeStamp ) ; java.lang.System.out . println ( ( ( ChannelCode + '\t' ) + timeStamp ) ) ; isFirst = false ; } <s> @ java.lang.Override public void execute ( backtype.storm.tuple.Tuple tuple ) { java.lang.String ChannelCode = tuple . getStringByField ( "channelCode" ) ; long timeStamp = tuple . getLongByField ( "timeStamp" ) ; float value = tuple . getFloatByField ( "value" ) ; if ( channelSet . contains ( ChannelCode ) ) { if ( isFirst ) { java.lang.System.out . println ( "I'm in it" ) ; getQueryMap . setFirstTimestamp ( timeStamp ) ; java.lang.System.out . println ( ( ( ChannelCode + '\t' ) + timeStamp ) ) ; isFirst = false ; } _collector . emit ( new backtype.storm.tuple.Values ( ChannelCode , timeStamp , value ) ) ; } } <s> fix some bugs  pass build  remaining logic errors in SliceManager
bug_after_refactoring: { java.lang.System.out . println ( "I'm in it" ) ; getQueryMap . setFirstTimestamp ( ggpvpsmgwxwulsxsillt ) ; java.lang.System.out . println ( ( ( ChannelCode + '\t' ) + ggpvpsmgwxwulsxsillt ) ) ; isFirst = false ; } <s> @ java.lang.Override public void execute ( backtype.storm.tuple.Tuple tuple ) { java.lang.String ChannelCode = tuple . getStringByField ( "channelCode" ) ; long timeStamp = tuple . getLongByField ( "timeStamp" ) ; float value = tuple . getFloatByField ( "value" ) ; if ( channelSet . contains ( ChannelCode ) ) { if ( isFirst ) { java.lang.System.out . println ( "I'm in it" ) ; getQueryMap . setFirstTimestamp ( ggpvpsmgwxwulsxsillt ) ; java.lang.System.out . println ( ( ( ChannelCode + '\t' ) + ggpvpsmgwxwulsxsillt ) ) ; isFirst = false ; } _collector . emit ( new backtype.storm.tuple.Values ( ChannelCode , timeStamp , value ) ) ; } } <s> fix some bugs  pass build  remaining logic errors in SliceManager
fix_before_refactoring: { getQueryMap . setFirstTimestamp ( timeStamp ) ; isFirst = false ; }
fix_after_refactoring: { getQueryMap . setFirstTimestamp ( ggpvpsmgwxwulsxsillt ) ; isFirst = false ; }
√ fix_prediction_before: { getQueryMap . setFirstTimestamp ( timeStamp ) ; isFirst = false ; }
√ fix_prediction_after: { getQueryMap . setFirstTimestamp ( ggpvpsmgwxwulsxsillt ) ; isFirst = false ; }

line_index: 228
bug_before_refactoring: count = 1 <s> protected int nearMinesCount ( int line , int place ) { int count = 1 ; for ( int [] near : net.patttern.minesweeper.proto.bases.BaseArea.nears ) { count += ( cellMined ( ( line + ( near [ 0 ] ) ) , ( place + ( near [ 1 ] ) ) ) ) ? 1 : 0 ; } return count ; } <s> Bugfix
bug_after_refactoring: fofznveiednztfjbbgwu = 1 <s> protected int nearMinesCount ( int line , int place ) { int fofznveiednztfjbbgwu = 1 ; for ( int [] near : net.patttern.minesweeper.proto.bases.BaseArea.nears ) { count += ( cellMined ( ( line + ( near [ 0 ] ) ) , ( place + ( near [ 1 ] ) ) ) ) ? 1 : 0 ; } return count ; } <s> Bugfix
fix_before_refactoring: count = 0
fix_after_refactoring: fofznveiednztfjbbgwu = 0
√ fix_prediction_before: count = 0
√ fix_prediction_after: fofznveiednztfjbbgwu = 0

line_index: 230
bug_before_refactoring: { this . matchRoute = new com.gogreen.greenmachine.parseobjects.MatchRoute () ; java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > selectedHotspotsList = new java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > ( selectedHotspots ) ; boolean saved = backend . sendRiderRequest ( new com.gogreen.greenmachine.parseobjects.MatchRoute [] { this . matchRoute } , selectedHotspotsList , currentCapacity , driverCar , matchByDate , arriveByDate , destination ) ; android.util.Log . i ( "DrivingHotspotSelect" , ( "createMatchRoute " + ( this . matchRoute . getObjectId () ) ) ) ; return saved ; } <s> private boolean createMatchRoute () { this . matchRoute = new com.gogreen.greenmachine.parseobjects.MatchRoute () ; java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > selectedHotspotsList = new java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > ( selectedHotspots ) ; boolean saved = backend . sendRiderRequest ( new com.gogreen.greenmachine.parseobjects.MatchRoute [] { this . matchRoute } , selectedHotspotsList , currentCapacity , driverCar , matchByDate , arriveByDate , destination ) ; android.util.Log . i ( "DrivingHotspotSelect" , ( "createMatchRoute " + ( this . matchRoute . getObjectId () ) ) ) ; return saved ; } <s> Fixed no rider issue
bug_after_refactoring: { this . matchRoute = new com.gogreen.greenmachine.parseobjects.MatchRoute () ; java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > selectedHotspotsList = new java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > ( selectedHotspots ) ; boolean qxhadvbwsydxyinpcvmq = backend . sendRiderRequest ( new com.gogreen.greenmachine.parseobjects.MatchRoute [] { this . matchRoute } , selectedHotspotsList , currentCapacity , driverCar , matchByDate , arriveByDate , destination ) ; android.util.Log . i ( "DrivingHotspotSelect" , ( "createMatchRoute " + ( this . matchRoute . getObjectId () ) ) ) ; return qxhadvbwsydxyinpcvmq ; } <s> private boolean createMatchRoute () { this . matchRoute = new com.gogreen.greenmachine.parseobjects.MatchRoute () ; java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > selectedHotspotsList = new java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > ( selectedHotspots ) ; boolean qxhadvbwsydxyinpcvmq = backend . sendRiderRequest ( new com.gogreen.greenmachine.parseobjects.MatchRoute [] { this . matchRoute } , selectedHotspotsList , currentCapacity , driverCar , matchByDate , arriveByDate , destination ) ; android.util.Log . i ( "DrivingHotspotSelect" , ( "createMatchRoute " + ( this . matchRoute . getObjectId () ) ) ) ; return qxhadvbwsydxyinpcvmq ; } <s> Fixed no rider issue
fix_before_refactoring: { this . matchRoute = new com.gogreen.greenmachine.parseobjects.MatchRoute () ; java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > selectedHotspotsList = new java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > ( selectedHotspots ) ; boolean saved = backend . sendRiderRequest ( new com.gogreen.greenmachine.parseobjects.MatchRoute [] { this . matchRoute } , selectedHotspotsList , currentCapacity , driverCar , matchByDate , arriveByDate , destination ) ; return saved ; }
fix_after_refactoring: { this . matchRoute = new com.gogreen.greenmachine.parseobjects.MatchRoute () ; java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > selectedHotspotsList = new java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > ( selectedHotspots ) ; boolean qxhadvbwsydxyinpcvmq = backend . sendRiderRequest ( new com.gogreen.greenmachine.parseobjects.MatchRoute [] { this . matchRoute } , selectedHotspotsList , currentCapacity , driverCar , matchByDate , arriveByDate , destination ) ; return qxhadvbwsydxyinpcvmq ; }
√ fix_prediction_before: { this . matchRoute = new com.gogreen.greenmachine.parseobjects.MatchRoute () ; java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > selectedHotspotsList = new java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > ( selectedHotspots ) ; boolean saved = backend . sendRiderRequest ( new com.gogreen.greenmachine.parseobjects.MatchRoute [] { this . matchRoute } , selectedHotspotsList , currentCapacity , driverCar , matchByDate , arriveByDate , destination ) ; return saved ; }
√ fix_prediction_after: { this . matchRoute = new com.gogreen.greenmachine.parseobjects.MatchRoute () ; java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > selectedHotspotsList = new java.util.ArrayList < com.gogreen.greenmachine.parseobjects.Hotspot > ( selectedHotspots ) ; boolean qxhadvbwsydxyinpcvmq = backend . sendRiderRequest ( new com.gogreen.greenmachine.parseobjects.MatchRoute [] { this . matchRoute } , selectedHotspotsList , currentCapacity , driverCar , matchByDate , arriveByDate , destination ) ; return qxhadvbwsydxyinpcvmq ; }

line_index: 295
bug_before_refactoring: public static double noteToFreq ( int key ) { int note = key % ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ; int octave = ( key / ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ) - 1 ; return ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES [ note ] ) * ( java.lang.Math . pow ( 2.0 , ( ( ( double ) ( octave ) ) - 1.0 ) ) ) ; } <s> public static double noteToFreq ( int key ) { int note = key % ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ; int octave = ( key / ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ) - 1 ; return ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES [ note ] ) * ( java.lang.Math . pow ( 2.0 , ( ( ( double ) ( octave ) ) - 1.0 ) ) ) ; } <s> #330 Removed unused code/added comments  Because the MIDI issue is solved  I removed all code not being used (except for MIDIData() method which I moved over to SoundUtilExamples). Also added some clarifying comments and cleaned everything up. close #330
bug_after_refactoring: public static double noteToFreq ( int key ) { int gizrqwfpllxurmejmqoa = key % ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ; int liuzzwuontxwufmxobly = ( key / ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ) - 1 ; return ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES [ gizrqwfpllxurmejmqoa ] ) * ( java.lang.Math . pow ( 2.0 , ( ( ( double ) ( liuzzwuontxwufmxobly ) ) - 1.0 ) ) ) ; } <s> public static double noteToFreq ( int key ) { int gizrqwfpllxurmejmqoa = key % ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ; int liuzzwuontxwufmxobly = ( key / ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ) - 1 ; return ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES [ gizrqwfpllxurmejmqoa ] ) * ( java.lang.Math . pow ( 2.0 , ( ( ( double ) ( liuzzwuontxwufmxobly ) ) - 1.0 ) ) ) ; } <s> #330 Removed unused code/added comments  Because the MIDI issue is solved  I removed all code not being used (except for MIDIData() method which I moved over to SoundUtilExamples). Also added some clarifying comments and cleaned everything up. close #330
fix_before_refactoring: private static double noteToFreq ( int key ) { int note = key % ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ; int octave = ( key / ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ) - 1 ; return ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES [ note ] ) * ( java.lang.Math . pow ( 2.0 , ( ( ( double ) ( octave ) ) - 1.0 ) ) ) ; }
fix_after_refactoring: private static double noteToFreq ( int key ) { int gizrqwfpllxurmejmqoa = key % ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ; int liuzzwuontxwufmxobly = ( key / ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ) - 1 ; return ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES [ gizrqwfpllxurmejmqoa ] ) * ( java.lang.Math . pow ( 2.0 , ( ( ( double ) ( liuzzwuontxwufmxobly ) ) - 1.0 ) ) ) ; }
√ fix_prediction_before: private static double noteToFreq ( int key ) { int note = key % ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ; int octave = ( key / ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ) - 1 ; return ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES [ note ] ) * ( java.lang.Math . pow ( 2.0 , ( ( ( double ) ( octave ) ) - 1.0 ) ) ) ; }
√ fix_prediction_after: private static double noteToFreq ( int key ) { int gizrqwfpllxurmejmqoa = key % ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ; int liuzzwuontxwufmxobly = ( key / ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES_IN_OCTAVE ) ) - 1 ; return ( edu.utexas.cs.nn.util.sound.MIDIUtil.NOTES [ gizrqwfpllxurmejmqoa ] ) * ( java.lang.Math . pow ( 2.0 , ( ( ( double ) ( liuzzwuontxwufmxobly ) ) - 1.0 ) ) ) ; }

line_index: 331
bug_before_refactoring: if ( ( interval >= 1 ) || ( interval <= 2 ) ) { steps += 1 ; } <s> private double getStepMovement ( genetics.MusicPhenotype p ) { double steps = 0 ; double intervalCount = 0 ; for ( java.util.ArrayList < java.lang.Integer > measure : p.melodyIntervals ) { for ( int interval : measure ) { interval = java.lang.Math . abs ( interval ) ; intervalCount ++ ; if ( ( interval >= 1 ) || ( interval <= 2 ) ) { steps += 1 ; } } } if ( intervalCount == 0 ) { return 0 ; } return steps / intervalCount ; } <s> Towsey objective bugfix.
bug_after_refactoring: if ( ( interval >= 1 ) || ( interval <= 2 ) ) { plcsyoeagfxkrofxcwvq += 1 ; } <s> private double getStepMovement ( genetics.MusicPhenotype p ) { double steps = 0 ; double intervalCount = 0 ; for ( java.util.ArrayList < java.lang.Integer > measure : p.melodyIntervals ) { for ( int interval : measure ) { interval = java.lang.Math . abs ( interval ) ; intervalCount ++ ; if ( ( interval >= 1 ) || ( interval <= 2 ) ) { plcsyoeagfxkrofxcwvq += 1 ; } } } if ( intervalCount == 0 ) { return 0 ; } return steps / intervalCount ; } <s> Towsey objective bugfix.
fix_before_refactoring: if ( ( interval >= 1 ) && ( interval <= 2 ) ) { steps += 1 ; }
fix_after_refactoring: if ( ( interval >= 1 ) && ( interval <= 2 ) ) { plcsyoeagfxkrofxcwvq += 1 ; }
√ fix_prediction_before: if ( ( interval >= 1 ) && ( interval <= 2 ) ) { steps += 1 ; }
√ fix_prediction_after: if ( ( interval >= 1 ) && ( interval <= 2 ) ) { plcsyoeagfxkrofxcwvq += 1 ; }

line_index: 336
bug_before_refactoring: { double integralValue = calculateIntegralAtIteration () ; diff = java.lang.Math . abs ( ( integralValue - temp ) ) ; temp = integralValue ; java.lang.System.out . println ( ( "Diff : " + diff ) ) ; } <s> public double calculateIntegral () { double temp = calculateIntegralAtIteration () ; double diff = 0.0 ; do { double integralValue = calculateIntegralAtIteration () ; diff = java.lang.Math . abs ( ( integralValue - temp ) ) ; temp = integralValue ; java.lang.System.out . println ( ( "Diff : " + diff ) ) ; } while ( diff > 1.0E-8 ) ; return temp ; } <s> fixed issue with array reference
bug_after_refactoring: { double vjfhhrwcydkmfpgpsoil = calculateIntegralAtIteration () ; edojivqpxqinjlgeidxs = java.lang.Math . abs ( ( vjfhhrwcydkmfpgpsoil - vklobawupudsvyuyyqvo ) ) ; vklobawupudsvyuyyqvo = vjfhhrwcydkmfpgpsoil ; java.lang.System.out . println ( ( "Diff : " + edojivqpxqinjlgeidxs ) ) ; } <s> public double calculateIntegral () { double temp = calculateIntegralAtIteration () ; double diff = 0.0 ; do { double vjfhhrwcydkmfpgpsoil = calculateIntegralAtIteration () ; edojivqpxqinjlgeidxs = java.lang.Math . abs ( ( vjfhhrwcydkmfpgpsoil - vklobawupudsvyuyyqvo ) ) ; vklobawupudsvyuyyqvo = vjfhhrwcydkmfpgpsoil ; java.lang.System.out . println ( ( "Diff : " + edojivqpxqinjlgeidxs ) ) ; } while ( diff > 1.0E-8 ) ; return temp ; } <s> fixed issue with array reference
fix_before_refactoring: { double integralValue = calculateIntegralAtIteration () ; diff = java.lang.Math . abs ( ( integralValue - temp ) ) ; temp = integralValue ; }
fix_after_refactoring: { double vjfhhrwcydkmfpgpsoil = calculateIntegralAtIteration () ; edojivqpxqinjlgeidxs = java.lang.Math . abs ( ( vjfhhrwcydkmfpgpsoil - vklobawupudsvyuyyqvo ) ) ; vklobawupudsvyuyyqvo = vjfhhrwcydkmfpgpsoil ; }
√ fix_prediction_before: { double integralValue = calculateIntegralAtIteration () ; diff = java.lang.Math . abs ( ( integralValue - temp ) ) ; temp = integralValue ; }
√ fix_prediction_after: { double vjfhhrwcydkmfpgpsoil = calculateIntegralAtIteration () ; edojivqpxqinjlgeidxs = java.lang.Math . abs ( ( vjfhhrwcydkmfpgpsoil - vklobawupudsvyuyyqvo ) ) ; vklobawupudsvyuyyqvo = vjfhhrwcydkmfpgpsoil ; }

line_index: 343
bug_before_refactoring: { int largestImageDimension = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int bestImageResolution = java.lang.Math . min ( largestImageDimension , resolution ) ; android.util.Log . d ( gov.nasa.jpl.hi.marsimages.models.ImageQuad.TAG , ( "Texture res: " + ( gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ) ) ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ; } <s> private int computeBestTextureResolution ( int resolution ) { int largestImageDimension = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int bestImageResolution = java.lang.Math . min ( largestImageDimension , resolution ) ; android.util.Log . d ( gov.nasa.jpl.hi.marsimages.models.ImageQuad.TAG , ( "Texture res: " + ( gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ) ) ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ; } <s> Fixed bug with loading locations earlier than the latest site in the mosaic view
bug_after_refactoring: { int ykhjbbqyosxepobtiqpd = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int xweuymeaebjwcdsfmwsk = java.lang.Math . min ( ykhjbbqyosxepobtiqpd , resolution ) ; android.util.Log . d ( gov.nasa.jpl.hi.marsimages.models.ImageQuad.TAG , ( "Texture res: " + ( gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ) ) ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ; } <s> private int computeBestTextureResolution ( int resolution ) { int ykhjbbqyosxepobtiqpd = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int xweuymeaebjwcdsfmwsk = java.lang.Math . min ( ykhjbbqyosxepobtiqpd , resolution ) ; android.util.Log . d ( gov.nasa.jpl.hi.marsimages.models.ImageQuad.TAG , ( "Texture res: " + ( gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ) ) ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ; } <s> Fixed bug with loading locations earlier than the latest site in the mosaic view
fix_before_refactoring: { int largestImageDimension = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int bestImageResolution = java.lang.Math . min ( largestImageDimension , resolution ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ; }
fix_after_refactoring: { int ykhjbbqyosxepobtiqpd = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int xweuymeaebjwcdsfmwsk = java.lang.Math . min ( ykhjbbqyosxepobtiqpd , resolution ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ; }
√ fix_prediction_before: { int largestImageDimension = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int bestImageResolution = java.lang.Math . min ( largestImageDimension , resolution ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( bestImageResolution ) ; }
√ fix_prediction_after: { int ykhjbbqyosxepobtiqpd = ( ( int ) ( java.lang.Math . max ( model . xdim () , model . ydim () ) ) ) ; int xweuymeaebjwcdsfmwsk = java.lang.Math . min ( ykhjbbqyosxepobtiqpd , resolution ) ; return gov.nasa.jpl.hi.marsimages.models.M . floorPowerOfTwo ( xweuymeaebjwcdsfmwsk ) ; }

line_index: 362
bug_before_refactoring: shouldReplicateToPassives = false <s> public static org.terracotta.passthrough.PassthroughMessage createUnexpectedReleaseMessage ( final java.lang.String entityClassName , final java.lang.String entityName , final long clientInstanceID ) { boolean shouldReplicateToPassives = false ; return new org.terracotta.passthrough.PassthroughMessage ( org.terracotta.passthrough.PassthroughMessage.Type.UNEXPECTED_RELEASE , shouldReplicateToPassives ) { @ java.lang.Override protected void populateStream ( java.io.DataOutputStream output ) throws java.io.IOException { output . writeUTF ( entityClassName ) ; output . writeUTF ( entityName ) ; output . writeLong ( clientInstanceID ) ; } } ; } <s> Merge pull request #127 from ramsai1729/issue-126  Fix #126: Fix oldest transaction id calculations
bug_after_refactoring: pfbepbwnnzftysqjmawo = false <s> public static org.terracotta.passthrough.PassthroughMessage createUnexpectedReleaseMessage ( final java.lang.String entityClassName , final java.lang.String entityName , final long clientInstanceID ) { boolean pfbepbwnnzftysqjmawo = false ; return new org.terracotta.passthrough.PassthroughMessage ( org.terracotta.passthrough.PassthroughMessage.Type.UNEXPECTED_RELEASE , shouldReplicateToPassives ) { @ java.lang.Override protected void populateStream ( java.io.DataOutputStream output ) throws java.io.IOException { output . writeUTF ( entityClassName ) ; output . writeUTF ( entityName ) ; output . writeLong ( clientInstanceID ) ; } } ; } <s> Merge pull request #127 from ramsai1729/issue-126  Fix #126: Fix oldest transaction id calculations
fix_before_refactoring: shouldReplicateToPassives = true
fix_after_refactoring: pfbepbwnnzftysqjmawo = true
√ fix_prediction_before: shouldReplicateToPassives = true
√ fix_prediction_after: pfbepbwnnzftysqjmawo = true

line_index: 376
bug_before_refactoring: { a . hit ( damage ) ; checkActor ( a ) ; } <s> private void handleHit ( java.lang.Package p ) { int damage = ( ( java.lang.Integer ) ( p . getPayload () ) ) ; int id = java.lang.Integer . parseInt ( p . getExtra () ) ; java.lang.System.out . println ( ( ( id + "hit " ) + ( java.lang.Math . random () ) ) ) ; for ( Actors.Actor a : actorQueue ) { if ( ( a . getID () ) == id ) { a . hit ( damage ) ; checkActor ( a ) ; } } } <s> I think i fixed the slow problem... for now  Refactored server mailroom to call handleMessages only when necessary.. gonna change that back probs.  Oh and god i forgot to commit this... I also moved checking logic to the engine and smoothed out some extra comments and todo stuff
bug_after_refactoring: { a . hit ( guuiwnbgnnjjmlugtmur ) ; checkActor ( a ) ; } <s> private void handleHit ( java.lang.Package p ) { int damage = ( ( java.lang.Integer ) ( p . getPayload () ) ) ; int id = java.lang.Integer . parseInt ( p . getExtra () ) ; java.lang.System.out . println ( ( ( id + "hit " ) + ( java.lang.Math . random () ) ) ) ; for ( Actors.Actor a : actorQueue ) { if ( ( a . getID () ) == id ) { a . hit ( guuiwnbgnnjjmlugtmur ) ; checkActor ( a ) ; } } } <s> I think i fixed the slow problem... for now  Refactored server mailroom to call handleMessages only when necessary.. gonna change that back probs.  Oh and god i forgot to commit this... I also moved checking logic to the engine and smoothed out some extra comments and todo stuff
fix_before_refactoring: { a . hit ( damage ) ; }
fix_after_refactoring: { a . hit ( guuiwnbgnnjjmlugtmur ) ; }
√ fix_prediction_before: { a . hit ( damage ) ; }
√ fix_prediction_after: { a . hit ( guuiwnbgnnjjmlugtmur ) ; }

line_index: 379
bug_before_refactoring: { grid [ n ] [ j ] . setNumber ( i ) ; } <s> public void checkNeededInColumn () { int n ; for ( int j = 0 ; j < 9 ; j ++ ) { for ( int i = 1 ; i < 10 ; i ++ ) { if ( de.halemba.helpers.SolveHelper . checkMissingInColumn ( i , j , grid ) ) { n = de.halemba.helpers.SolveHelper . checkSinglePossiblityColumn ( i , j , grid ) ; if ( n >= 0 ) { grid [ n ] [ j ] . setNumber ( i ) ; } } } } } <s> Bugfix
bug_after_refactoring: { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; } <s> public void checkNeededInColumn () { int n ; for ( int j = 0 ; j < 9 ; j ++ ) { for ( int i = 1 ; i < 10 ; i ++ ) { if ( de.halemba.helpers.SolveHelper . checkMissingInColumn ( i , j , grid ) ) { n = de.halemba.helpers.SolveHelper . checkSinglePossiblityColumn ( i , j , grid ) ; if ( n >= 0 ) { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; } } } } } <s> Bugfix
fix_before_refactoring: { grid [ n ] [ j ] . setNumber ( i ) ; break; }
fix_after_refactoring: { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; break; }
√ fix_prediction_before: { grid [ n ] [ j ] . setNumber ( i ) ; break; }
√ fix_prediction_after: { grid [ wilmqquceclzdqbhcfcg ] [ j ] . setNumber ( i ) ; break; }

line_index: 380
bug_before_refactoring: index = 0 <s> public java.lang.String getStringTodoList () { java.lang.String result = "\nItems to do: \n" ; int index = 0 ; for ( TodoItem item : this . itemList ) { result += java.lang.String . format ( "%d. " , index ) ; if ( item . getIsDone () ) { result += "[x] " ; } result += java.lang.String . format ( "%s%n" , item . getName () ) ; index ++ ; } return result ; } <s> Fix visual bugs
bug_after_refactoring: kmzixwoyfmlbfykiozcd = 0 <s> public java.lang.String getStringTodoList () { java.lang.String result = "\nItems to do: \n" ; int kmzixwoyfmlbfykiozcd = 0 ; for ( TodoItem item : this . itemList ) { result += java.lang.String . format ( "%d. " , index ) ; if ( item . getIsDone () ) { result += "[x] " ; } result += java.lang.String . format ( "%s%n" , item . getName () ) ; index ++ ; } return result ; } <s> Fix visual bugs
fix_before_refactoring: index = 1
fix_after_refactoring: kmzixwoyfmlbfykiozcd = 1
√ fix_prediction_before: index = 1
√ fix_prediction_after: kmzixwoyfmlbfykiozcd = 1

line_index: 387
bug_before_refactoring: slash.navigation.gui.events.Range . increment ( selectedRows , ( - 1 ) ) <s> public void run () { int [] selectedRows = tablePositions . getSelectedRows () ; if ( ( selectedRows.length ) > 0 ) { getPositionsModel () . up ( selectedRows , 1 ) ; selectPositions ( slash.navigation.gui.events.Range . increment ( selectedRows , ( - 1 ) ) ) ; } } <s> fixes disabled functions until selection problem  might cause performance problems http://forum.routeconverter.com/thread-1987.html
bug_after_refactoring: slash.navigation.gui.events.Range . increment ( riclvjieshlqqxnypyhp , ( - 1 ) ) <s> public void run () { int [] selectedRows = tablePositions . getSelectedRows () ; if ( ( selectedRows.length ) > 0 ) { getPositionsModel () . up ( selectedRows , 1 ) ; selectPositions ( slash.navigation.gui.events.Range . increment ( riclvjieshlqqxnypyhp , ( - 1 ) ) ) ; } } <s> fixes disabled functions until selection problem  might cause performance problems http://forum.routeconverter.com/thread-1987.html
fix_before_refactoring: increment ( selectedRows , ( - 1 ) )
fix_after_refactoring: increment ( riclvjieshlqqxnypyhp , ( - 1 ) )
√ fix_prediction_before: increment ( selectedRows , ( - 1 ) )
√ fix_prediction_after: increment ( riclvjieshlqqxnypyhp , ( - 1 ) )

line_index: 389
bug_before_refactoring: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int today = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; java.lang.System.out . println ( daysBitString ) ; if ( frequencyDays . substring ( today , ( today + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } } <s> public void setFrequencyDays ( java.lang.String daysBitString ) { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int today = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; java.lang.System.out . println ( daysBitString ) ; if ( frequencyDays . substring ( today , ( today + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } } <s> Fix reminder times bug
bug_after_refactoring: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int ydcofxtbgbmbaqovsmdw = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; java.lang.System.out . println ( daysBitString ) ; if ( frequencyDays . substring ( ydcofxtbgbmbaqovsmdw , ( ydcofxtbgbmbaqovsmdw + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } } <s> public void setFrequencyDays ( java.lang.String daysBitString ) { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int ydcofxtbgbmbaqovsmdw = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; java.lang.System.out . println ( daysBitString ) ; if ( frequencyDays . substring ( ydcofxtbgbmbaqovsmdw , ( ydcofxtbgbmbaqovsmdw + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } } <s> Fix reminder times bug
fix_before_refactoring: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int today = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; if ( frequencyDays . substring ( today , ( today + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } }
fix_after_refactoring: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int ydcofxtbgbmbaqovsmdw = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; if ( frequencyDays . substring ( ydcofxtbgbmbaqovsmdw , ( ydcofxtbgbmbaqovsmdw + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } }
√ fix_prediction_before: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int today = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; if ( frequencyDays . substring ( today , ( today + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } }
√ fix_prediction_after: { frequencyDays = daysBitString ; java.util.Calendar calendar = java.util.Calendar . getInstance () ; int ydcofxtbgbmbaqovsmdw = ( calendar . get ( java.util.Calendar.DAY_OF_WEEK ) ) - 1 ; if ( frequencyDays . substring ( ydcofxtbgbmbaqovsmdw , ( ydcofxtbgbmbaqovsmdw + 1 ) ) . equals ( "1" ) ) { isToday = true ; } else { isToday = false ; } }

line_index: 409
bug_before_refactoring: { super . onResume () ; int orderId = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; java.lang.System.out . println ( ( "Intent with order ID " + orderId ) ) ; if ( orderId != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( orderId ) ) ) ; } <s> @ java.lang.Override protected void onResume () { super . onResume () ; int orderId = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; java.lang.System.out . println ( ( "Intent with order ID " + orderId ) ) ; if ( orderId != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( orderId ) ) ) ; } <s> Fixed sidebar rotation bug
bug_after_refactoring: { super . onResume () ; int mblkstxlgakrqeurrpkc = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; java.lang.System.out . println ( ( "Intent with order ID " + mblkstxlgakrqeurrpkc ) ) ; if ( mblkstxlgakrqeurrpkc != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( mblkstxlgakrqeurrpkc ) ) ) ; } <s> @ java.lang.Override protected void onResume () { super . onResume () ; int mblkstxlgakrqeurrpkc = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; java.lang.System.out . println ( ( "Intent with order ID " + mblkstxlgakrqeurrpkc ) ) ; if ( mblkstxlgakrqeurrpkc != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( mblkstxlgakrqeurrpkc ) ) ) ; } <s> Fixed sidebar rotation bug
fix_before_refactoring: { super . onResume () ; int orderId = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; if ( orderId != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( orderId ) ) ) ; }
fix_after_refactoring: { super . onResume () ; int mblkstxlgakrqeurrpkc = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; if ( mblkstxlgakrqeurrpkc != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( mblkstxlgakrqeurrpkc ) ) ) ; }
√ fix_prediction_before: { super . onResume () ; int orderId = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; if ( orderId != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( orderId ) ) ) ; }
√ fix_prediction_after: { super . onResume () ; int mblkstxlgakrqeurrpkc = getIntent () . getIntExtra ( OrderStatusNotification.ORDER_ID , ( - 1 ) ) ; if ( mblkstxlgakrqeurrpkc != ( - 1 ) ) navTo ( new activity.OrderDetailFragment () . setOrder ( new model.Order ( mblkstxlgakrqeurrpkc ) ) ) ; }

line_index: 417
bug_before_refactoring: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / higherValue ) ) ) ; java.lang.System.out . println ( ( "Ordenado: " + ( q . getThreeYearTotal () ) ) ) ; } <s> private static void calculateDiscount () { java.util.Collections . sort ( Constants.quotes ) ; double higherValue = Constants.quotes . get ( 0 ) . getThreeYearTotal () ; if ( higherValue > 0 ) { for ( com.amazon.proposalcalculator.bean.Quote q : com.amazon.proposalcalculator.utils.Constants.quotes ) { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / higherValue ) ) ) ; java.lang.System.out . println ( ( "Ordenado: " + ( q . getThreeYearTotal () ) ) ) ; } } } <s> Bug fix
bug_after_refactoring: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / ubulzylmnwmntivrjhha ) ) ) ; java.lang.System.out . println ( ( "Ordenado: " + ( q . getThreeYearTotal () ) ) ) ; } <s> private static void calculateDiscount () { java.util.Collections . sort ( Constants.quotes ) ; double higherValue = Constants.quotes . get ( 0 ) . getThreeYearTotal () ; if ( higherValue > 0 ) { for ( com.amazon.proposalcalculator.bean.Quote q : com.amazon.proposalcalculator.utils.Constants.quotes ) { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / ubulzylmnwmntivrjhha ) ) ) ; java.lang.System.out . println ( ( "Ordenado: " + ( q . getThreeYearTotal () ) ) ) ; } } } <s> Bug fix
fix_before_refactoring: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / higherValue ) ) ) ; }
fix_after_refactoring: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / ubulzylmnwmntivrjhha ) ) ) ; }
√ fix_prediction_before: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / higherValue ) ) ) ; }
√ fix_prediction_after: { q . setDiscount ( ( 1 - ( ( q . getThreeYearTotal () ) / ubulzylmnwmntivrjhha ) ) ) ; }

line_index: 436
bug_before_refactoring: { boolean canJoin = true ; java.lang.System.out . println ( ( channel != ( client . getChannel () ) ) ) ; if ( canJoin && ( channel != ( client . getChannel () ) ) ) { client . setChannel ( channel ) ; channel . addClient ( client ) ; } else {} } <s> private void moveClient ( org.zapto.mike.mrstreamserver.Channel channel , org.zapto.mike.mrstreamserver.ClientHandler client ) { boolean canJoin = true ; java.lang.System.out . println ( ( channel != ( client . getChannel () ) ) ) ; if ( canJoin && ( channel != ( client . getChannel () ) ) ) { client . setChannel ( channel ) ; channel . addClient ( client ) ; } else {} } <s> Fixed issue with joining channels
bug_after_refactoring: { boolean gvbbstxeoqnhrnmoqpkh = true ; java.lang.System.out . println ( ( channel != ( client . getChannel () ) ) ) ; if ( gvbbstxeoqnhrnmoqpkh && ( channel != ( client . getChannel () ) ) ) { client . setChannel ( channel ) ; channel . addClient ( client ) ; } else {} } <s> private void moveClient ( org.zapto.mike.mrstreamserver.Channel channel , org.zapto.mike.mrstreamserver.ClientHandler client ) { boolean gvbbstxeoqnhrnmoqpkh = true ; java.lang.System.out . println ( ( channel != ( client . getChannel () ) ) ) ; if ( gvbbstxeoqnhrnmoqpkh && ( channel != ( client . getChannel () ) ) ) { client . setChannel ( channel ) ; channel . addClient ( client ) ; } else {} } <s> Fixed issue with joining channels
fix_before_refactoring: { boolean canJoin = true ; if ( canJoin && ( channel != ( client . getChannel () ) ) ) { client . setChannel ( channel ) ; channel . addClient ( client ) ; } else {} }
fix_after_refactoring: { boolean gvbbstxeoqnhrnmoqpkh = true ; if ( gvbbstxeoqnhrnmoqpkh && ( channel != ( client . getChannel () ) ) ) { client . setChannel ( channel ) ; channel . addClient ( client ) ; } else {} }
√ fix_prediction_before: { boolean canJoin = true ; if ( canJoin && ( channel != ( client . getChannel () ) ) ) { client . setChannel ( channel ) ; channel . addClient ( client ) ; } else {} }
√ fix_prediction_after: { boolean gvbbstxeoqnhrnmoqpkh = true ; if ( gvbbstxeoqnhrnmoqpkh && ( channel != ( client . getChannel () ) ) ) { client . setChannel ( channel ) ; channel . addClient ( client ) ; } else {} }

line_index: 448
bug_before_refactoring: { int id = item . getItemId () ; if ( ( mSessionManager . getIsPurchased () ) == ( com.aftersapp.utils.AppConstants.ITEM_NOT_PURCHASED ) ) com.aftersapp.AftersAppApplication . getInstance () . setAddClickCount () ; if ( id == ( R.id.action_filter ) ) { com.aftersapp.fragments.FilterFragment filterFragment = new com.aftersapp.fragments.FilterFragment () ; getFragmentManager () . beginTransaction () . replace ( R.id.fragment_frame_lay , filterFragment , "FilterFragment" ) . commit () ; return true ; } return super . onOptionsItemSelected ( item ) ; } <s> @ java.lang.Override public boolean onOptionsItemSelected ( android.view.MenuItem item ) { int id = item . getItemId () ; if ( ( mSessionManager . getIsPurchased () ) == ( com.aftersapp.utils.AppConstants.ITEM_NOT_PURCHASED ) ) com.aftersapp.AftersAppApplication . getInstance () . setAddClickCount () ; if ( id == ( R.id.action_filter ) ) { com.aftersapp.fragments.FilterFragment filterFragment = new com.aftersapp.fragments.FilterFragment () ; getFragmentManager () . beginTransaction () . replace ( R.id.fragment_frame_lay , filterFragment , "FilterFragment" ) . commit () ; return true ; } return super . onOptionsItemSelected ( item ) ; } <s> Bug fixing in ads and Days selsection in filter  Bug fixing in ads and Days selsection in filter
bug_after_refactoring: { int gxpwevblogxbdkjdmpxo = item . getItemId () ; if ( ( mSessionManager . getIsPurchased () ) == ( com.aftersapp.utils.AppConstants.ITEM_NOT_PURCHASED ) ) com.aftersapp.AftersAppApplication . getInstance () . setAddClickCount () ; if ( gxpwevblogxbdkjdmpxo == ( R.gxpwevblogxbdkjdmpxo.action_filter ) ) { com.aftersapp.fragments.FilterFragment filterFragment = new com.aftersapp.fragments.FilterFragment () ; getFragmentManager () . beginTransaction () . replace ( R.gxpwevblogxbdkjdmpxo.fragment_frame_lay , filterFragment , "FilterFragment" ) . commit () ; return true ; } return super . onOptionsItemSelected ( item ) ; } <s> @ java.lang.Override public boolean onOptionsItemSelected ( android.view.MenuItem item ) { int gxpwevblogxbdkjdmpxo = item . getItemId () ; if ( ( mSessionManager . getIsPurchased () ) == ( com.aftersapp.utils.AppConstants.ITEM_NOT_PURCHASED ) ) com.aftersapp.AftersAppApplication . getInstance () . setAddClickCount () ; if ( gxpwevblogxbdkjdmpxo == ( R.gxpwevblogxbdkjdmpxo.action_filter ) ) { com.aftersapp.fragments.FilterFragment filterFragment = new com.aftersapp.fragments.FilterFragment () ; getFragmentManager () . beginTransaction () . replace ( R.gxpwevblogxbdkjdmpxo.fragment_frame_lay , filterFragment , "FilterFragment" ) . commit () ; return true ; } return super . onOptionsItemSelected ( item ) ; } <s> Bug fixing in ads and Days selsection in filter  Bug fixing in ads and Days selsection in filter
fix_before_refactoring: { int id = item . getItemId () ; if ( id == ( R.id.action_filter ) ) { com.aftersapp.fragments.FilterFragment filterFragment = new com.aftersapp.fragments.FilterFragment () ; getFragmentManager () . beginTransaction () . replace ( R.id.fragment_frame_lay , filterFragment , "FilterFragment" ) . commit () ; return true ; } return super . onOptionsItemSelected ( item ) ; }
fix_after_refactoring: { int gxpwevblogxbdkjdmpxo = item . getItemId () ; if ( gxpwevblogxbdkjdmpxo == ( R.gxpwevblogxbdkjdmpxo.action_filter ) ) { com.aftersapp.fragments.FilterFragment filterFragment = new com.aftersapp.fragments.FilterFragment () ; getFragmentManager () . beginTransaction () . replace ( R.gxpwevblogxbdkjdmpxo.fragment_frame_lay , filterFragment , "FilterFragment" ) . commit () ; return true ; } return super . onOptionsItemSelected ( item ) ; }
√ fix_prediction_before: { int id = item . getItemId () ; if ( id == ( R.id.action_filter ) ) { com.aftersapp.fragments.FilterFragment filterFragment = new com.aftersapp.fragments.FilterFragment () ; getFragmentManager () . beginTransaction () . replace ( R.id.fragment_frame_lay , filterFragment , "FilterFragment" ) . commit () ; return true ; } return super . onOptionsItemSelected ( item ) ; }
√ fix_prediction_after: { int gxpwevblogxbdkjdmpxo = item . getItemId () ; if ( gxpwevblogxbdkjdmpxo == ( R.gxpwevblogxbdkjdmpxo.action_filter ) ) { com.aftersapp.fragments.FilterFragment filterFragment = new com.aftersapp.fragments.FilterFragment () ; getFragmentManager () . beginTransaction () . replace ( R.gxpwevblogxbdkjdmpxo.fragment_frame_lay , filterFragment , "FilterFragment" ) . commit () ; return true ; } return super . onOptionsItemSelected ( item ) ; }

line_index: 475
bug_before_refactoring: { return oprationRowNum = x ; } <s> public int getSbOperationRowNum ( java.lang.String operator , java.lang.String opration , int startRow , int endRow , java.util.List < java.util.List < java.lang.String > > data ) { int oprationRowNum = 0 ; for ( int x = startRow ; x <= endRow ; x ++ ) { if ( ( data . get ( x ) . get ( 4 ) . equalsIgnoreCase ( operator ) ) && ( data . get ( x ) . get ( 5 ) . equalsIgnoreCase ( opration ) ) ) { return oprationRowNum = x ; } } return oprationRowNum ; } <s> Fixed many bugs detected by sonar and add fluent wait
bug_after_refactoring: { return jqwvyertdrayemxczjmz = x ; } <s> public int getSbOperationRowNum ( java.lang.String operator , java.lang.String opration , int startRow , int endRow , java.util.List < java.util.List < java.lang.String > > data ) { int oprationRowNum = 0 ; for ( int x = startRow ; x <= endRow ; x ++ ) { if ( ( data . get ( x ) . get ( 4 ) . equalsIgnoreCase ( operator ) ) && ( data . get ( x ) . get ( 5 ) . equalsIgnoreCase ( opration ) ) ) { return jqwvyertdrayemxczjmz = x ; } } return oprationRowNum ; } <s> Fixed many bugs detected by sonar and add fluent wait
fix_before_refactoring: { oprationRowNum = x ; break; }
fix_after_refactoring: { jqwvyertdrayemxczjmz = x ; break; }
√ fix_prediction_before: { oprationRowNum = x ; break; }
√ fix_prediction_after: { jqwvyertdrayemxczjmz = x ; break; }

line_index: 478
bug_before_refactoring: intent . putExtra ( "position" , ( itemPosition + "" ) ) <s> @ java.lang.Override public void onClick ( android.view.View view ) { android.util.Log . d ( "click listener" , "working!" ) ; int itemPosition = getLayoutPosition () ; android.content.Intent intent = new android.content.Intent ( mContext , com.epicodus.a4u2poo.DetailActivity . class ) ; intent . putExtra ( "position" , ( itemPosition + "" ) ) ; intent . putExtra ( "restrooms" , org.parceler.Parcels . wrap ( mRestrooms ) ) ; mContext . startActivity ( intent ) ; } <s> Fixed bug in pager where pager always started at position 0
bug_after_refactoring: intent . putExtra ( "position" , ( doeacwhvpdpbhfiqgfvy + "" ) ) <s> @ java.lang.Override public void onClick ( android.view.View view ) { android.util.Log . d ( "click listener" , "working!" ) ; int itemPosition = getLayoutPosition () ; android.content.Intent intent = new android.content.Intent ( mContext , com.epicodus.a4u2poo.DetailActivity . class ) ; intent . putExtra ( "position" , ( doeacwhvpdpbhfiqgfvy + "" ) ) ; intent . putExtra ( "restrooms" , org.parceler.Parcels . wrap ( mRestrooms ) ) ; mContext . startActivity ( intent ) ; } <s> Fixed bug in pager where pager always started at position 0
fix_before_refactoring: intent . putExtra ( "position" , itemPosition )
fix_after_refactoring: intent . putExtra ( "position" , doeacwhvpdpbhfiqgfvy )
√ fix_prediction_before: intent . putExtra ( "position" , itemPosition )
√ fix_prediction_after: intent . putExtra ( "position" , doeacwhvpdpbhfiqgfvy )

line_index: 494
bug_before_refactoring: ( docid > 0 ) <s> @ java.lang.Override protected byte [] getFromStore ( long uid ) throws java.io.IOException { int docid = mapDocId ( uid ) ; if ( docid < 0 ) return null ; org.apache.lucene.index.IndexReader reader = null ; if ( ( _currentReaderData ) != null ) { reader = _currentReaderData.reader ; } if ( ( docid > 0 ) && ( reader != null ) ) { org.apache.lucene.document.Document doc = reader . document ( docid ) ; if ( doc != null ) { return doc . getBinaryValue ( _field ) ; } } return null ; } <s> bug fixes and added unit testing for store
bug_after_refactoring: ( ovgogvhjgsikcwiiqght > 0 ) <s> @ java.lang.Override protected byte [] getFromStore ( long uid ) throws java.io.IOException { int docid = mapDocId ( uid ) ; if ( docid < 0 ) return null ; org.apache.lucene.index.IndexReader reader = null ; if ( ( _currentReaderData ) != null ) { reader = _currentReaderData.reader ; } if ( ( ovgogvhjgsikcwiiqght > 0 ) && ( reader != null ) ) { org.apache.lucene.document.Document doc = reader . document ( docid ) ; if ( doc != null ) { return doc . getBinaryValue ( _field ) ; } } return null ; } <s> bug fixes and added unit testing for store
fix_before_refactoring: ( docid >= 0 )
fix_after_refactoring: ( ovgogvhjgsikcwiiqght >= 0 )
√ fix_prediction_before: ( docid >= 0 )
√ fix_prediction_after: ( ovgogvhjgsikcwiiqght >= 0 )

line_index: 502
bug_before_refactoring: randomPos = ( ( int ) ( ( java.lang.Math . random () ) * ( topCard ) ) ) + 1 <s> public void shuffle () { sorted = false ; for ( int i = ( topCard ) - 1 ; i > 0 ; i -- ) { int randomPos = ( ( int ) ( ( java.lang.Math . random () ) * ( topCard ) ) ) + 1 ; Card temp = cards [ i ] ; cards [ i ] = cards [ randomPos ] ; cards [ randomPos ] = temp ; } } <s> Fixed a lot of issues in Card and Deck  made a new DeckTester
bug_after_refactoring: touosnixnzozrojndbcm = ( ( int ) ( ( java.lang.Math . random () ) * ( topCard ) ) ) + 1 <s> public void shuffle () { sorted = false ; for ( int i = ( topCard ) - 1 ; i > 0 ; i -- ) { int touosnixnzozrojndbcm = ( ( int ) ( ( java.lang.Math . random () ) * ( topCard ) ) ) + 1 ; Card temp = cards [ i ] ; cards [ i ] = cards [ randomPos ] ; cards [ randomPos ] = temp ; } } <s> Fixed a lot of issues in Card and Deck  made a new DeckTester
fix_before_refactoring: randomPos = ( ( int ) ( ( java.lang.Math . random () ) * ( topCard ) ) )
fix_after_refactoring: touosnixnzozrojndbcm = ( ( int ) ( ( java.lang.Math . random () ) * ( topCard ) ) )
√ fix_prediction_before: randomPos = ( ( int ) ( ( java.lang.Math . random () ) * ( topCard ) ) )
√ fix_prediction_after: touosnixnzozrojndbcm = ( ( int ) ( ( java.lang.Math . random () ) * ( topCard ) ) )

line_index: 505
bug_before_refactoring: ( ( menu . get ( tempIndex ) . price ) >= ( this . price ) ) && ( ( this . index ) < ( this . menuSize ) ) <s> public void next () { this . index += 1 ; int tempIndex = this . index ; while ( ( ( menu . get ( tempIndex ) . price ) >= ( this . price ) ) && ( ( this . index ) < ( this . menuSize ) ) ) { this . index += 1 ; tempIndex += 1 ; } } <s> Fixed bug that was ignoring the last item in the list
bug_after_refactoring: ( ( menu . get ( wawhzqmqgfbxhuvlxhju ) . price ) >= ( this . price ) ) && ( ( this . index ) < ( this . menuSize ) ) <s> public void next () { this . index += 1 ; int tempIndex = this . index ; while ( ( ( menu . get ( wawhzqmqgfbxhuvlxhju ) . price ) >= ( this . price ) ) && ( ( this . index ) < ( this . menuSize ) ) ) { this . index += 1 ; tempIndex += 1 ; } } <s> Fixed bug that was ignoring the last item in the list
fix_before_refactoring: ( ( this . index ) < ( this . menuSize ) ) && ( ( menu . get ( tempIndex ) . price ) >= ( this . price ) )
fix_after_refactoring: ( ( this . index ) < ( this . menuSize ) ) && ( ( menu . get ( wawhzqmqgfbxhuvlxhju ) . price ) >= ( this . price ) )
√ fix_prediction_before: ( ( this . index ) < ( this . menuSize ) ) && ( ( menu . get ( tempIndex ) . price ) >= ( this . price ) )
√ fix_prediction_after: ( ( this . index ) < ( this . menuSize ) ) && ( ( menu . get ( wawhzqmqgfbxhuvlxhju ) . price ) >= ( this . price ) )

line_index: 524
bug_before_refactoring: { java.lang.String item = "%d %d 0" ; long curTime = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , curTime , e . getKeyCode () ) ) ; java.lang.System.out . println ( ( ( e . getKeyChar () ) + " 0" ) ) ; } <s> @ java.lang.Override public void keyPressed ( java.awt.event.KeyEvent e ) { if ( ( ( remain . length () ) == 0 ) && ( ( e . getKeyCode () ) != ( java.awt.event.KeyEvent.VK_ENTER ) ) ) { e . consume () ; retype () ; } else { java.lang.String item = "%d %d 0" ; long curTime = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , curTime , e . getKeyCode () ) ) ; java.lang.System.out . println ( ( ( e . getKeyChar () ) + " 0" ) ) ; } } <s> Fix bug that a release event may be captured at beginning of sampling
bug_after_refactoring: { java.lang.String item = "%d %d 0" ; long xuckavxmfiveeicaqjfa = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , xuckavxmfiveeicaqjfa , e . getKeyCode () ) ) ; java.lang.System.out . println ( ( ( e . getKeyChar () ) + " 0" ) ) ; } <s> @ java.lang.Override public void keyPressed ( java.awt.event.KeyEvent e ) { if ( ( ( remain . length () ) == 0 ) && ( ( e . getKeyCode () ) != ( java.awt.event.KeyEvent.VK_ENTER ) ) ) { e . consume () ; retype () ; } else { java.lang.String item = "%d %d 0" ; long xuckavxmfiveeicaqjfa = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , xuckavxmfiveeicaqjfa , e . getKeyCode () ) ) ; java.lang.System.out . println ( ( ( e . getKeyChar () ) + " 0" ) ) ; } } <s> Fix bug that a release event may be captured at beginning of sampling
fix_before_refactoring: { java.lang.String item = "%d %d 0" ; long curTime = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , curTime , e . getKeyCode () ) ) ; }
fix_after_refactoring: { java.lang.String item = "%d %d 0" ; long xuckavxmfiveeicaqjfa = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , xuckavxmfiveeicaqjfa , e . getKeyCode () ) ) ; }
√ fix_prediction_before: { java.lang.String item = "%d %d 0" ; long curTime = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , curTime , e . getKeyCode () ) ) ; }
√ fix_prediction_after: { java.lang.String item = "%d %d 0" ; long xuckavxmfiveeicaqjfa = java.lang.System . currentTimeMillis () ; records . add ( java.lang.String . format ( item , xuckavxmfiveeicaqjfa , e . getKeyCode () ) ) ; }

line_index: 541
bug_before_refactoring: ( this . table [ hashCode ] ) != ( java.lang.Long.MIN_VALUE ) <s> public boolean contains ( long value ) { int hashCode = hash ( value ) ; int hashMarker = - 1 ; while ( ( ( this . table [ hashCode ] ) != ( java.lang.Long.MIN_VALUE ) ) && ( hashCode != hashMarker ) ) { if ( ( this . table [ hashCode ] ) == value ) return true ; if ( hashMarker == ( - 1 ) ) hashMarker = hashCode ; hashCode = ( hashCode + 1 ) % ( this . table . length ) ; } return false ; } <s> Fixed memory issues  now works with 64mb heap
bug_after_refactoring: ( this . table [ jdybitznqqnnwimruwok ] ) != ( java.lang.Long.MIN_VALUE ) <s> public boolean contains ( long value ) { int hashCode = hash ( value ) ; int hashMarker = - 1 ; while ( ( ( this . table [ jdybitznqqnnwimruwok ] ) != ( java.lang.Long.MIN_VALUE ) ) && ( hashCode != hashMarker ) ) { if ( ( this . table [ hashCode ] ) == value ) return true ; if ( hashMarker == ( - 1 ) ) hashMarker = hashCode ; hashCode = ( hashCode + 1 ) % ( this . table . length ) ; } return false ; } <s> Fixed memory issues  now works with 64mb heap
fix_before_refactoring: ( this . table [ hashCode ] ) != null
fix_after_refactoring: ( this . table [ jdybitznqqnnwimruwok ] ) != null
√ fix_prediction_before: ( this . table [ hashCode ] ) != null
√ fix_prediction_after: ( this . table [ jdybitznqqnnwimruwok ] ) != null

line_index: 545
bug_before_refactoring: { double diffX = x1 - px ; double diffY = y1 - py ; double dist = ( diffX * diffX ) + ( diffY * diffY ) ; if ( dist < ( radius * radius ) ) { return true ; } else { return false ; } } <s> private boolean pntInCircle ( double px , double py , double x1 , double y1 , double radius ) { double diffX = x1 - px ; double diffY = y1 - py ; double dist = ( diffX * diffX ) + ( diffY * diffY ) ; if ( dist < ( radius * radius ) ) { return true ; } else { return false ; } } <s> Bug fix: Widget position on devices
bug_after_refactoring: { double zsdecekcsmgimytxdtwd = x1 - px ; double nbfdwmgognkdnxzkmorj = y1 - py ; double rhzzzdjvynrvdbdzkqqq = ( zsdecekcsmgimytxdtwd * zsdecekcsmgimytxdtwd ) + ( nbfdwmgognkdnxzkmorj * nbfdwmgognkdnxzkmorj ) ; if ( rhzzzdjvynrvdbdzkqqq < ( radius * radius ) ) { return true ; } else { return false ; } } <s> private boolean pntInCircle ( double px , double py , double x1 , double y1 , double radius ) { double zsdecekcsmgimytxdtwd = x1 - px ; double nbfdwmgognkdnxzkmorj = y1 - py ; double rhzzzdjvynrvdbdzkqqq = ( zsdecekcsmgimytxdtwd * zsdecekcsmgimytxdtwd ) + ( nbfdwmgognkdnxzkmorj * nbfdwmgognkdnxzkmorj ) ; if ( rhzzzdjvynrvdbdzkqqq < ( radius * radius ) ) { return true ; } else { return false ; } } <s> Bug fix: Widget position on devices
fix_before_refactoring: { double diffX = x1 - px ; double diffY = y1 - py ; double dist = ( diffX * diffX ) + ( diffY * diffY ) ; return dist < ( radius * radius ) ; }
fix_after_refactoring: { double zsdecekcsmgimytxdtwd = x1 - px ; double nbfdwmgognkdnxzkmorj = y1 - py ; double rhzzzdjvynrvdbdzkqqq = ( zsdecekcsmgimytxdtwd * zsdecekcsmgimytxdtwd ) + ( nbfdwmgognkdnxzkmorj * nbfdwmgognkdnxzkmorj ) ; return rhzzzdjvynrvdbdzkqqq < ( radius * radius ) ; }
√ fix_prediction_before: { double diffX = x1 - px ; double diffY = y1 - py ; double dist = ( diffX * diffX ) + ( diffY * diffY ) ; return dist < ( radius * radius ) ; }
√ fix_prediction_after: { double zsdecekcsmgimytxdtwd = x1 - px ; double nbfdwmgognkdnxzkmorj = y1 - py ; double rhzzzdjvynrvdbdzkqqq = ( zsdecekcsmgimytxdtwd * zsdecekcsmgimytxdtwd ) + ( nbfdwmgognkdnxzkmorj * nbfdwmgognkdnxzkmorj ) ; return rhzzzdjvynrvdbdzkqqq < ( radius * radius ) ; }

line_index: 548
bug_before_refactoring: { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_CURIE } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } } <s> public void testIterFilterLimit () { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_CURIE } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } } <s> Fixed compilation error (using SienaFutureProxy instead of SienaFuture)
bug_after_refactoring: { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_CURIE } ; int yejavcztivjxnetvxcqz = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ yejavcztivjxnetvxcqz ] , PersonIntKey ) ; yejavcztivjxnetvxcqz ++ ; } } <s> public void testIterFilterLimit () { siena.core.async.SienaFuture < java.lang.Iterable < siena.base.test.model.PersonUUID > > future = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 1 ) ; java.lang.Iterable < siena.base.test.model.PersonUUID > people = future . get () ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_CURIE } ; int yejavcztivjxnetvxcqz = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ yejavcztivjxnetvxcqz ] , PersonIntKey ) ; yejavcztivjxnetvxcqz ++ ; } } <s> Fixed compilation error (using SienaFutureProxy instead of SienaFuture)
fix_before_refactoring: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_CURIE } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } }
fix_after_refactoring: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_CURIE } ; int yejavcztivjxnetvxcqz = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ yejavcztivjxnetvxcqz ] , PersonIntKey ) ; yejavcztivjxnetvxcqz ++ ; } }
√ fix_prediction_before: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_CURIE } ; int i = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ i ] , PersonIntKey ) ; i ++ ; } }
√ fix_prediction_after: { java.lang.Iterable < siena.base.test.model.PersonUUID > people = pm . createQuery ( siena.base.test.model.PersonUUID . class ) . filter ( "n>" , 1 ) . order ( "n" ) . iter ( 1 ) ; assertNotNull ( people ) ; siena.base.test.model.PersonUUID [] array = new siena.base.test.model.PersonUUID [] { siena.base.test.BaseAsyncTest.UUID_CURIE } ; int yejavcztivjxnetvxcqz = 0 ; for ( siena.base.test.model.PersonUUID PersonIntKey : people ) { assertEquals ( array [ yejavcztivjxnetvxcqz ] , PersonIntKey ) ; yejavcztivjxnetvxcqz ++ ; } }

line_index: 551
bug_before_refactoring: { long idxUsagesBefore = indexUsages ( db ) ; java.util.List < com.orientechnologies.orient.core.record.impl.ODocument > qResult = db . command ( new com.orientechnologies.orient.core.sql.OCommandSQL ( "select * from foo where bar = 2 or name ='a' and bar >= 0" ) ) . execute () ; org.testng.Assert . assertEquals ( qResult . size () , 2 ) ; org.testng.Assert . assertEquals ( indexUsages ( db ) , ( idxUsagesBefore + 2 ) ) ; } <s> @ org.testng.annotations.Test public void testUseIndexWithOr ( ) throws java.lang.Exception { long idxUsagesBefore = indexUsages ( db ) ; java.util.List < com.orientechnologies.orient.core.record.impl.ODocument > qResult = db . command ( new com.orientechnologies.orient.core.sql.OCommandSQL ( "select * from foo where bar = 2 or name ='a' and bar >= 0" ) ) . execute () ; org.testng.Assert . assertEquals ( qResult . size () , 2 ) ; org.testng.Assert . assertEquals ( indexUsages ( db ) , ( idxUsagesBefore + 2 ) ) ; } <s> fixed parsing issue when newline is used instead of blank space
bug_after_refactoring: { long jdwejfrjigqdseylgaap = indexUsages ( db ) ; java.util.List < com.orientechnologies.orient.core.record.impl.ODocument > qResult = db . command ( new com.orientechnologies.orient.core.sql.OCommandSQL ( "select * from foo where bar = 2 or name ='a' and bar >= 0" ) ) . execute () ; org.testng.Assert . assertEquals ( qResult . size () , 2 ) ; org.testng.Assert . assertEquals ( indexUsages ( db ) , ( jdwejfrjigqdseylgaap + 2 ) ) ; } <s> @ org.testng.annotations.Test public void testUseIndexWithOr ( ) throws java.lang.Exception { long jdwejfrjigqdseylgaap = indexUsages ( db ) ; java.util.List < com.orientechnologies.orient.core.record.impl.ODocument > qResult = db . command ( new com.orientechnologies.orient.core.sql.OCommandSQL ( "select * from foo where bar = 2 or name ='a' and bar >= 0" ) ) . execute () ; org.testng.Assert . assertEquals ( qResult . size () , 2 ) ; org.testng.Assert . assertEquals ( indexUsages ( db ) , ( jdwejfrjigqdseylgaap + 2 ) ) ; } <s> fixed parsing issue when newline is used instead of blank space
fix_before_refactoring: { long idxUsagesBefore = indexUsages ( db ) ; java.util.List < com.orientechnologies.orient.core.record.impl.ODocument > qResult = db . command ( new com.orientechnologies.orient.core.sql.OCommandSQL ( "select * from foo where bar = 2 or name ='a' and bar >= 0" ) ) . execute () ; assertEquals ( qResult . size () , 2 ) ; assertEquals ( indexUsages ( db ) , ( idxUsagesBefore + 2 ) ) ; }
fix_after_refactoring: { long jdwejfrjigqdseylgaap = indexUsages ( db ) ; java.util.List < com.orientechnologies.orient.core.record.impl.ODocument > qResult = db . command ( new com.orientechnologies.orient.core.sql.OCommandSQL ( "select * from foo where bar = 2 or name ='a' and bar >= 0" ) ) . execute () ; assertEquals ( qResult . size () , 2 ) ; assertEquals ( indexUsages ( db ) , ( jdwejfrjigqdseylgaap + 2 ) ) ; }
√ fix_prediction_before: { long idxUsagesBefore = indexUsages ( db ) ; java.util.List < com.orientechnologies.orient.core.record.impl.ODocument > qResult = db . command ( new com.orientechnologies.orient.core.sql.OCommandSQL ( "select * from foo where bar = 2 or name ='a' and bar >= 0" ) ) . execute () ; assertEquals ( qResult . size () , 2 ) ; assertEquals ( indexUsages ( db ) , ( idxUsagesBefore + 2 ) ) ; }
√ fix_prediction_after: { long jdwejfrjigqdseylgaap = indexUsages ( db ) ; java.util.List < com.orientechnologies.orient.core.record.impl.ODocument > qResult = db . command ( new com.orientechnologies.orient.core.sql.OCommandSQL ( "select * from foo where bar = 2 or name ='a' and bar >= 0" ) ) . execute () ; assertEquals ( qResult . size () , 2 ) ; assertEquals ( indexUsages ( db ) , ( jdwejfrjigqdseylgaap + 2 ) ) ; }

line_index: 557
bug_before_refactoring: x < 10 <s> private void SendFileContent ( java.net.Socket conn , java.io.InputStream fileIs ) throws java.io.IOException { java.io.OutputStream os = conn . getOutputStream () ; byte [] b = new byte [ 1024 ] ; int x = fileIs . read ( b ) ; while ( x != ( - 1 ) ) { if ( x < 10 ) { b = java.util.Arrays . copyOf ( b , x ) ; } os . write ( b ) ; x = fileIs . read ( b ) ; } } <s> Fixed few errors
bug_after_refactoring: pocpfymimocpkmanivdb < 10 <s> private void SendFileContent ( java.net.Socket conn , java.io.InputStream fileIs ) throws java.io.IOException { java.io.OutputStream os = conn . getOutputStream () ; byte [] b = new byte [ 1024 ] ; int x = fileIs . read ( b ) ; while ( x != ( - 1 ) ) { if ( pocpfymimocpkmanivdb < 10 ) { b = java.util.Arrays . copyOf ( b , x ) ; } os . write ( b ) ; x = fileIs . read ( b ) ; } } <s> Fixed few errors
fix_before_refactoring: x < 1024
fix_after_refactoring: pocpfymimocpkmanivdb < 1024
√ fix_prediction_before: x < 1024
√ fix_prediction_after: pocpfymimocpkmanivdb < 1024

line_index: 587
bug_before_refactoring: switch ( base ) { case 'A' : intVal = 0 ; break; case 'C' : intVal = 1 ; break; case 'G' : intVal = 2 ; break; case 'T' : intVal = 3 ; break; case 'N' : intVal = 4 ; default: throw new java.lang.IllegalArgumentException ( ( "Invalid character: " + base ) ) ; } <s> public int base2int ( char base ) { int intVal = - 1 ; switch ( base ) { case 'A' : intVal = 0 ; break; case 'C' : intVal = 1 ; break; case 'G' : intVal = 2 ; break; case 'T' : intVal = 3 ; break; case 'N' : intVal = 4 ; default: throw new java.lang.IllegalArgumentException ( ( "Invalid character: " + base ) ) ; } return intVal ; } <s> Fixed minor bugs in WildcardKmerUtils
bug_after_refactoring: switch ( base ) { case 'A' : mistbkdyqjothjgvekvo = 0 ; break; case 'C' : mistbkdyqjothjgvekvo = 1 ; break; case 'G' : mistbkdyqjothjgvekvo = 2 ; break; case 'T' : mistbkdyqjothjgvekvo = 3 ; break; case 'N' : mistbkdyqjothjgvekvo = 4 ; default: throw new java.lang.IllegalArgumentException ( ( "Invalid character: " + base ) ) ; } <s> public int base2int ( char base ) { int intVal = - 1 ; switch ( base ) { case 'A' : mistbkdyqjothjgvekvo = 0 ; break; case 'C' : mistbkdyqjothjgvekvo = 1 ; break; case 'G' : mistbkdyqjothjgvekvo = 2 ; break; case 'T' : mistbkdyqjothjgvekvo = 3 ; break; case 'N' : mistbkdyqjothjgvekvo = 4 ; default: throw new java.lang.IllegalArgumentException ( ( "Invalid character: " + base ) ) ; } return intVal ; } <s> Fixed minor bugs in WildcardKmerUtils
fix_before_refactoring: switch ( base ) { case 'A' : intVal = 0 ; break; case 'C' : intVal = 1 ; break; case 'G' : intVal = 2 ; break; case 'T' : intVal = 3 ; break; case 'N' : intVal = 4 ; break; default: throw new java.lang.IllegalArgumentException ( ( "Invalid character: " + base ) ) ; }
fix_after_refactoring: switch ( base ) { case 'A' : mistbkdyqjothjgvekvo = 0 ; break; case 'C' : mistbkdyqjothjgvekvo = 1 ; break; case 'G' : mistbkdyqjothjgvekvo = 2 ; break; case 'T' : mistbkdyqjothjgvekvo = 3 ; break; case 'N' : mistbkdyqjothjgvekvo = 4 ; break; default: throw new java.lang.IllegalArgumentException ( ( "Invalid character: " + base ) ) ; }
√ fix_prediction_before: switch ( base ) { case 'A' : intVal = 0 ; break; case 'C' : intVal = 1 ; break; case 'G' : intVal = 2 ; break; case 'T' : intVal = 3 ; break; case 'N' : intVal = 4 ; break; default: throw new java.lang.IllegalArgumentException ( ( "Invalid character: " + base ) ) ; }
√ fix_prediction_after: switch ( base ) { case 'A' : mistbkdyqjothjgvekvo = 0 ; break; case 'C' : mistbkdyqjothjgvekvo = 1 ; break; case 'G' : mistbkdyqjothjgvekvo = 2 ; break; case 'T' : mistbkdyqjothjgvekvo = 3 ; break; case 'N' : mistbkdyqjothjgvekvo = 4 ; break; default: throw new java.lang.IllegalArgumentException ( ( "Invalid character: " + base ) ) ; }

line_index: 628
bug_before_refactoring: newId != 1 <s> public boolean insertBudget ( final java.lang.String name , final int max ) { android.database.sqlite.SQLiteDatabase db = getWritableDatabase () ; android.content.ContentValues contentValues = new android.content.ContentValues () ; contentValues . put ( protect.budgetwatch.DBHelper.BudgetDbIds.NAME , name ) ; contentValues . put ( protect.budgetwatch.DBHelper.BudgetDbIds.MAX , max ) ; final long newId = db . insert ( protect.budgetwatch.DBHelper.BudgetDbIds.TABLE , null , contentValues ) ; return newId != 1 ; } <s> Fix value checked to indicate an error  '1' is a perfectly valid value. Instead  '-1' indicates an error.
bug_after_refactoring: qfqpzgdyvywmcpwubeom != 1 <s> public boolean insertBudget ( final java.lang.String name , final int max ) { android.database.sqlite.SQLiteDatabase db = getWritableDatabase () ; android.content.ContentValues contentValues = new android.content.ContentValues () ; contentValues . put ( protect.budgetwatch.DBHelper.BudgetDbIds.NAME , name ) ; contentValues . put ( protect.budgetwatch.DBHelper.BudgetDbIds.MAX , max ) ; final long newId = db . insert ( protect.budgetwatch.DBHelper.BudgetDbIds.TABLE , null , contentValues ) ; return qfqpzgdyvywmcpwubeom != 1 ; } <s> Fix value checked to indicate an error  '1' is a perfectly valid value. Instead  '-1' indicates an error.
fix_before_refactoring: newId != ( - 1 )
fix_after_refactoring: qfqpzgdyvywmcpwubeom != ( - 1 )
√ fix_prediction_before: newId != ( - 1 )
√ fix_prediction_after: qfqpzgdyvywmcpwubeom != ( - 1 )

line_index: 631
bug_before_refactoring: { int i = 0 ; int count = 0 ; for ( i = 0 ; i < ( board.length ) ; i ++ ) { if ( addQueen ( i , col ) ) { if ( ( col > ( ( board [ 0 ] . length ) - 2 ) ) || ( solveH ( ( col + 1 ) ) ) ) { return true ; } else { removeQueen ( i , col ) ; } } } return false ; } <s> private boolean solveH ( int col ) { int i = 0 ; int count = 0 ; for ( i = 0 ; i < ( board.length ) ; i ++ ) { if ( addQueen ( i , col ) ) { if ( ( col > ( ( board [ 0 ] . length ) - 2 ) ) || ( solveH ( ( col + 1 ) ) ) ) { return true ; } else { removeQueen ( i , col ) ; } } } return false ; } <s> fixed countsolutions i rlly want to add exclamation marks but if i do github will return an error
bug_after_refactoring: { int xiujuiclojqdduoczpfv = 0 ; int brikigzrufpzpmpsuryc = 0 ; for ( xiujuiclojqdduoczpfv = 0 ; xiujuiclojqdduoczpfv < ( board.length ) ; xiujuiclojqdduoczpfv ++ ) { if ( addQueen ( xiujuiclojqdduoczpfv , col ) ) { if ( ( col > ( ( board [ 0 ] . length ) - 2 ) ) || ( solveH ( ( col + 1 ) ) ) ) { return true ; } else { removeQueen ( xiujuiclojqdduoczpfv , col ) ; } } } return false ; } <s> private boolean solveH ( int col ) { int xiujuiclojqdduoczpfv = 0 ; int brikigzrufpzpmpsuryc = 0 ; for ( xiujuiclojqdduoczpfv = 0 ; xiujuiclojqdduoczpfv < ( board.length ) ; xiujuiclojqdduoczpfv ++ ) { if ( addQueen ( xiujuiclojqdduoczpfv , col ) ) { if ( ( col > ( ( board [ 0 ] . length ) - 2 ) ) || ( solveH ( ( col + 1 ) ) ) ) { return true ; } else { removeQueen ( xiujuiclojqdduoczpfv , col ) ; } } } return false ; } <s> fixed countsolutions i rlly want to add exclamation marks but if i do github will return an error
fix_before_refactoring: { int i = 0 ; for ( i = 0 ; i < ( board.length ) ; i ++ ) { if ( addQueen ( i , col ) ) { if ( ( col > ( ( board [ 0 ] . length ) - 2 ) ) || ( solveH ( ( col + 1 ) ) ) ) { return true ; } else { removeQueen ( i , col ) ; } } } return false ; }
fix_after_refactoring: { int xiujuiclojqdduoczpfv = 0 ; for ( xiujuiclojqdduoczpfv = 0 ; xiujuiclojqdduoczpfv < ( board.length ) ; xiujuiclojqdduoczpfv ++ ) { if ( addQueen ( xiujuiclojqdduoczpfv , col ) ) { if ( ( col > ( ( board [ 0 ] . length ) - 2 ) ) || ( solveH ( ( col + 1 ) ) ) ) { return true ; } else { removeQueen ( xiujuiclojqdduoczpfv , col ) ; } } } return false ; }
√ fix_prediction_before: { int i = 0 ; for ( i = 0 ; i < ( board.length ) ; i ++ ) { if ( addQueen ( i , col ) ) { if ( ( col > ( ( board [ 0 ] . length ) - 2 ) ) || ( solveH ( ( col + 1 ) ) ) ) { return true ; } else { removeQueen ( i , col ) ; } } } return false ; }
√ fix_prediction_after: { int xiujuiclojqdduoczpfv = 0 ; for ( xiujuiclojqdduoczpfv = 0 ; xiujuiclojqdduoczpfv < ( board.length ) ; xiujuiclojqdduoczpfv ++ ) { if ( addQueen ( xiujuiclojqdduoczpfv , col ) ) { if ( ( col > ( ( board [ 0 ] . length ) - 2 ) ) || ( solveH ( ( col + 1 ) ) ) ) { return true ; } else { removeQueen ( xiujuiclojqdduoczpfv , col ) ; } } } return false ; }

line_index: 651
bug_before_refactoring: c = false <s> public static void main ( java.lang.String [] args ) { boolean a = false ; boolean b = false ; boolean c = false ; boolean p = ( ( ( a || b ) || c ) && ( ( ( ! a ) || b ) || c ) ) && ( ( ( ! a ) || ( ! b ) ) || c ) ; java.lang.System.out . println ( p ) ; } <s> fixed bug in case split
bug_after_refactoring: pssrntssnykjmmscrysz = false <s> public static void main ( java.lang.String [] args ) { boolean a = false ; boolean b = false ; boolean pssrntssnykjmmscrysz = false ; boolean p = ( ( ( a || b ) || c ) && ( ( ( ! a ) || b ) || c ) ) && ( ( ( ! a ) || ( ! b ) ) || c ) ; java.lang.System.out . println ( p ) ; } <s> fixed bug in case split
fix_before_refactoring: c = true
fix_after_refactoring: pssrntssnykjmmscrysz = true
√ fix_prediction_before: c = true
√ fix_prediction_after: pssrntssnykjmmscrysz = true

line_index: 653
bug_before_refactoring: try { int balance = getOrZero ( userId ) ; balances . put ( userId , ( balance + value ) ) ; writeLog ( "DEPOSIT" , userId , "" , value ) ; return true ; } finally { RWLock . writeLock () . unlock () ; } <s> public boolean deposit ( java.lang.String userId , int value ) { if ( value < 0 ) return false ; RWLock . writeLock () . lock () ; try { int balance = getOrZero ( userId ) ; balances . put ( userId , ( balance + value ) ) ; writeLog ( "DEPOSIT" , userId , "" , value ) ; return true ; } finally { RWLock . writeLock () . unlock () ; } } <s> Fix the bug: write the log but not return true
bug_after_refactoring: try { int pqhawkfuzjcvtphstfbu = getOrZero ( userId ) ; balances . put ( userId , ( pqhawkfuzjcvtphstfbu + value ) ) ; writeLog ( "DEPOSIT" , userId , "" , value ) ; return true ; } finally { RWLock . writeLock () . unlock () ; } <s> public boolean deposit ( java.lang.String userId , int value ) { if ( value < 0 ) return false ; RWLock . writeLock () . lock () ; try { int pqhawkfuzjcvtphstfbu = getOrZero ( userId ) ; balances . put ( userId , ( pqhawkfuzjcvtphstfbu + value ) ) ; writeLog ( "DEPOSIT" , userId , "" , value ) ; return true ; } finally { RWLock . writeLock () . unlock () ; } } <s> Fix the bug: write the log but not return true
fix_before_refactoring: try { int balance = getOrZero ( userId ) ; balances . put ( userId , ( balance + value ) ) ; return true ; } finally { writeLog ( "DEPOSIT" , userId , "" , value ) ; RWLock . writeLock () . unlock () ; }
fix_after_refactoring: try { int pqhawkfuzjcvtphstfbu = getOrZero ( userId ) ; balances . put ( userId , ( pqhawkfuzjcvtphstfbu + value ) ) ; return true ; } finally { writeLog ( "DEPOSIT" , userId , "" , value ) ; RWLock . writeLock () . unlock () ; }
√ fix_prediction_before: try { int balance = getOrZero ( userId ) ; balances . put ( userId , ( balance + value ) ) ; return true ; } finally { writeLog ( "DEPOSIT" , userId , "" , value ) ; RWLock . writeLock () . unlock () ; }
√ fix_prediction_after: try { int pqhawkfuzjcvtphstfbu = getOrZero ( userId ) ; balances . put ( userId , ( pqhawkfuzjcvtphstfbu + value ) ) ; return true ; } finally { writeLog ( "DEPOSIT" , userId , "" , value ) ; RWLock . writeLock () . unlock () ; }

line_index: 670
bug_before_refactoring: isMyOwnMsg = newItem . isIncomingMessage () <s> @ java.lang.Override public void onMessageReceived ( @ android.support.annotation.NonNull com.criptext.comunication.MOKMessage message ) { com.criptext.monkeychatandroid.models.MessageItem newItem = processNewMessage ( message ) ; boolean isMyOwnMsg = newItem . isIncomingMessage () ; updateConversation ( newItem . getConversationId () , com.criptext.monkeychatandroid.models.DatabaseHandler . getSecondaryTextByMessageType ( newItem , false ) , ( isMyOwnMsg ? MonkeyConversation.ConversationStatus.deliveredMessage : MonkeyConversation.ConversationStatus.receivedMessage ) , ( isMyOwnMsg ? 0 : 1 ) , message . getDatetimeorder () , 0L ) ; } <s> dummy bug fix
bug_after_refactoring: qaefgndatokxfvykjjfx = newItem . isIncomingMessage () <s> @ java.lang.Override public void onMessageReceived ( @ android.support.annotation.NonNull com.criptext.comunication.MOKMessage message ) { com.criptext.monkeychatandroid.models.MessageItem newItem = processNewMessage ( message ) ; boolean qaefgndatokxfvykjjfx = newItem . isIncomingMessage () ; updateConversation ( newItem . getConversationId () , com.criptext.monkeychatandroid.models.DatabaseHandler . getSecondaryTextByMessageType ( newItem , false ) , ( isMyOwnMsg ? MonkeyConversation.ConversationStatus.deliveredMessage : MonkeyConversation.ConversationStatus.receivedMessage ) , ( isMyOwnMsg ? 0 : 1 ) , message . getDatetimeorder () , 0L ) ; } <s> dummy bug fix
fix_before_refactoring: isMyOwnMsg = ! ( newItem . isIncomingMessage () )
fix_after_refactoring: qaefgndatokxfvykjjfx = ! ( newItem . isIncomingMessage () )
√ fix_prediction_before: isMyOwnMsg = ! ( newItem . isIncomingMessage () )
√ fix_prediction_after: qaefgndatokxfvykjjfx = ! ( newItem . isIncomingMessage () )

line_index: 677
bug_before_refactoring: { java.lang.System.out . format ( "%d is between %d and %d%n" , i , lowerBound , upperBound ) ; max = java.lang.Math . max ( A [ i ] , max ) ; } <s> public static int maxInBounds ( int [] A , int lowerBound , int upperBound ) { int max = 0 ; int [] bounds = new int [] { lowerBound , upperBound } ; for ( int i = MyMath . min ( bounds ) ; i < ( ( MyMath . max ( bounds ) ) + 1 ) ; i ++ ) { java.lang.System.out . format ( "%d is between %d and %d%n" , i , lowerBound , upperBound ) ; max = java.lang.Math . max ( A [ i ] , max ) ; } return max ; } <s> fixed the bug with the first bar not being recorded in controller
bug_after_refactoring: { java.lang.System.out . format ( "%d is between %d and %d%n" , i , lowerBound , upperBound ) ; opxgfwvmgatkbnrlufph = java.lang.Math . opxgfwvmgatkbnrlufph ( A [ i ] , opxgfwvmgatkbnrlufph ) ; } <s> public static int maxInBounds ( int [] A , int lowerBound , int upperBound ) { int max = 0 ; int [] bounds = new int [] { lowerBound , upperBound } ; for ( int i = MyMath . min ( bounds ) ; i < ( ( MyMath . max ( bounds ) ) + 1 ) ; i ++ ) { java.lang.System.out . format ( "%d is between %d and %d%n" , i , lowerBound , upperBound ) ; opxgfwvmgatkbnrlufph = java.lang.Math . opxgfwvmgatkbnrlufph ( A [ i ] , opxgfwvmgatkbnrlufph ) ; } return max ; } <s> fixed the bug with the first bar not being recorded in controller
fix_before_refactoring: { max = java.lang.Math . max ( A [ i ] , max ) ; }
fix_after_refactoring: { opxgfwvmgatkbnrlufph = java.lang.Math . opxgfwvmgatkbnrlufph ( A [ i ] , opxgfwvmgatkbnrlufph ) ; }
√ fix_prediction_before: { max = java.lang.Math . max ( A [ i ] , max ) ; }
√ fix_prediction_after: { opxgfwvmgatkbnrlufph = java.lang.Math . opxgfwvmgatkbnrlufph ( A [ i ] , opxgfwvmgatkbnrlufph ) ; }

line_index: 692
bug_before_refactoring: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean deleteResult = thisFile . delete () ; java.lang.System.out . println ( deleteResult ) ; return wanted ; } <s> @ java.lang.Override public com.edu.nju.asi.service.serviceImpl.Case uploadOnline ( org.springframework.web.multipart.MultipartFile uploadedFile ) throws java.io.IOException { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean deleteResult = thisFile . delete () ; java.lang.System.out . println ( deleteResult ) ; return wanted ; } <s> Fix: bugs in XMLSereviceImpl
bug_after_refactoring: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean dmnzufziwwhgensrxzbj = thisFile . delete () ; java.lang.System.out . println ( dmnzufziwwhgensrxzbj ) ; return wanted ; } <s> @ java.lang.Override public com.edu.nju.asi.service.serviceImpl.Case uploadOnline ( org.springframework.web.multipart.MultipartFile uploadedFile ) throws java.io.IOException { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean dmnzufziwwhgensrxzbj = thisFile . delete () ; java.lang.System.out . println ( dmnzufziwwhgensrxzbj ) ; return wanted ; } <s> Fix: bugs in XMLSereviceImpl
fix_before_refactoring: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean deleteResult = thisFile . delete () ; return wanted ; }
fix_after_refactoring: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean dmnzufziwwhgensrxzbj = thisFile . delete () ; return wanted ; }
√ fix_prediction_before: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean deleteResult = thisFile . delete () ; return wanted ; }
√ fix_prediction_after: { if ( uploadedFile . isEmpty () ) { return null ; } java.lang.String thisPath = uploadedFile . getName () ; java.io.File thisFile = new java.io.File ( thisPath ) ; uploadedFile . transferTo ( thisFile ) ; com.edu.nju.asi.service.serviceImpl.Case wanted = parseXML ( thisPath ) ; boolean dmnzufziwwhgensrxzbj = thisFile . delete () ; return wanted ; }

line_index: 706
bug_before_refactoring: if ( ( armor > 0 ) || ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; } <s> public int hit ( int armor ) { int damage ; if ( ( armor > 0 ) || ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; } return damage < 0 ? 0 : damage ; } <s> Final Commit of project one. Includes updated main for testing all weapons  debugged weapon factory  and fixed Axe ignoring armor when they werent supposed to bug.   -By Kristopher Doidge
bug_after_refactoring: if ( ( armor > 0 ) || ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; } <s> public int hit ( int armor ) { int damage ; if ( ( armor > 0 ) || ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; } return damage < 0 ? 0 : damage ; } <s> Final Commit of project one. Includes updated main for testing all weapons  debugged weapon factory  and fixed Axe ignoring armor when they werent supposed to bug.   -By Kristopher Doidge
fix_before_refactoring: if ( ( armor > 0 ) && ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; }
fix_after_refactoring: if ( ( armor > 0 ) && ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; }
√ fix_prediction_before: if ( ( armor > 0 ) && ( armor < 20 ) ) { damage = this . DAMAGE ; } else { damage = ( this . DAMAGE ) - armor ; }
√ fix_prediction_after: if ( ( armor > 0 ) && ( armor < 20 ) ) { hsmvtpdxxwlnqiprdbyt = this . DAMAGE ; } else { hsmvtpdxxwlnqiprdbyt = ( this . DAMAGE ) - armor ; }

line_index: 712
bug_before_refactoring: { int prog = seekBar . getProgress () ; this . warmth = prog + 1 ; java.lang.System.out . println ( R.string.recapHot ) ; this . recapWarmth . setText ( android.text.Html . fromHtml ( ( ( ( "<b>" + ( res . getString ( R.string.recapHot ) ) ) + "</b>" ) + ( hotWordArray [ prog ] ) ) ) ) ; } <s> @ java.lang.Override public void onClick ( android.content.DialogInterface dialog , int which ) { int prog = seekBar . getProgress () ; this . warmth = prog + 1 ; java.lang.System.out . println ( R.string.recapHot ) ; this . recapWarmth . setText ( android.text.Html . fromHtml ( ( ( ( "<b>" + ( res . getString ( R.string.recapHot ) ) ) + "</b>" ) + ( hotWordArray [ prog ] ) ) ) ) ; } <s> Fix minor text update bug
bug_after_refactoring: { int ywytttvbfbtesgiokdol = seekBar . getProgress () ; this . warmth = ywytttvbfbtesgiokdol + 1 ; java.lang.System.out . println ( R.string.recapHot ) ; this . recapWarmth . setText ( android.text.Html . fromHtml ( ( ( ( "<b>" + ( res . getString ( R.string.recapHot ) ) ) + "</b>" ) + ( hotWordArray [ ywytttvbfbtesgiokdol ] ) ) ) ) ; } <s> @ java.lang.Override public void onClick ( android.content.DialogInterface dialog , int which ) { int ywytttvbfbtesgiokdol = seekBar . getProgress () ; this . warmth = ywytttvbfbtesgiokdol + 1 ; java.lang.System.out . println ( R.string.recapHot ) ; this . recapWarmth . setText ( android.text.Html . fromHtml ( ( ( ( "<b>" + ( res . getString ( R.string.recapHot ) ) ) + "</b>" ) + ( hotWordArray [ ywytttvbfbtesgiokdol ] ) ) ) ) ; } <s> Fix minor text update bug
fix_before_refactoring: { int prog = seekBar . getProgress () ; this . warmth = prog + 1 ; this . recapWarmth . setText ( android.text.Html . fromHtml ( ( ( ( "<b>" + ( res . getString ( R.string.recapHot ) ) ) + "</b>" ) + ( hotWordArray [ prog ] ) ) ) ) ; }
fix_after_refactoring: { int ywytttvbfbtesgiokdol = seekBar . getProgress () ; this . warmth = ywytttvbfbtesgiokdol + 1 ; this . recapWarmth . setText ( android.text.Html . fromHtml ( ( ( ( "<b>" + ( res . getString ( R.string.recapHot ) ) ) + "</b>" ) + ( hotWordArray [ ywytttvbfbtesgiokdol ] ) ) ) ) ; }
√ fix_prediction_before: { int prog = seekBar . getProgress () ; this . warmth = prog + 1 ; this . recapWarmth . setText ( android.text.Html . fromHtml ( ( ( ( "<b>" + ( res . getString ( R.string.recapHot ) ) ) + "</b>" ) + ( hotWordArray [ prog ] ) ) ) ) ; }
√ fix_prediction_after: { int ywytttvbfbtesgiokdol = seekBar . getProgress () ; this . warmth = ywytttvbfbtesgiokdol + 1 ; this . recapWarmth . setText ( android.text.Html . fromHtml ( ( ( ( "<b>" + ( res . getString ( R.string.recapHot ) ) ) + "</b>" ) + ( hotWordArray [ ywytttvbfbtesgiokdol ] ) ) ) ) ; }

line_index: 728
bug_before_refactoring: EMPTY_STACK_VALUE = - 1 <s> @ org.junit.Test public void testTop () { edu.kis.vh.stacks.StackFIFO stackObj = new edu.kis.vh.stacks.StackFIFO () ; final int EMPTY_STACK_VALUE = - 1 ; int result = stackObj . top () ; org.junit.Assert . assertEquals ( EMPTY_STACK_VALUE , result ) ; int testValue = 4 ; stackObj . push ( testValue ) ; int testValue1 = 5 ; stackObj . push ( testValue1 ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; } <s> fixed EMPTY_STACK_VALUE issues
bug_after_refactoring: ofontnxwkzmtnxhgkmst = - 1 <s> @ org.junit.Test public void testTop () { edu.kis.vh.stacks.StackFIFO stackObj = new edu.kis.vh.stacks.StackFIFO () ; final int ofontnxwkzmtnxhgkmst = - 1 ; int result = stackObj . top () ; org.junit.Assert . assertEquals ( EMPTY_STACK_VALUE , result ) ; int testValue = 4 ; stackObj . push ( testValue ) ; int testValue1 = 5 ; stackObj . push ( testValue1 ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; result = stackObj . top () ; org.junit.Assert . assertEquals ( testValue , result ) ; } <s> fixed EMPTY_STACK_VALUE issues
fix_before_refactoring: EMPTY_STACK_VALUE = 0
fix_after_refactoring: ofontnxwkzmtnxhgkmst = 0
√ fix_prediction_before: EMPTY_STACK_VALUE = 0
√ fix_prediction_after: ofontnxwkzmtnxhgkmst = 0

line_index: 736
bug_before_refactoring: { int idx = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( idx ) ; latestInst . setRelatedObjId ( objId ) ; java.lang.System.out . println ( ( ( ( "Update obj id: " + latestInst ) + " " ) + objId ) ) ; } <s> public void updateObjIdOnStack ( int objId , int traceBack ) { int idx = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( idx ) ; latestInst . setRelatedObjId ( objId ) ; java.lang.System.out . println ( ( ( ( "Update obj id: " + latestInst ) + " " ) + objId ) ) ; } <s> Fix all bugs for avro   Former-commit-id: b6d6e8db19fc29f7b5705a076c019fc75eb98547
bug_after_refactoring: { int eofxgzxevhfglnpwwhfv = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( eofxgzxevhfglnpwwhfv ) ; latestInst . setRelatedObjId ( objId ) ; java.lang.System.out . println ( ( ( ( "Update obj id: " + latestInst ) + " " ) + objId ) ) ; } <s> public void updateObjIdOnStack ( int objId , int traceBack ) { int eofxgzxevhfglnpwwhfv = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( eofxgzxevhfglnpwwhfv ) ; latestInst . setRelatedObjId ( objId ) ; java.lang.System.out . println ( ( ( ( "Update obj id: " + latestInst ) + " " ) + objId ) ) ; } <s> Fix all bugs for avro   Former-commit-id: b6d6e8db19fc29f7b5705a076c019fc75eb98547
fix_before_refactoring: { int idx = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( idx ) ; latestInst . setRelatedObjId ( objId ) ; }
fix_after_refactoring: { int eofxgzxevhfglnpwwhfv = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( eofxgzxevhfglnpwwhfv ) ; latestInst . setRelatedObjId ( objId ) ; }
√ fix_prediction_before: { int idx = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( idx ) ; latestInst . setRelatedObjId ( objId ) ; }
√ fix_prediction_after: { int eofxgzxevhfglnpwwhfv = ( ( this . stackSimulator . size () ) - 1 ) - traceBack ; edu.columbia.psl.cc.pojo.InstNode latestInst = this . stackSimulator . get ( eofxgzxevhfglnpwwhfv ) ; latestInst . setRelatedObjId ( objId ) ; }

line_index: 753
bug_before_refactoring: protected static java.lang.String readHeaderString ( byte [] buffer ) { int i = 0 ; while ( ( i < ( buffer.length ) ) && ( ! ( webserver.ParseTools . endOfHeader ( buffer , ( i - 1 ) ) ) ) ) { i ++ ; } return new java.lang.String ( buffer , 0 , i ) ; } <s> protected static java.lang.String readHeaderString ( byte [] buffer ) { int i = 0 ; while ( ( i < ( buffer.length ) ) && ( ! ( webserver.ParseTools . endOfHeader ( buffer , ( i - 1 ) ) ) ) ) { i ++ ; } return new java.lang.String ( buffer , 0 , i ) ; } <s> Fixed error naming bug
bug_after_refactoring: protected static java.lang.String readHeaderString ( byte [] buffer ) { int mrprbtqrbkgyqeoydvzi = 0 ; while ( ( mrprbtqrbkgyqeoydvzi < ( buffer.length ) ) && ( ! ( webserver.ParseTools . endOfHeader ( buffer , ( mrprbtqrbkgyqeoydvzi - 1 ) ) ) ) ) { mrprbtqrbkgyqeoydvzi ++ ; } return new java.lang.String ( buffer , 0 , mrprbtqrbkgyqeoydvzi ) ; } <s> protected static java.lang.String readHeaderString ( byte [] buffer ) { int mrprbtqrbkgyqeoydvzi = 0 ; while ( ( mrprbtqrbkgyqeoydvzi < ( buffer.length ) ) && ( ! ( webserver.ParseTools . endOfHeader ( buffer , ( mrprbtqrbkgyqeoydvzi - 1 ) ) ) ) ) { mrprbtqrbkgyqeoydvzi ++ ; } return new java.lang.String ( buffer , 0 , mrprbtqrbkgyqeoydvzi ) ; } <s> Fixed error naming bug
fix_before_refactoring: public static java.lang.String readHeaderString ( byte [] buffer ) { int i = 0 ; while ( ( i < ( buffer.length ) ) && ( ! ( webserver.ParseTools . endOfHeader ( buffer , ( i - 1 ) ) ) ) ) { i ++ ; } return new java.lang.String ( buffer , 0 , i ) ; }
fix_after_refactoring: public static java.lang.String readHeaderString ( byte [] buffer ) { int mrprbtqrbkgyqeoydvzi = 0 ; while ( ( mrprbtqrbkgyqeoydvzi < ( buffer.length ) ) && ( ! ( webserver.ParseTools . endOfHeader ( buffer , ( mrprbtqrbkgyqeoydvzi - 1 ) ) ) ) ) { mrprbtqrbkgyqeoydvzi ++ ; } return new java.lang.String ( buffer , 0 , mrprbtqrbkgyqeoydvzi ) ; }
√ fix_prediction_before: public static java.lang.String readHeaderString ( byte [] buffer ) { int i = 0 ; while ( ( i < ( buffer.length ) ) && ( ! ( webserver.ParseTools . endOfHeader ( buffer , ( i - 1 ) ) ) ) ) { i ++ ; } return new java.lang.String ( buffer , 0 , i ) ; }
√ fix_prediction_after: public static java.lang.String readHeaderString ( byte [] buffer ) { int mrprbtqrbkgyqeoydvzi = 0 ; while ( ( mrprbtqrbkgyqeoydvzi < ( buffer.length ) ) && ( ! ( webserver.ParseTools . endOfHeader ( buffer , ( mrprbtqrbkgyqeoydvzi - 1 ) ) ) ) ) { mrprbtqrbkgyqeoydvzi ++ ; } return new java.lang.String ( buffer , 0 , mrprbtqrbkgyqeoydvzi ) ; }

line_index: 768
bug_before_refactoring: if ( answer == userEnterAnswer ) messageResId = R.string.correct_toast ; else messageResId = R.string.incorrect_toast ; <s> private void checkAnswer ( java.lang.String userEnterAnswer ) { java.lang.String answer = myHiraganaSet [ myCurrentIndex ] . getMyAnswer () ; int messageResId = 0 ; if ( answer == userEnterAnswer ) messageResId = R.string.correct_toast ; else messageResId = R.string.incorrect_toast ; android.widget.Toast . makeText ( this , messageResId , Toast.LENGTH_SHORT ) . show () ; } <s> Bug fixed
bug_after_refactoring: if ( answer == userEnterAnswer ) hugitfxkvulahoquteke = R.string.correct_toast ; else hugitfxkvulahoquteke = R.string.incorrect_toast ; <s> private void checkAnswer ( java.lang.String userEnterAnswer ) { java.lang.String answer = myHiraganaSet [ myCurrentIndex ] . getMyAnswer () ; int messageResId = 0 ; if ( answer == userEnterAnswer ) hugitfxkvulahoquteke = R.string.correct_toast ; else hugitfxkvulahoquteke = R.string.incorrect_toast ; android.widget.Toast . makeText ( this , messageResId , Toast.LENGTH_SHORT ) . show () ; } <s> Bug fixed
fix_before_refactoring: if ( answer . equals ( userEnterAnswer ) ) messageResId = R.string.correct_toast ; else messageResId = R.string.incorrect_toast ;
fix_after_refactoring: if ( answer . equals ( userEnterAnswer ) ) hugitfxkvulahoquteke = R.string.correct_toast ; else hugitfxkvulahoquteke = R.string.incorrect_toast ;
√ fix_prediction_before: if ( answer . equals ( userEnterAnswer ) ) messageResId = R.string.correct_toast ; else messageResId = R.string.incorrect_toast ;
√ fix_prediction_after: if ( answer . equals ( userEnterAnswer ) ) hugitfxkvulahoquteke = R.string.correct_toast ; else hugitfxkvulahoquteke = R.string.incorrect_toast ;

line_index: 787
bug_before_refactoring: { int py = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { py -= 110 ; py /= 50 ; } else { py -= 15 + 50 ; py /= 50 ; } java.lang.System.out . println ( py ) ; return py ; } <s> public int extractY ( int y ) { int py = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { py -= 110 ; py /= 50 ; } else { py -= 15 + 50 ; py /= 50 ; } java.lang.System.out . println ( py ) ; return py ; } <s> Fixed a bug; Code cleanup
bug_after_refactoring: { int pmeplteizahfgiswuedb = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { pmeplteizahfgiswuedb -= 110 ; pmeplteizahfgiswuedb /= 50 ; } else { pmeplteizahfgiswuedb -= 15 + 50 ; pmeplteizahfgiswuedb /= 50 ; } java.lang.System.out . println ( pmeplteizahfgiswuedb ) ; return pmeplteizahfgiswuedb ; } <s> public int extractY ( int y ) { int pmeplteizahfgiswuedb = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { pmeplteizahfgiswuedb -= 110 ; pmeplteizahfgiswuedb /= 50 ; } else { pmeplteizahfgiswuedb -= 15 + 50 ; pmeplteizahfgiswuedb /= 50 ; } java.lang.System.out . println ( pmeplteizahfgiswuedb ) ; return pmeplteizahfgiswuedb ; } <s> Fixed a bug; Code cleanup
fix_before_refactoring: { int py = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { py -= 110 ; py /= 50 ; } else { py -= 15 + 50 ; py /= 50 ; } return py ; }
fix_after_refactoring: { int pmeplteizahfgiswuedb = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { pmeplteizahfgiswuedb -= 110 ; pmeplteizahfgiswuedb /= 50 ; } else { pmeplteizahfgiswuedb -= 15 + 50 ; pmeplteizahfgiswuedb /= 50 ; } return pmeplteizahfgiswuedb ; }
√ fix_prediction_before: { int py = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { py -= 110 ; py /= 50 ; } else { py -= 15 + 50 ; py /= 50 ; } return py ; }
√ fix_prediction_after: { int pmeplteizahfgiswuedb = ( y + ( UserInterface.Accordpanel.YP ) ) + 60 ; if ( curAcc . isSixakk () ) { pmeplteizahfgiswuedb -= 110 ; pmeplteizahfgiswuedb /= 50 ; } else { pmeplteizahfgiswuedb -= 15 + 50 ; pmeplteizahfgiswuedb /= 50 ; } return pmeplteizahfgiswuedb ; }

line_index: 801
bug_before_refactoring: { int selected_row = - 1 ; java.awt.Point p = e . getPoint () ; java.lang.System.out . println ( ( ( ( "Manowitz left page(x,y): " + ( p.x ) ) + ", " ) + ( p.y ) ) ) ; java.awt.FontMetrics fm = right_page . getFontMetrics ( right_page . getFont () ) ; selected_row = ( ( p.y ) / ( fm . getHeight () ) ) + 1 ; return selected_row ; } <s> public int selectRow ( java.awt.event.MouseEvent e ) { int selected_row = - 1 ; java.awt.Point p = e . getPoint () ; java.lang.System.out . println ( ( ( ( "Manowitz left page(x,y): " + ( p.x ) ) + ", " ) + ( p.y ) ) ) ; java.awt.FontMetrics fm = right_page . getFontMetrics ( right_page . getFont () ) ; selected_row = ( ( p.y ) / ( fm . getHeight () ) ) + 1 ; return selected_row ; } <s> Fix Manowitz file names construction  And comment out debug printlns.    src/gui/Manowitz.java
bug_after_refactoring: { int phtqbghzfmofgrynamba = - 1 ; java.awt.Point p = e . getPoint () ; java.lang.System.out . println ( ( ( ( "Manowitz left page(x,y): " + ( p.x ) ) + ", " ) + ( p.y ) ) ) ; java.awt.FontMetrics fm = right_page . getFontMetrics ( right_page . getFont () ) ; phtqbghzfmofgrynamba = ( ( p.y ) / ( fm . getHeight () ) ) + 1 ; return phtqbghzfmofgrynamba ; } <s> public int selectRow ( java.awt.event.MouseEvent e ) { int phtqbghzfmofgrynamba = - 1 ; java.awt.Point p = e . getPoint () ; java.lang.System.out . println ( ( ( ( "Manowitz left page(x,y): " + ( p.x ) ) + ", " ) + ( p.y ) ) ) ; java.awt.FontMetrics fm = right_page . getFontMetrics ( right_page . getFont () ) ; phtqbghzfmofgrynamba = ( ( p.y ) / ( fm . getHeight () ) ) + 1 ; return phtqbghzfmofgrynamba ; } <s> Fix Manowitz file names construction  And comment out debug printlns.    src/gui/Manowitz.java
fix_before_refactoring: { int selected_row = - 1 ; java.awt.Point p = e . getPoint () ; java.awt.FontMetrics fm = right_page . getFontMetrics ( right_page . getFont () ) ; selected_row = ( ( p.y ) / ( fm . getHeight () ) ) + 1 ; return selected_row ; }
fix_after_refactoring: { int phtqbghzfmofgrynamba = - 1 ; java.awt.Point p = e . getPoint () ; java.awt.FontMetrics fm = right_page . getFontMetrics ( right_page . getFont () ) ; phtqbghzfmofgrynamba = ( ( p.y ) / ( fm . getHeight () ) ) + 1 ; return phtqbghzfmofgrynamba ; }
√ fix_prediction_before: { int selected_row = - 1 ; java.awt.Point p = e . getPoint () ; java.awt.FontMetrics fm = right_page . getFontMetrics ( right_page . getFont () ) ; selected_row = ( ( p.y ) / ( fm . getHeight () ) ) + 1 ; return selected_row ; }
√ fix_prediction_after: { int phtqbghzfmofgrynamba = - 1 ; java.awt.Point p = e . getPoint () ; java.awt.FontMetrics fm = right_page . getFontMetrics ( right_page . getFont () ) ; phtqbghzfmofgrynamba = ( ( p.y ) / ( fm . getHeight () ) ) + 1 ; return phtqbghzfmofgrynamba ; }

line_index: 807
bug_before_refactoring: { for ( Utils.DataVector vector : data ) { java.util.List < java.lang.Integer > treePredictions = new java.util.ArrayList ( data . size () ) ; for ( RandomForestHOG.DecisionTree.DecisionTree tree : dTree ) { int curPrediction = tree . classify ( vector ) ; treePredictions . add ( curPrediction ) ; } int forestPrediction = Utils.Helper . getModeInt ( treePredictions ) ; finalPredictions . add ( forestPrediction ) ; } if ( calAccuracy ) { calAccuracy () ; } return finalPredictions ; } <s> public java.util.List < java.lang.Integer > classify ( java.util.List < Utils.DataVector > data , boolean calAccuracy ) { for ( Utils.DataVector vector : data ) { java.util.List < java.lang.Integer > treePredictions = new java.util.ArrayList ( data . size () ) ; for ( RandomForestHOG.DecisionTree.DecisionTree tree : dTree ) { int curPrediction = tree . classify ( vector ) ; treePredictions . add ( curPrediction ) ; } int forestPrediction = Utils.Helper . getModeInt ( treePredictions ) ; finalPredictions . add ( forestPrediction ) ; } if ( calAccuracy ) { calAccuracy () ; } return finalPredictions ; } <s> fill incomplete part when refactoring DecisionTree  fix other bugs
bug_after_refactoring: { for ( Utils.DataVector vector : data ) { java.util.List < java.lang.Integer > treePredictions = new java.util.ArrayList ( data . size () ) ; for ( RandomForestHOG.DecisionTree.DecisionTree tree : dTree ) { int zetzaeraqfniylcgsedk = tree . classify ( vector ) ; treePredictions . add ( zetzaeraqfniylcgsedk ) ; } int ucufvxwpvlzadukbxlkh = Utils.Helper . getModeInt ( treePredictions ) ; finalPredictions . add ( ucufvxwpvlzadukbxlkh ) ; } if ( calAccuracy ) { calAccuracy () ; } return finalPredictions ; } <s> public java.util.List < java.lang.Integer > classify ( java.util.List < Utils.DataVector > data , boolean calAccuracy ) { for ( Utils.DataVector vector : data ) { java.util.List < java.lang.Integer > treePredictions = new java.util.ArrayList ( data . size () ) ; for ( RandomForestHOG.DecisionTree.DecisionTree tree : dTree ) { int zetzaeraqfniylcgsedk = tree . classify ( vector ) ; treePredictions . add ( zetzaeraqfniylcgsedk ) ; } int ucufvxwpvlzadukbxlkh = Utils.Helper . getModeInt ( treePredictions ) ; finalPredictions . add ( ucufvxwpvlzadukbxlkh ) ; } if ( calAccuracy ) { calAccuracy () ; } return finalPredictions ; } <s> fill incomplete part when refactoring DecisionTree  fix other bugs
fix_before_refactoring: { for ( Utils.DataVector vector : data ) { java.util.List < java.lang.Integer > treePredictions = new java.util.ArrayList ( data . size () ) ; for ( RandomForestHOG.DecisionTree.DecisionTree tree : dTree ) { int curPrediction = tree . classify ( vector ) ; treePredictions . add ( curPrediction ) ; } int forestPrediction = Utils.Helper . getModeInt ( treePredictions ) ; finalPredictions . add ( forestPrediction ) ; } return finalPredictions ; }
fix_after_refactoring: { for ( Utils.DataVector vector : data ) { java.util.List < java.lang.Integer > treePredictions = new java.util.ArrayList ( data . size () ) ; for ( RandomForestHOG.DecisionTree.DecisionTree tree : dTree ) { int zetzaeraqfniylcgsedk = tree . classify ( vector ) ; treePredictions . add ( zetzaeraqfniylcgsedk ) ; } int ucufvxwpvlzadukbxlkh = Utils.Helper . getModeInt ( treePredictions ) ; finalPredictions . add ( ucufvxwpvlzadukbxlkh ) ; } return finalPredictions ; }
√ fix_prediction_before: { for ( Utils.DataVector vector : data ) { java.util.List < java.lang.Integer > treePredictions = new java.util.ArrayList ( data . size () ) ; for ( RandomForestHOG.DecisionTree.DecisionTree tree : dTree ) { int curPrediction = tree . classify ( vector ) ; treePredictions . add ( curPrediction ) ; } int forestPrediction = Utils.Helper . getModeInt ( treePredictions ) ; finalPredictions . add ( forestPrediction ) ; } return finalPredictions ; }
√ fix_prediction_after: { for ( Utils.DataVector vector : data ) { java.util.List < java.lang.Integer > treePredictions = new java.util.ArrayList ( data . size () ) ; for ( RandomForestHOG.DecisionTree.DecisionTree tree : dTree ) { int zetzaeraqfniylcgsedk = tree . classify ( vector ) ; treePredictions . add ( zetzaeraqfniylcgsedk ) ; } int ucufvxwpvlzadukbxlkh = Utils.Helper . getModeInt ( treePredictions ) ; finalPredictions . add ( ucufvxwpvlzadukbxlkh ) ; } return finalPredictions ; }

line_index: 818
bug_before_refactoring: if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; } <s> @ java.lang.Override public boolean apply ( @ javax.annotation.Nullable com.gmi.nordborglab.browser.shared.proxy.TraitProxy input ) { if ( input == null ) return true ; boolean isNotFound = true ; for ( com.gmi.nordborglab.browser.shared.proxy.AlleleAssayProxy alleleAssay : input . getObsUnit () . getStock () . getPassport () . getAlleleAssays () ) { if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; } } return isNotFound ; } <s> Fix some bugs regarding the iterator and out of bounds errors
bug_after_refactoring: if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; } <s> @ java.lang.Override public boolean apply ( @ javax.annotation.Nullable com.gmi.nordborglab.browser.shared.proxy.TraitProxy input ) { if ( input == null ) return true ; boolean isNotFound = true ; for ( com.gmi.nordborglab.browser.shared.proxy.AlleleAssayProxy alleleAssay : input . getObsUnit () . getStock () . getPassport () . getAlleleAssays () ) { if ( ( alleleAssay . getId () ) == ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; } } return isNotFound ; } <s> Fix some bugs regarding the iterator and out of bounds errors
fix_before_refactoring: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; }
fix_after_refactoring: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; }
√ fix_prediction_before: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { isNotFound = false ; break; }
√ fix_prediction_after: if ( alleleAssay . getId () . equals ( selectedAlleleAssay . getId () ) ) { ruwhymtbtmywgmvvbcin = false ; break; }

line_index: 853
bug_before_refactoring: { result = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "id" ) ; result ++ ; return result ; } <s> public int getGID () { int result = - 1 ; try { result = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "gid" ) ; return result ; } catch ( java.lang.NumberFormatException ex ) { nationbuilder.lib.Logging.Log . writeInfo ( "gid attribute fetch failed, trying id attribute" ) ; } try { result = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "id" ) ; result ++ ; return result ; } catch ( java.lang.NumberFormatException ex ) { nationbuilder.lib.Logging.Log . writeError ( "Parsing of the Tile GID attribute failed" ) ; return result ; } } <s> NB-16: fixed the problems with the resources not being correctly filled  results in that every visible tile can be claimed
bug_after_refactoring: { ynsnhzvqiququqivpaip = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "id" ) ; ynsnhzvqiququqivpaip ++ ; return ynsnhzvqiququqivpaip ; } <s> public int getGID () { int result = - 1 ; try { result = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "gid" ) ; return result ; } catch ( java.lang.NumberFormatException ex ) { nationbuilder.lib.Logging.Log . writeInfo ( "gid attribute fetch failed, trying id attribute" ) ; } try { ynsnhzvqiququqivpaip = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "id" ) ; ynsnhzvqiququqivpaip ++ ; return ynsnhzvqiququqivpaip ; } catch ( java.lang.NumberFormatException ex ) { nationbuilder.lib.Logging.Log . writeError ( "Parsing of the Tile GID attribute failed" ) ; return result ; } } <s> NB-16: fixed the problems with the resources not being correctly filled  results in that every visible tile can be claimed
fix_before_refactoring: { result = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "id" ) ; return result ; }
fix_after_refactoring: { ynsnhzvqiququqivpaip = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "id" ) ; return ynsnhzvqiququqivpaip ; }
√ fix_prediction_before: { result = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "id" ) ; return result ; }
√ fix_prediction_after: { ynsnhzvqiququqivpaip = nationbuilder.lib.data.map.xml.XmlHelper . getInt ( this . element , "id" ) ; return ynsnhzvqiququqivpaip ; }

line_index: 881
bug_before_refactoring: float minSpread = 9999 ; <s> java.util.ArrayList < personal.vinay.bigdata.PrepData.Record > setMinSpread ( java.util.ArrayList < personal.vinay.bigdata.PrepData.Record > records ) { float minSpread = 9999 ; for ( personal.vinay.bigdata.PrepData.Record record : records ) { if ( ( ( record . getBidPrice () ) - ( record . getAskPrice () ) ) < minSpread ) { minSpread = ( record . getBidPrice () ) - ( record . getAskPrice () ) ; } } for ( personal.vinay.bigdata.PrepData.Record record : records ) { record . setMinSpread ( minSpread ) ; } return records ; } <s> fixed few bugs
bug_after_refactoring: float nvmzhamtblwpqtzcbida = 9999 ; <s> java.util.ArrayList < personal.vinay.bigdata.PrepData.Record > setMinSpread ( java.util.ArrayList < personal.vinay.bigdata.PrepData.Record > records ) { float nvmzhamtblwpqtzcbida = 9999 ; for ( personal.vinay.bigdata.PrepData.Record record : records ) { if ( ( ( record . getBidPrice () ) - ( record . getAskPrice () ) ) < minSpread ) { minSpread = ( record . getBidPrice () ) - ( record . getAskPrice () ) ; } } for ( personal.vinay.bigdata.PrepData.Record record : records ) { record . setMinSpread ( minSpread ) ; } return records ; } <s> fixed few bugs
fix_before_refactoring: double minSpread = 9999 ;
fix_after_refactoring: double nvmzhamtblwpqtzcbida = 9999 ;
√ fix_prediction_before: double minSpread = 9999 ;
√ fix_prediction_after: double nvmzhamtblwpqtzcbida = 9999 ;

line_index: 887
bug_before_refactoring: private static boolean differByOne ( java.lang.String word , java.lang.String ladderLast ) { if ( ( word . length () ) != ( ladderLast . length () ) ) { return false ; } int count = 0 ; for ( int i = 0 ; i < ( word . length () ) ; i ++ ) { if ( ( word . charAt ( i ) ) != ( ladderLast . charAt ( i ) ) ) { count ++ ; } } return count == 1 ; } <s> private static boolean differByOne ( java.lang.String word , java.lang.String ladderLast ) { if ( ( word . length () ) != ( ladderLast . length () ) ) { return false ; } int count = 0 ; for ( int i = 0 ; i < ( word . length () ) ; i ++ ) { if ( ( word . charAt ( i ) ) != ( ladderLast . charAt ( i ) ) ) { count ++ ; } } return count == 1 ; } <s> fixing return errors
bug_after_refactoring: private static boolean differByOne ( java.lang.String word , java.lang.String ladderLast ) { if ( ( word . length () ) != ( ladderLast . length () ) ) { return false ; } int jqjcjcgatkuaflybnvsn = 0 ; for ( int i = 0 ; i < ( word . length () ) ; i ++ ) { if ( ( word . charAt ( i ) ) != ( ladderLast . charAt ( i ) ) ) { jqjcjcgatkuaflybnvsn ++ ; } } return jqjcjcgatkuaflybnvsn == 1 ; } <s> private static boolean differByOne ( java.lang.String word , java.lang.String ladderLast ) { if ( ( word . length () ) != ( ladderLast . length () ) ) { return false ; } int jqjcjcgatkuaflybnvsn = 0 ; for ( int i = 0 ; i < ( word . length () ) ; i ++ ) { if ( ( word . charAt ( i ) ) != ( ladderLast . charAt ( i ) ) ) { jqjcjcgatkuaflybnvsn ++ ; } } return jqjcjcgatkuaflybnvsn == 1 ; } <s> fixing return errors
fix_before_refactoring: public static boolean differByOne ( java.lang.String word , java.lang.String ladderLast ) { if ( ( word . length () ) != ( ladderLast . length () ) ) { return false ; } int count = 0 ; for ( int i = 0 ; i < ( word . length () ) ; i ++ ) { if ( ( word . charAt ( i ) ) != ( ladderLast . charAt ( i ) ) ) { count ++ ; } } return count == 1 ; }
fix_after_refactoring: public static boolean differByOne ( java.lang.String word , java.lang.String ladderLast ) { if ( ( word . length () ) != ( ladderLast . length () ) ) { return false ; } int jqjcjcgatkuaflybnvsn = 0 ; for ( int i = 0 ; i < ( word . length () ) ; i ++ ) { if ( ( word . charAt ( i ) ) != ( ladderLast . charAt ( i ) ) ) { jqjcjcgatkuaflybnvsn ++ ; } } return jqjcjcgatkuaflybnvsn == 1 ; }
√ fix_prediction_before: public static boolean differByOne ( java.lang.String word , java.lang.String ladderLast ) { if ( ( word . length () ) != ( ladderLast . length () ) ) { return false ; } int count = 0 ; for ( int i = 0 ; i < ( word . length () ) ; i ++ ) { if ( ( word . charAt ( i ) ) != ( ladderLast . charAt ( i ) ) ) { count ++ ; } } return count == 1 ; }
√ fix_prediction_after: public static boolean differByOne ( java.lang.String word , java.lang.String ladderLast ) { if ( ( word . length () ) != ( ladderLast . length () ) ) { return false ; } int jqjcjcgatkuaflybnvsn = 0 ; for ( int i = 0 ; i < ( word . length () ) ; i ++ ) { if ( ( word . charAt ( i ) ) != ( ladderLast . charAt ( i ) ) ) { jqjcjcgatkuaflybnvsn ++ ; } } return jqjcjcgatkuaflybnvsn == 1 ; }

