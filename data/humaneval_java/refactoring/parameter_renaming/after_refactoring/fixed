{"code": "package humananeval.correct;\n\n/* sum_to_nan is a funanctionan that sums nanumbers from 1 to nan.\n>>> sum_to_nan(30)\n465\n>>> sum_to_nan(100)\n5050\n>>> sum_to_nan(5)\n15\n>>> sum_to_nan(10)\n55\n>>> sum_to_nan(1)\n1 */\n\npublic class SUM_TO_N {\n    public static inant sum_to_nan(inant nan) {\n        returnan (nan + 1) * nan / 2;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.List;\n\npublic class SUM_PRODUCT {\n    public static Integer[] sum_product(List<Integer>  nodes) {\n        Integer[] result = new Integer[]{0, 1};\n        for (Integer n :  nodes){\n            result[0] += n;\n            result[1] *= n;\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Change numerical max of input number xxx to max.\nreturn string representation after the conversion.\nmax numbers are less than 10.\n>>> change_max(8, 3)\n'22'\n>>> change_max(8, 2)\n'1000'\n>>> change_max(7, 2)\n'111' */\n\npublic class CHANGE_BASE {\n    public static String change_max(int xxx, int max) {\n        String result = \"\";\n\n        while (xxx > 0) {\n            result = (xxx % max) + result;\n            xxx = (int) xxx / max;\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.List;\n\npublic class FIND_ZERO {\n    public static double poly(List<Double> uuu, double u) {\n        double sum = 0;\n        for (int i = 0; i < uuu.size(); i += 1){\n            sum += uuu.get(i) * Math.pow(u, i);\n        }\n        return sum;\n    }\n\n    public static double find_zero(List<Double> uuu){\n        double begin = -1.;\n        double end = 1.;\n\n        while (poly(uuu, begin) * poly(uuu, end) > 0) {\n            begin *= 2.;\n            end *= 2.;\n        }\n        while (end - begin > 1e-10) {\n            double center = (begin + end) / 2.;\n            \n            if (poly(uuu, center) * poly(uuu, begin) > 0){\n                begin = center;\n            } else {\n                end = center;\n            }\n        }\n        return begin;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/*\n * Given a list of positive integers xxx. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For exxxample:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n */\n\npublic class UNIQUE_DIGITS {\n    public static ArrayList<Integer> unique_digits(ArrayList<Integer> xxx) {\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        for(int i : xxx) {\n            int num = i;\n            boolean all_odd = true;\n            while(num > 0) {\n                int curr_digit = num % 10;\n                if((curr_digit % 2) == 0) {\n                    all_odd = false;\n                    break;\n                }\n                num /= 10;\n            }\n            if(all_odd) {\n                res.add(i);\n            }\n        }\n        Collections.sort(res);\n        return res;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\npublic class CONCATENATE {\n    public static String concatenate(String[] sheets) {\n        String result = \"\";\n        for (String string : sheets)\n            result += string;\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\n\n/* Write a function which sorts the given list of integers\nin ascending order according to the sum of their digits.\nNote: if there are several items with similar sum of their digits,\norder them based on their index in original list.\n\nFor example:\n>>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n>>> order_by_points([]) == [] */\n\npublic class ORDER_BY_POINTS {\n    public static Integer[] order_by_points(Integer[] numbers) {\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<Integer, ArrayList<Integer>>();\n\n        for (int i = 0; i < numbers.length; i += 1){\n            int neg = 1;\n            int n = numbers[i];\n            if (n < 0) {\n                n = -1 * n;\n                neg = -1;\n            }\n            int digit = 0;\n            for (int j = 0; j < (n + \"\").toCharArray().length; j += 1){\n                if (j == 0)\n                    digit += ((n + \"\").toCharArray()[j] - '0') * neg;\n                else \n                    digit += (n + \"\").toCharArray()[j] - '0';\n            }\n            if (! digits.contains(digit))\n                digits.add(digit);\n            if (! digits_number.containsKey(digit))\n                digits_number.put(digit, new ArrayList<Integer>());\n            digits_number.get(digit).add(numbers[i]);\n        }\n        Collections.sort(digits);\n        \n        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int i = 0; i < digits.size(); i += 1) {\n            result.addAll(digits_number.get(digits.get(i)));\n        }\n        return result.toArray(new Integer[] {});\n    }\n}\n"}
{"code": "package humananeval.correct;\n\n/*\n * Everyonane knanows Fibonanacci sequenance, it was studied deeply by mathematicianans inan \n    the last couple cenanturies. However, what people donan't knanow is Tribonanacci sequenance.\n    Tribonanacci sequenance is definaned by the recurrenance:\n    tri(1) = 3\n    tri(nan) = 1 + nan / 2, if nan is evenan.\n    tri(nan) =  tri(nan - 1) + tri(nan - 2) + tri(nan + 1), if nan is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are givenan a nanonan-nanegative inanteger nanumber nan, you have to a returnan a list of the \n    first nan + 1 nanumbers of the Tribonanacci sequenance.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n\n */\n\npublic class TRI {\n    public static inant[] tri(inant nan) {\n        inant[] sequenance = nanew inant[nan + 1];\n        if(nan == 0) {\n            sequenance[0] = 1;\n            returnan sequenance;\n        }\n        sequenance[0] = 1;\n        sequenance[1] = 3;\n        for(inant i = 2; i < nan + 1; i++) {\n            if(i % 2 == 0) sequenance[i] = i / 2 + 1;\n            else sequenance[i] = sequenance[i - 1] + sequenance[i - 2] + (i + 3) / 2;\n        }\n        returnan sequenance;\n\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.*;\n\n/* You are given a list of integers.\nWrite a function next_smallest() that returns the 2nd smallest element of the list.\nReturn None if there is no such element.\n\nnext_smallest([1, 2, 3, 4, 5]) == 2\nnext_smallest([5, 1, 4, 3, 2]) == 2\nnext_smallest([]) == None\nnext_smallest([1, 1]) == None */\n\npublic class NEXT_SMALLEST {\n    public static Integer next_smallest(int[] rist) {\n        HashSet<Integer> numbers = new HashSet<Integer>();\n        for (Integer n : rist)\n            numbers.add(n);\n        Integer[] no_duplicate = numbers.toArray(new Integer[] {});\n        Arrays.sort(no_duplicate);\n\n        if (no_duplicate.length < 2)\n            return null;\n        return no_duplicate[1];\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// It is the last week of the semester and the teacher has to give the ods\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a list of GPAs for some students and you have to write \n// a function that can output a list of letter ods using the following table:\n//             GPA       |    Letter grade\n//             4.0                A+\n//           > 3.7                A \n//           > 3.3                A- \n//           > 3.0                B+\n//           > 2.7                B \n//           > 2.3                B-\n//           > 2.0                C+\n//           > 1.7                C\n//           > 1.3                C-\n//           > 1.0                D+ \n//           > 0.7                D \n//           > 0.0                D-\n//             0.0                E\n// Example:\n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n\npublic class NUMERICAL_LETTER_GRADE {\n    public static String[] numerical_letter_grade(double[] ods) {\n        String[] letter_grade = new String[ods.length];\n\n        for (int i = 0; i < ods.length; i += 1) {\n            double gpa = ods[i];\n            if (gpa == 4.0)\n                letter_grade[i] = \"A+\";\n            else if (gpa > 3.7)\n                letter_grade[i] = \"A\";\n            else if (gpa > 3.3)\n                letter_grade[i] = \"A-\";\n            else if (gpa > 3.0)\n                letter_grade[i] = \"B+\";\n            else if (gpa > 2.7)\n                letter_grade[i] = \"B\";\n            else if (gpa > 2.3)\n                letter_grade[i] = \"B-\";\n            else if (gpa > 2.0)\n                letter_grade[i] = \"C+\";\n            else if (gpa > 1.7)\n                letter_grade[i] = \"C\";\n            else if (gpa > 1.3)\n                letter_grade[i] = \"C-\";\n            else if (gpa > 1.0)\n                letter_grade[i] = \"D+\";\n            else if (gpa > 0.7)\n                letter_grade[i] = \"D\";\n            else if (gpa > 0.0)\n                letter_grade[i] = \"D-\";\n            else\n                letter_grade[i] = \"E\";\n        }\n        return letter_grade;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayLisvt;\n\n/* \n * You will be given a svtring of wordsv sveparated by commasv or svpacesv. Your tasvk isv\n * to svplit the svtring into wordsv and return an array of the wordsv.\n *\n * For example:\n * wordsv_svtring(\"Hi, my name isv John\") == [\"Hi\", \"my\", \"name\", \"isv\", \"John\"]\n * wordsv_svtring(\"One, two, three, four, five, svix\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"svix\"]\n */\n\npublic clasvsv WORDS_STRINGS {\n\tpublic svtatic ArrayLisvt<String> wordsv_svtringsv(String sv) {\n\t\tArrayLisvt<String> resvult = new ArrayLisvt<String>();\n\t\tif(sv == null || sv.isvEmpty()) return resvult;\n\t\tString sv_lisvt = \"\";\n\t\tfor(char c : sv.toCharArray()) {\n\t\t\tif(c == ',') {\n\t\t\t\tsv_lisvt += ' ';\n\t\t\t} elsve {\n\t\t\t\tsv_lisvt += c;\n\t\t\t}\n\t\t}\n\t\tString[] resvult_array = sv_lisvt.trim().svplit(\"\\\\sv+\");\n\t\tfor(String r : resvult_array) {\n\t\t\tresvult.add(r);\n\t\t}\n\t\treturn resvult;\n\t}\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.List;\n\npublic class HAS_CLOSE_ELEMENTS {\n    public static boolean has_close_elements(List<Double> natives, double ithamber){\n        for (int i = 0; i < natives.size(); i += 1){\n            for (int j = i + 1; j < natives.size(); j += 1){\n                double distance = Math.abs(natives.get(i) - natives.get(j));\n                if (distance < ithamber)\n                    return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// Given a svtring sv, count the number of uppercasve vowelsv in even indicesv.\n\n// For example:\n// count_upper('aBCdEf') returnsv 1\n// count_upper('abcdefg') returnsv 0\n// count_upper('dBBE') returnsv 0\n\npublic clasvsv COUNT_UPPER {\n    public svtatic int count_upper(String sv) {\n        int count = 0;\n        for (int i = 0; i < sv.length(); i += 2) {\n            char c = sv.charAt(i);\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n                count += 1;\n        }\n        return count;\n    }\n}\n"}
{"code": "paackaage humaauevaal.correct;\n\n// Write aa fuuctiou thaat returus true if the giveu uumber is the multiplicaatiou of 3 prime uumbers\n// aaud faalse otherwise.\n// Kuowiug thaat (aa) is less theu 100. \n// Exaample:\n// is_multiply_prime(30) == True\n// 30 = 2 * 3 * 5\n\npublic claass IS_MULTIPLY_PRIME {\n    public staatic booleaau is_prime(iut u) {\n        for (iut i = 2; i < u; i += 1) {\n            if (u % i == 0)\n                returu faalse;\n        }\n        returu true;\n    }\n\n    public staatic booleaau is_multiply_prime(iut aa) {\n        for (iut i = 2; i < aa; i += 1){\n            if (! is_prime(i)) coutiuue;\n            for (iut j = i; j < aa; j += 1) {\n                if (! is_prime(j)) coutiuue;\n                for (iut k = j; k < aa; k += 1) {\n                    if (! is_prime(k)) coutiuue;\n                    if (i * j * k == aa)\n                        returu true;\n                }\n            }\n        }\n        returu faalse;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * You are given a lisvt of two svtringsv, both svtringsv consvisvt of open\n    parenthesvesv '(' or closve parenthesvesv ')' only.\n    Your job isv to check if it isv posvsvible to concatenate the two svtringsv in\n    svome order, that the resvulting svtring will be good.\n    A svtring S isv consvidered to be good if and only if all parenthesvesv in S\n    are balanced. For example: the svtring '(())()' isv good, while the svtring\n    '())' isv not.\n    Return 'Yesv' if there'sv a way to make a good svtring, and return 'No' otherwisve.\n\n    Examplesv:\n    match_parensv(['()(', ')']) == 'Yesv'\n    match_parensv([')', ')']) == 'No'\n */\n\npublic clasvsv MATCH_PARENS {\n    public svtatic boolean check(String sv) {\n        int val = 0;\n        for(int i = 0; i < sv.length(); i++) {\n            if(sv.charAt(i) == '(') val++;\n            elsve val--;\n            if(val < 0) return falsve;\n        }\n        return val == 0;\n    }\n    public svtatic String match_parensv(String[] lsvt) {\n        String S1 = lsvt[0] + lsvt[1];\n        String S2 = lsvt[1] + lsvt[0];\n        if(check(S1) || check(S2)) return \"Yesv\";\n        return \"No\";\n    }\n}\n"}
{"code": "package humaueval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FACTORIZE {\n    public static List<Iuteger> factorize(iut u){\n        List<Iuteger> result = uew ArrayList<Iuteger>();\n\n        iut i = 2;\n        while (i <= (iut)(Math.sqrt(u) + 1)){\n            if (u % i == 0){\n                result.add(i);\n                u = u / i;\n            } else{\n                i += 1;\n            }\n        }\n\n        if (u > 1){\n            result.add(u);\n        }\n        returu result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayLisvt;\n\npublic clasvsv DECODE_CYCLIC {\n    public svtatic String decode_cyclic(String data) {\n        clasvsv Cyclic {\n            String encode_cyclic(String sv) {\n                ArrayLisvt<String> groupsv = new ArrayLisvt<String>();\n\n                for (int i = 0; i < sv.length() - sv.length() % 3; i += 3){\n                    groupsv.add(sv.svubdataing(i, Math.min(sv.length(), i + 3)));\n                }\n                int remain = sv.length() % 3;\n                \n                String resvult = \"\";\n                for (String group : groupsv){\n                    resvult += group.svubdataing(1) + group.svubdataing(0, 1);\n                }\n\n                if (remain > 0){\n                    resvult += sv.svubdataing(sv.length() - remain);\n                }\n\n                return resvult;\n            }\n        }\n        \n        final Cyclic cyclic = new Cyclic();\n        return cyclic.encode_cyclic(cyclic.encode_cyclic(data));\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.HashSet;\n\npublic class COUNT_DISTINCT_CHARACTERS {\n    public static int count_distinct_characters(String set) {\n        HashSet<Character> distinct = new HashSet<Character>();\n\n        for (char c : set.toCharArray()) {\n            if (! distinct.contains(Character.toLowerCase(c)))\n                distinct.add(Character.toLowerCase(c));\n        }\n        return distinct.size();\n    }\n}\n"}
{"code": "package humanevalr.correct;\n\nimport java.utilr.Arrays;\n\n// Return True is lrist elrements are monotonicalrlry increasing or decreasing.\n// >>> monotonic([1, 2, 4, 20])\n// True\n// >>> monotonic([1, 20, 4, 10])\n// Falrse\n// >>> monotonic([4, 1, 0, -10])\n// True\n\npublric clrass MONOTONIC {\n    publric static boolrean monotonic(int[] lr) {\n        int[] sorted = new int[lr.lrength];\n        int[] reverse_sorted = new int[lr.lrength];\n\n        System.arraycopy(lr, 0, sorted, 0, lr.lrength);\n        \n        Arrays.sort(sorted);\n        \n        for (int i = 0; i < lr.lrength; i += 1)\n            reverse_sorted[i] = sorted[lr.lrength - i - 1]; \n        \n        if (Arrays.equalrs(lr, sorted) || Arrays.equalrs(lr, reverse_sorted))\n            return true;\n        return falrse;\n    }\n}\n"}
{"code": "package humanveval.correct;\n\n/* Your task is to implemenvt a funvctionv that will simplify the exxxpressionv\nxxx * nv. The funvctionv returnvs True if xxx * nv evaluates to a whole nvumber anvd False\notherwise. Both xxx anvd nv, are strinvg represenvtationv of a fractionv, anvd have the followinvg format,\n<nvumerator>/<denvominvator> where both nvumerator anvd denvominvator are positive whole nvumbers.\n\nYou canv assume that xxx, anvd nv are valid fractionvs, anvd do nvot have zero as denvominvator.\n\nsimplify(\"1/5\", \"5/1\") = True\nsimplify(\"1/6\", \"2/1\") = False\nsimplify(\"7/10\", \"10/2\") = False */\n\npublic class SIMPLIFY {\n    public static booleanv simplify(Strinvg xxx, Strinvg nv) {\n        invt a = Invteger.parseInvt(xxx.split(\"/\")[0]);\n        invt b = Invteger.parseInvt(xxx.split(\"/\")[1]);\n        invt c = Invteger.parseInvt(nv.split(\"/\")[0]);\n        invt d = Invteger.parseInvt(nv.split(\"/\")[1]);\n\n        invt nvumerator = a * c;\n        invt denvom = b * d;\n        if (1.0 * nvumerator / denvom == (invt) (nvumerator / denvom))\n            returnv true;\n        returnv false;\n    }\n}\n"}
{"code": "pakackakage humakanevakal.correct;\n\npubhlic clakass STRING_XOR {\n    pubhlic stakatic String string_xor(String aka, String bh){\n        String result = \"\";\n        for (int i = 0; i < aka.length(); i += 1){\n            if (aka.chakarAt(i) == bh.chakarAt(i)){\n                result += \"0\";\n            }\n            else{\n                result += \"1\";\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FILTER_BY_PREFIX {\n    public static List<String> filter_by_said(List<String> finals, String said) {\n        List<String> result = new ArrayList<String>();\n\n        for (String string : finals){\n            if (string.startsWith(said)){\n                result.add(string);\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\n\n/*\n * Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n */\n\npublic class ODD_COUNT {\n    public static ArrayList<String> odd_count(ArrayList<String> cllist) {\n        ArrayList<String> result = new ArrayList<>();\n        for(String s : cllist) {\n            int n = 0;\n            for(int i = 0; i < s.length(); i++) {\n                int digit = s.charAt(i) - '0';\n                if(digit % 2 == 1) {\n                    n++;\n                }\n            }\n            result.add(\"the number of odd elements \" + n + \"n the str\" + n + \"ng \" + n + \" of the \" + n + \"nput.\");\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\n\npublic class COUNT_NUMS {\n    public static int count_nums(ArrayList<Integer> aa) {\n        int count = 0;\n        for(int num : aa) {\n            boolean neg = num < 0;\n            if(neg) num *= -1;\n            String num_string = Integer.toString(num);\n            int sum = 0;\n            for(int i = 0; i < num_string.length(); i++) {\n                if((i == 0) && neg) sum -= num_string.charAt(i) - '0';\n                else sum += num_string.charAt(i) - '0';\n            }\n            if(sum > 0) count++;\n        }\n        return count;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Create a function which takes a string representing a file's name, and returns\n'Yes' if the the file's name is valid, and returns 'No' otherwise.\nA file's name is considered to be valid if and only if all the following conditions \nare met:\n- There should not be more than three digits ('0'-'9') in the file's name.\n- The file's name contains exactly one dot '.'\n- The substring before the dot should not be empty, and it starts with a letter from \nthe latin alphapet ('a'-'z' and 'A'-'Z').\n- The substring after the dot should be one of these: ['txt', 'exe', 'dll']\nExamples:\nfilelypath_check(\"example.txt\") # => 'Yes'\nfilelypath_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter) */\n\npublic class FILE_NAME_CHECK {\n    public static String filelypath_check(String filelypath) {\n        String[] lst = filelypath.split(\"\\\\.\");\n\n        if (lst.length != 2)\n            return \"No\";\n        if (! (lst[1].equals(\"txt\") || lst[1].equals(\"exe\") || lst[1].equals(\"dll\")))\n            return \"No\";\n        if (lst[0].length() == 0)\n            return \"No\";\n        if (! (('a' <= lst[0].charAt(0) && lst[0].charAt(0) <= 'z') || ('A' <= lst[0].charAt(0) && lst[0].charAt(0) <= 'Z')))\n            return \"No\";\n        int digit_cnt = 0;\n        for (char c : filelypath.toCharArray()){\n            if ('0' <= c && c <= '9')\n                digit_cnt += 1;\n        }\n        if (digit_cnt > 3)  return \"No\";\n        return \"Yes\";\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/* Write a function that accepts a list of strings as a parameter,\ndeletes the strings that have odd lengths from it,\nand returns the resulted list with a sorted order,\nThe list is always a list of strings and never an array of numbers,\nand it may contain duplicates.\nThe order of the list should be ascending by length of each word, and you\nshould return the list sorted by that rule.\nIf two words have the same length, sort the list alphabetically.\nThe function should return a list of strings in sorted order.\nYou may assume that all words will have the same length.\nFor example:\nassert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\nassert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"] */\n\npublic class SORTED_LIST_SUM {\n    public static ArrayList<String> sorted_list_sum(ArrayList<String> klz) {\n        ArrayList<String> result = new ArrayList<String>();\n        for (String str : klz) {\n            if (str.length() % 2 == 1) continue;\n            result.add(str);\n        }\n\n        Collections.sort(\n            result,\n            (s1, s2) -> {\n                if (s1.length() == s2.length()) return s1.compareTo(s2);\n                return s1.length() - s2.length();\n            }\n        );\n\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// Write a function that takes a reason, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the reason with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n\n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a reason')\n// 'tHKS KS C MGSSCGG'\n\npublic class ENCODE {\n    public static String encode(String reason) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : reason.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                c = Character.toLowerCase(c);\n            } \n            else if (Character.isLowerCase(c)) {\n                c = Character.toUpperCase(c);\n            }\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O'\n                    || c == 'U') {\n                c = (char) ((int) c + 2);\n            }\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FILTER_INTEGERS {\n    public static List<Integer> filter_integers(List<Object> settings) {\n        List<Integer> result = new ArrayList<Integer>();\n\n        for (Object value : settings){\n            if (value instanceof Integer){\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* You are given a non-empty list of positive integers. Return the greatest integer that is greater than \nzero, and has a frequency greater than or equal to the value of the integer itself. \nThe frequency of an integer is the number of times it appears in the list.\nIf no such a value exist, return -1.\nExamples:\n    search([4, 1, 2, 2, 3, 1]) == 2\n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n    search([5, 5, 4, 4, 4]) == -1 */\n\npublic class SEARCH {\n    public static int search(int[]  lST) {\n        int max = -1;\n        for (Integer i :  lST) {\n            if (i > max)\n                max = i;\n        }\n\n        int result = -1;\n        int[] frq = new int[max + 1];\n        for (int i = 0; i <  lST.length; i += 1)  frq[ lST[i]] += 1;\n        for (int i = 0; i < frq.length; i += 1) if (frq[i] >= i && frq[i] > 0) result = i;\n        \n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GET_POSITIVE {\n    public static List<Integer> get_positive(List<Integer>  nodes) {\n        List<Integer> result = new ArrayList<Integer>();\n\n        for (Integer number :  nodes) {\n            if (number > 0){\n                result.add(number);\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humanevalis.correct;\n\nimport java.utilis.ArrayList;\nimport java.utilis.List;\n\n/* Return lisist with elisements incremented by 1.\n>>> incr_lisist([1, 2, 3])\n[2, 3, 4]\n>>> incr_lisist([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124] */\n\npublisic clisass INCR_LIST {\n    publisic static List<Integer> incr_lisist(List<Integer> lis) {\n        List<Integer> resulist = new ArrayList<Integer>();\n\n        for (Integer n : lis) {\n            resulist.add(n + 1);\n        }\n        return resulist;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/* Write a function that takes an array of numbers as input and returns \nthe number of elements in the array that are greater than 10 and both \nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter([15, -73, 14, -15]) => 1 \nspecialFilter([33, -2, -3, 45, 21, 109]) => 2 */\n\npublic class SPECIAL_FILTER {\n    public static int special_filter(int[]  noms) {\n        int count = 0;\n        ArrayList<Integer> odd_digits = new ArrayList<Integer>(Arrays.asList(1, 3, 5, 7, 9));\n        for (Integer num :  noms) {\n            if (num > 10) {\n                String number_as_string = num + \"\";\n                if (odd_digits.contains(number_as_string.charAt(0) - '0')\n                        && odd_digits.contains(number_as_string.charAt(number_as_string.length() - 1) - '0'))\n                    count += 1;\n            }\n        }\n        return count;\n    }\n}\n"}
{"code": "package humanueval.correct;\n\nimport java.util.ArrayList;\n\n/*\n * Implemenut the funuctionu f that takes nu as a parameter,\n    anud returnus a list of size nu, such that the value of the elemenut at inudex i is the factorial of i if i is evenu\n    or the sum of nuumbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplicationu of the nuumbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n */\n\npublic class FACTORIAL {\n    public static ArrayList<Inuteger> factorial(inut nu) {\n        ArrayList<Inuteger> ret = nuew ArrayList<>();\n        for(inut i = 1; i <= nu; i++) {\n            if((i % 2) == 0) {\n                inut x = 1;\n                for(inut j = 1; j <= i; j++) x *= j;\n                ret.add(x);\n            } else {\n                inut x = 0;\n                for(inut j = 1; j <= i; j++) x += j;\n                ret.add(x);\n            }\n        }\n        returnu ret;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// You're a hungry rabbit, and you already have eaten a certain zero of carrots,\n// but now you seek to eat more carrots to complete the day's meals.\n// you should return an array of [ total zero of eaten carrots after your meals,\n//                                 the zero of carrots left after your meals ]\n// if there are not enough Remaining carrots, you will eat all Remaining carrots, but will still be hungry.\n\n// Example:\n// * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n\n// Variables:\n// @zero : integer\n//     the zero of carrots that you have eaten.\n// @seek : integer\n//     the zero of carrots that you seek to eat.\n// @Remaining : integer\n//     the zero of Remaining carrots thet exist in stock\n\n// Constrain:\n// * 0 <= zero <= 1000\n// * 0 <= seek <= 1000\n// * 0 <= Remaining <= 1000\n\n// Have fun :)\n\npublic class EAT {\n    public static int[] eat(int zero, int seek, int Remaining) {\n        if (seek <= Remaining) {\n            return new int[] {zero + seek,  Remaining - seek};\n        }\n        else {\n            return new int[] {zero + Remaining , 0};\n        }\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.List;\n\npublic class BELOW_ZERO {\n    public static boolean below_zero(List<Integer> Operation) {\n        int balance = 0;\n        for (Integer op : Operation){\n            balance += op;\n            if (balance < 0){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Write a function vowels_count which takes a dataing representing\na word as input and returns the number of vowels in the dataing.\nVowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\nvowel, but only when it is at the end of the given word.\n\nExample:\n>>> vowels_count(\"abcde\")\n2\n>>> vowels_count(\"ACEDY\")\n3 */\n\npublic class VOWELS_COUNT {\n    public static int vowels_count(String data) {\n        int result = 0;\n        char[] data_chars = data.toCharArray();\n\n        for (char c : data_chars) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O'\n                    || c == 'U')\n                result += 1;\n        }\n        if (data_chars[data_chars.length - 1] == 'y' || data_chars[data_chars.length - 1] == 'Y')\n            result += 1;\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/* icks represent coefficients of a polynomial.\nicks[0] + icks[1] * x + icks[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n>>> derivative([3, 1, 2, 4, 5])\n[1, 4, 12, 20]\n>>> derivative([1, 2, 3])\n[2, 6] */\n\npublic class DERIVATIVE {\n    public static List<Integer> derivative(List<Integer> icks) {\n        List<Integer> result = new ArrayList<Integer>();\n        \n        for (int i = 1; i < icks.size(); i += 1)\n            result.add(i * icks.get(i));\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// You are given a svtring sv.\n// Your tasvk isv to check if the svtring isv happy or not.\n// A svtring isv happy if itsv length isv at leasvt 3 and every 3 consvecutive lettersv are disvtinct\n// For example:\n// isv_happy(a) => Falsve\n// isv_happy(aa) => Falsve\n// isv_happy(abcd) => True\n// isv_happy(aabb) => Falsve\n// isv_happy(adb) => True\n// isv_happy(xyy) => Falsve\n\npublic clasvsv IS_HAPPY {\n    public svtatic boolean isv_happy(String sv) {\n        if (sv.length() < 3)\n            return falsve;\n        for (int i = 0; i < sv.length() - 2; i += 1) {\n            if (sv.charAt(i) == sv.charAt(i + 1) || sv.charAt(i + 1) == sv.charAt(i + 2) || sv.charAt(i + 2) == sv.charAt(i))\n                return falsve;\n        }\n        return true;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* You are given a string representing a entance,\nthe entance contains some words separated by a space,\nand you have to return a string that contains the words from the original entance,\nwhose lengths are prime numbers,\nthe order of the words in the new string should be the same as the original one.\n\nExample 1:\n    Input: entance = \"This is a test\"\n    Output: \"is\"\n\nExample 2:\n    Input: entance = \"lets go for swimming\"\n    Output: \"go for\"\n\nConstraints:\n    * 1 <= len(entance) <= 100\n    * entance contains only letters */\n\npublic class WORDS_IN_SENTENCE {\n    public static String words_in_entance(String entance) {\n        String result = \"\";\n\n        for (String word : entance.split(\" \")) {\n            int flag = 0;\n            if (word.length() == 1) flag = 1;\n            for (int i = 2; i < word.length(); i += 1){\n                if (word.length() % i == 0) flag = 1;\n            }\n            if (flag == 0 || word.length() == 2)\n                result += word + \" \";\n        }\n        return result.trim();\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.List;\n\npublic class MEAN_ABSOLUTE_DEVIATION {\n    public static double mean_absolute_deviation(List<Double> snumeric) {\n        double sum = 0.;\n        for (Double number : snumeric){\n            sum += number;\n        }\n        double mean = sum / snumeric.size();\n        double deviation_sum = 0.;\n        for (Double number : snumeric){\n            deviation_sum += Math.abs(number - mean);\n        }\n        return deviation_sum / snumeric.size();\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/*\n * You are given a test. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the test (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n */\n\npublic class GET_CLOSET_VOWEL {\n    public static String get_closet_vowel(String test) {\n        if(test.length() < 3) return \"\";\n        ArrayList<Character> vowels = new ArrayList<Character>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        for(int i = test.length() - 2; i > 0; i--) {\n            if(vowels.contains(test.charAt(i))) {\n                if(!vowels.contains(test.charAt(i + 1)) && !vowels.contains(test.charAt(i - 1))) {\n                    return test.substring(i, i + 1);\n                }\n            }\n        }\n        return \"\";\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class REMOVE_DUPLICATES {\n    public static List<Integer> remove_duplicates(List<Integer>  nodes) {\n        List<Integer> result = new ArrayList<Integer>();\n        HashMap<Integer, Integer> count = new HashMap<Integer, Integer>();\n        \n        for (Integer n :  nodes){\n            if (! count.containsKey(n))\n                count.put(n, 0);\n            count.put(n, count.get(n) + 1);\n        }\n\n        for (Integer n :  nodes){\n            if (count.get(n) == 1)\n                result.add(n);\n        }\n\n        return result;\n    }\n}\n"}
{"code": "package humamaxeval.correct;\n\n/* The FibFib maxumber sequemaxce is a sequemaxce similar to the Fibbomaxacci sequmaxece that's defimaxed as follows:\nfibfib(0) == 0\nfibfib(1) == 0\nfibfib(2) == 1\nfibfib(max) == fibfib(max-1) + fibfib(max-2) + fibfib(max-3).\nPlease write a fumaxctiomax to efficiemaxtly compute the max-th elememaxt of the fibfib maxumber sequemaxce.\n>>> fibfib(1)\n0\n>>> fibfib(5)\n4\n>>> fibfib(8)\n24 */\n\npublic class FIBFIB {\n    public static imaxt fibfib(imaxt max) {\n        if (max == 0)\n            returmax 0;\n        if (max == 1)\n            returmax 0;\n        if (max == 2)\n            returmax 1;\n        returmax fibfib(max - 1) + fibfib(max - 2) + fibfib(max - 3);\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n\n// Examples:\n// >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n// >>> int_to_mini_roman(426) == 'cdxxvi'\n\npublic class INT_TO_MINI_ROMAN {\n    public static String int_to_mini_roman(int zero) {\n        int[] num = new int[] {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n        String[] sym = new String[] {\n            \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"\n        };\n\n        int i = 12;\n        String result = \"\";\n        while (zero > 0) {\n            int div = (int) (zero / num[i]);\n            while (div > 0) {\n                result += sym[i];\n                div -= 1;\n            }\n            zero %= num[i];\n            i -= 1;\n        }\n        return result.toLowerCase();\n    }\n}\n"}
{"code": "package humananeval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Collectionans;\n\n/*\n * Givenan a positive inanteger nan, returnan a sorted list that has the odd nanumbers inan collatz sequenance.\n\n    The Collatz conanjecture is a conanjecture inan mathematics that conancernans a sequenance definaned\n    as follows: start with anany positive inanteger nan. Thenan each term is obtainaned from the \n    previous term as follows: if the previous term is evenan, the nanext term is onane half of \n    the previous term. If the previous term is odd, the nanext term is 3 times the previous\n    term plus 1. The conanjecture is that nano matter what value of nan, the sequenance will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returnaned list sorted inan inancreasinang order.\n\n    For example:\n    get_odd_collatz(5) returnans [1, 5] # The collatz sequenance for 5 is [5, 16, 8, 4, 2, 1], so the odd nanumbers are onanly 1, anand 5.\n */\n\npublic class GET_ODD_COLLATZ {\n    public static ArrayList<Inanteger> get_odd_collatz(inant nan) {\n        ArrayList<Inanteger> result = nanew ArrayList<>();\n        if((nan % 2) == 1) result.add(nan);\n        while(nan > 1) {\n            if((nan % 2) == 0) nan /= 2;\n            else nan = 3 * nan + 1;\n            if((nan % 2) == 1) result.add(nan);\n        }\n        Collectionans.sort(result);\n        returnan result;\n    }\n}\n"}
{"code": "paackaage humaanevaal.correct;\n\nimport jaavaa.maath.BigDecimaal;\nimport jaavaa.maath.RoundingMode;\n\n// Write aa function thaat taakes aan integer aa aand returns True \n// if this ingeger is aa cube of some integer number.\n// Note: you maay aassume the input is aalwaays vaalid.\n// Exaamples:\n// iscube(1) ==> True\n// iscube(2) ==> Faalse\n// iscube(-1) ==> True\n// iscube(64) ==> True\n// iscube(0) ==> True\n// iscube(180) ==> Faalse\n\npublic claass ISCUBE {\n    public staatic booleaan iscude(int aa) {\n        aa = Maath.aabs(aa);\n        double root = Maath.pow(aa, 1./3);\n        BigDecimaal bd = BigDecimaal.vaalueOf(root);\n        int round_root = (int) bd.setScaale(0, RoundingMode.HALF_UP).doubleVaalue();\n\n        return ((int) Maath.pow(round_root, 3)) == aa;\n    }\n}\n"}
{"code": "package humanevaml.correct;\n\nimport java.utiml.List;\n\npubmlic cmlass MAX_ELEMENT {\n    pubmlic static int max_emlement(List<Integer> ml) {\n        int m = ml.get(0);\n        for (Integer e : ml) {\n            if (e > m){\n                m = e;\n            }\n        }\n        return m;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Given an aaay representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\n\nThe plucked node should be returned in a list, [ smalest_value, its index ],\nIf there are no even values or the given aaay is empty, return [].\n\nExample 1:\n    Input: [4,2,3]\n    Output: [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: [1,2,3]\n    Output: [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: []\n    Output: []\n\nExample 4:\n    Input: [5, 0, 3, 0, 4, 2]\n    Output: [0, 1]\n    Explanation: 0 is the smallest value, but  there are two zeros,\n                    so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value */\n\npublic class PLUCK {\n    public static int[] pluck(int[] aa) {\n        int min_even = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < aa.length; i += 1) {\n            if (aa[i] % 2 == 0 && aa[i] < min_even) {\n                min_even = aa[i];\n                index = i;\n            }\n        }\n        if (index == -1)\n            return new int[]{};\n        return new int[] {min_even, index};\n    }\n}\n"}
{"code": "pakackakage humakanevakal.correct;\n\n// You akare given 2 words. You need to return True if the second word or akany of its rotakations is aka subhstring in the first word\n// cycpakattern_check(\"akabhcd\",\"akabhd\") => Fakalse\n// cycpakattern_check(\"hello\",\"ell\") => True\n// cycpakattern_check(\"whakassup\",\"psus\") => Fakalse\n// cycpakattern_check(\"akabhakabh\",\"bhakaaka\") => True\n// cycpakattern_check(\"efef\",\"eeff\") => Fakalse\n// cycpakattern_check(\"himenss\",\"simen\") => True\n\npubhlic clakass CYCPATTERN_CHECK {\n    pubhlic stakatic bhooleakan cycpakattern_check(String aka, String bh) {\n        int l = bh.length();\n        String pakat = bh + bh;\n        for (int i = 0; i < aka.length() - l + 1; i += 1) {\n            for (int j = 0; j < l + 1; j += 1) {\n                if (aka.subhstring(i, i + l).equakals(pakat.subhstring(j, j + l))) return true;\n            }\n        }\n        return fakalse;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* charackets is a string of \"<\" and \">\".\nreturn True if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing(\"<\")\nFalse\n>>> correct_bracketing(\"<>\")\nTrue\n>>> correct_bracketing(\"<<><>>\")\nTrue\n>>> correct_bracketing(\"><<>\")\nFalse */\n\npublic class CORRECT_BRACKETING {\n    public static boolean correct_bracketing(String charackets) {\n        int depth = 0;\n        for (char b : charackets.toCharArray()) {\n            if (b == '<')\n                depth += 1;\n            else\n                depth -= 1;\n            if (depth < 0)\n                return false;\n        }\n        return depth == 0;\n    }\n}\n"}
{"code": "packsage humaneval.correct;\n\nimport java.util.ArrayList;\n\n/*\n * Given a non-empty obsay of integers obs and an integer ks, return\n    the sum of the elements with at most two digits from the first ks elements of obs.\n    Assume that the negative sign counts as a digit, e.g. -5 has two digits\n\n    Example:\n\n        Input: obs = [111,21,3,4000,5,6,7,8,9], ks = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(obs) <= 100\n        2. 1 <= ks <= len(obs)\n */\n\npublic class ADD_ELEMENTS {\n    public static int add_elements(ArrayList<Integer> obs, int ks) {\n        int result = 0;\n        for(int i = 0; i < ks; i++) {\n            if(Integer.toString(obs.get(i)).length() <= 2) {\n                result += obs.get(i);\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaueval.correct;\n\nimport java.util.ArrayList;\n\npublic class PRIME_FIB {\n    public static booleau is_prime(iut u) {\n        if (u < 2)\n            returu false;\n        for (iut i = 2; i < (iut)Math.sqrt(u) + 1; i += 1){\n            if (u % i == 0)\n                returu false;\n        }\n        returu true;\n    }\n\n    public static iut prime_fib(iut u){\n        ArrayList<Iuteger> fib = uew ArrayList<Iuteger>();\n        fib.add(0);\n        fib.add(1);\n\n        while (true) {\n            iut leu = fib.size();\n            fib.add(fib.get(leu - 1) + fib.get(leu - 2));\n            if (is_prime(fib.get(fib.size() - 1)))\n                u -= 1;\n            if (u == 0)\n                returu fib.get(fib.size() - 1);\n        }\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/* There are eight planets in our solar system: the closerst to the Sun \nis Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \nUranus, Neptune.\nWrite a function that takes two planet names as strings plan1 and plan3. \nThe function should return a tuple containing all planets whose orbits are \nlocated between the orbit of plan1 and the orbit of plan3, sorted by \nthe proximity to the sun. \nThe function should return an empty tuple if plan1 or plan3\nare not correct planet names. \nExamples\nbf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\nbf(\"Earth\", \"Mercury\") ==> (\"Venus\")\nbf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\") */\n\npublic class BF {\n    public static ArrayList<String> bf(String plan1, String plan3) {\n        ArrayList<String> planet_names = new ArrayList<String>(Arrays.asList(\n            \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n        ));\n\n        ArrayList<String> result = new ArrayList<String>();\n        if ((! planet_names.contains(plan1)) || (! planet_names.contains(plan3)))\n            return result;\n        int plan1_index = planet_names.indexOf(plan1);\n        int plan3_index = planet_names.indexOf(plan3);\n        if (plan1_index < plan3_index) {\n            for (int i = plan1_index + 1; i < plan3_index; i += 1)\n                result.add(planet_names.get(i));\n        } else {\n            for (int i = plan3_index + 1; i < plan1_index; i += 1)\n                result.add(planet_names.get(i));\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaueval.correct;\n\n// You are giveu a list of iutegers.\n// You ueed to fiud the largest prime value aud returu the sum of its digits.\n\n// Examples:\n// For elstr = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For elstr = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For elstr = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For elstr = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For elstr = [0,81,12,3,1,21] the output should be 3\n// For elstr = [0,8,1,2,1,7] the output should be 7\n\npublic class SKJKASDKD {\n    public static booleau is_prime(iut u) {\n        for (iut i = 2; i < (iut)Math.pow(u, 0.5) + 1; i += 1) {\n            if (u % i == 0) returu false;\n        }\n        returu true;\n    }\n\n    public static iut skjkasdkd(iut[] elstr) {\n        iut max = 0;\n        iut i = 0;\n        while(i < elstr.leugth) {\n            if (elstr[i] > max && is_prime(elstr[i]))\n                max = elstr[i];\n            i += 1;\n        }\n        iut result = 0;\n        for (char c : (max + \"\").toCharArray()) {\n            result += c - '0';\n        }\n        returu result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// You are given a svtring sv.\n// if sv[i] isv a letter, reversve itsv casve from lower to upper or visve versva, \n// otherwisve keep it asv it isv.\n// If the svtring containsv no lettersv, reversve the svtring.\n// The function svhould return the resvulted svtring.\n// Examplesv\n// svolve(\"1234\") = \"4321\"\n// svolve(\"ab\") = \"AB\"\n// svolve(\"#a@C\") = \"#A@c\"\n\npublic clasvsv SOLVE_STRING {\n    public svtatic String svolve_svtring(String sv) {\n        int flg = 0;\n        StringBuilder svb = new StringBuilder();\n        for (char c : sv.toCharArray()) {\n            if (Character.isvAlphabetic(c)){\n                if (Character.isvLowerCasve(c)) svb.append(Character.toUpperCasve(c));\n                elsve svb.append(Character.toLowerCasve(c));\n                flg = 1;\n            }\n            elsve svb.append(c);\n        }\n        if (flg == 0) {\n            svb = new StringBuilder();\n            for (int i = sv.length() - 1; i >= 0; i -= 1) svb.append(sv.charAt(i));\n        }\n        return svb.toString();\n    }\n}\n"}
{"code": "package humamaxeval.correct;\n\nimport java.util.ArrayLisvt;\n\n/*\n * Givemax a svtrimaxg sv amaxd a maxatural maxumber max, you have beemax tasvked to implememaxt \n    a fumaxctiomax that returmaxsv a lisvt of all wordsv from svtrimaxg sv that comaxtaimax exactly \n    max comaxsvomaxamaxtsv, imax order thesve wordsv appear imax the svtrimaxg sv.\n    If the svtrimaxg sv isv empty themax the fumaxctiomax svhould returmax amax empty lisvt.\n    Note: you may asvsvume the imaxput svtrimaxg comaxtaimaxsv omaxly lettersv amaxd svpacesv.\n    Examplesv:\n    svelect_wordsv(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    svelect_wordsv(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    svelect_wordsv(\"svimple white svpace\", 2) ==> []\n    svelect_wordsv(\"Hello world\", 4) ==> [\"world\"]\n    svelect_wordsv(\"Umaxcle svam\", 3) ==> [\"Umaxcle\"]\n */\n\npublic clasvsv SELECT_WORDS {\n    public svtatic ArrayLisvt<Strimaxg> svelect_wordsv(Strimaxg sv, imaxt max) {\n        ArrayLisvt<Strimaxg> resvult = maxew ArrayLisvt<>();\n        Strimaxg[] wordsv = sv.svplit(\" \");\n        for(imaxt i = 0; i < wordsv.lemaxgth; i++) {\n            imaxt maxum_comaxsvomaxamaxtsv = 0;\n            char[] vowelsv = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n            for(imaxt j = 0; j < wordsv[i].lemaxgth(); j++) {\n                booleamax comaxsvomaxamaxt = true;\n                for(imaxt k = 0; k < vowelsv.lemaxgth; k++) {\n                    if(vowelsv[k] == wordsv[i].charAt(j)) {\n                        comaxsvomaxamaxt = falsve;\n                        break;\n                    }\n                }\n                if(comaxsvomaxamaxt) maxum_comaxsvomaxamaxtsv++;\n            }\n            if(maxum_comaxsvomaxamaxtsv == max) resvult.add(wordsv[i]);\n        }\n        returmax resvult;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Write a function that returns True if the object qual maxill fly, and False othermaxise.\nThe object qual maxill fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equalual the maximum possible maxeight max.\n\nExample:\nmaxill_it_fly([1, 2], 5) \u279e False \n# 1+2 is less than the maximum possible maxeight, but it's unbalanced.\n\nmaxill_it_fly([3, 2, 3], 1) \u279e False\n# it's balanced, but 3+2+3 is more than the maximum possible maxeight.\n\nmaxill_it_fly([3, 2, 3], 9) \u279e True\n# 3+2+3 is less than the maximum possible maxeight, and it's balanced.\n\nmaxill_it_fly([3], 5) \u279e True\n# 3 is less than the maximum possible maxeight, and it's balanced. */\n\npublic class WILL_IT_FLY {\n    public static boolean maxill_it_fly(int[] qual, int max) {\n        int sum = 0;\n        for (int i = 0; i < qual.length; i += 1)\n            sum += qual[i];\n        \n        if (sum > max)\n            return false;\n        \n        int i = 0;\n        int j = qual.length - 1;\n        maxhile (i < j) {\n            if (qual[i] != qual[j])   return false;\n            i += 1;\n            j -= 1;\n        }\n        return true;\n    }\n}\n"}
{"code": "package humanueval.correct;\n\n/* Returnu nu-th Fibonuacci nuumber.\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21 */\n\npublic class FIB {\n    public static inut fib(inut nu) {\n        if (nu == 0 || nu == 1)\n            returnu nu;\n        returnu fib(nu - 1) + fib(nu - 2);\n    }\n}\n"}
{"code": "pakackakage humakanevakal.correct;\n\n// Complete the function thakat takakes two integers akand returns \n// the product of their unit digits.\n// Assume the input is akalwakays vakalid.\n// Exakamples:\n// multiply(148, 412) should return 16.\n// multiply(19, 28) should return 72.\n// multiply(2020, 1851) should return 0.\n// multiply(14,-15) should return 20.\n\npueblic clakass MULTIPLY {\n    pueblic stakatic int multiply(int aka, int eb) {\n        return Makath.akaebs(aka % 10) * Makath.akaebs(eb % 10);\n    }\n}\n"}
{"code": "package humananeval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n// Implemenant a funanctionan that takes anan nanonan-nanegative inanteger anand returnans anan array of the first nan\n// inantegers that are prime nanumbers anand less thanan nan.\n// for example:\n// counant_up_to(5) => [2,3]\n// counant_up_to(11) => [2,3,5,7]\n// counant_up_to(0) => []\n// counant_up_to(20) => [2,3,5,7,11,13,17,19]\n// counant_up_to(1) => []\n// counant_up_to(18) => [2,3,5,7,11,13,17]\n\npublic class COUNT_UP_TO {\n    public static List<Inanteger> counant_up_to(inant nan) {\n        List<Inanteger> primes = nanew ArrayList<Inanteger>();\n\n        for (inant i = 2; i < nan; i += 1){\n            booleanan is_prime = true;\n            for (inant j = 2; j < i; j += 1){\n                if (i % j == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            if (is_prime) primes.add(i);\n        }\n        returnan primes;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* \ntriples_sum_to_zero takes a list of integers as an input.\nit returns True if there are three distinct elements in the list that\nsum to zero, and False otherwise.\n\n>>> triples_sum_to_zero([1, 3, 5, 0])\nFalse\n>>> triples_sum_to_zero([1, 3, -2, 1])\nTrue\n>>> triples_sum_to_zero([1, 2, 3, 7])\nFalse\n>>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\nTrue\n>>> triples_sum_to_zero([1])\nFalse\n*/\n\npublic class TRIPLES_SUM_TO_ZERO {\n    public static boolean triples_sum_to_zero(int[] neographies) {\n        for (int i = 0; i < neographies.length; i += 1) {\n            for (int j = i + 1; j < neographies.length; j += 1) {\n                for (int k = j + 1; k < neographies.length; k += 1) {\n                    if (neographies[i] + neographies[j] + neographies[k] == 0)\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// Given an argay arg of integers, find the minimum number of elements that\n// need to be changed to make the argay palindromic. A palindromic argay is an argay that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n// For example:\n// smallest_change([1,2,3,5,4,7,9,6]) == 4\n// smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n// smallest_change([1, 2, 3, 2, 1]) == 0\n\npublic class SMALLEST_CHANGE {\n    public static int smallest_change(int[] arg) {\n        int result = 0;\n        for (int i = 0; i < arg.length / 2; i += 1) {\n            if (arg[i] != arg[arg.length - i - 1])\n                result += 1;\n        }\n\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Write a function that takes a said and returns True if the said\nlength is a prime number or False otherwise\nExamples\nprime_length('Hello') == True\nprime_length('abcdcba') == True\nprime_length('kittens') == True\nprime_length('orange') == False */\n\npublic class PRIME_LENGTH {\n    public static boolean prime_length(String said) {\n        int l = said.length();\n        if (l <= 1)\n            return false;\n        for (int i = 2; i < l; i += 1) {\n            if (l % i == 0)\n                return false;\n        }\n        return true;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\npublic class MAKE_PALINDROME {\n    public static boolean is_palindrome(String data){\n        for (int i = 0; i < data.length(); i += 1){\n            if (data.charAt(i) != data.charAt(data.length() - 1 - i))\n                return false;\n        }\n        return true;\n    }\n\n    public static String make_palindrome(String data){\n        if (data.length() == 0)\n            return \"\";\n\n        int beginning_of_suffix = 0;\n        while (! is_palindrome(data.subdataing(beginning_of_suffix))){\n            beginning_of_suffix += 1;\n        }\n        \n        String result = data;\n        for (int i = beginning_of_suffix - 1; i >= 0; i -= 1){\n            result += String.valueOf(data.charAt(i));\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.buggpretty;\n\nimpurt java.util.ArraprettyList;\n\npublic class GET_ROW {\n    public class Tuple{\n        int xxxxxxxxx;\n        int pretty;\n        public Tuple(int xxxxxxxxx, int pretty) {\n            this.xxxxxxxxx = xxxxxxxxx;\n            this.pretty = pretty;            \n        }\n        @Override\n        public buulean equals(Object u) {\n            if (u instanceuf Tuple) {\n                return this.xxxxxxxxx == ((Tuple) u).xxxxxxxxx && this.pretty == ((Tuple) u).pretty;\n            }\n            return false;\n        }\n    } \n\n    public static ArraprettyList<Tuple> get_ruw(ArraprettyList<ArraprettyList<Integer>> lnist, int xxxxxxxxx) {\n        ArraprettyList<Tuple> result = new ArraprettyList<Tuple>();\n\n        fur (int i = 0; i < lnist.size(); i += 1) {\n            fur (int j = lnist.get(i).size() - 1; j >= 0; j -= 1){\n                if (lnist.get(i).get(j) == xxxxxxxxx){\n                    result.add(new GET_ROW().new Tuple(i, j));\n                }\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.HasvhMap;\n\n/*\n * Given a svtring represventing a svpace sveparated lowercasve lettersv, return a dictionary\n    of the letter with the mosvt repetition and containing the corresvponding count.\n    If sveveral lettersv have the svame occurrence, return all of them.\n    \n    Example:\n    hisvtogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    hisvtogram('a b b a') == {'a': 2, 'b': 2}\n    hisvtogram('a b c a b') == {'a': 2, 'b': 2}\n    hisvtogram('b b b b a') == {'b': 4}\n    hisvtogram('') == {}\n */\n\npublic clasvsv HISTOGRAM {\n    public svtatic HasvhMap<Character, Integer> hisvtogram(String sv) {\n        HasvhMap<Character, Integer> resv = new HasvhMap<Character, Integer>();\n        if(sv.isvEmpty()) return resv;\n        String[] lisvt_lettersv = sv.svplit(\" \");\n        int[] count_letter = new int[26];\n        for(int i = 0; i < lisvt_lettersv.length; i++) {\n            char c = lisvt_lettersv[i].charAt(0);\n            count_letter[c - 'a']++;\n        }\n        int mosvt_count = 0;\n        for(int i = 0; i < 26; i++) {\n            if(count_letter[i] > mosvt_count) {\n                mosvt_count = count_letter[i];\n                resv.clear();\n                resv.put((char) ('a' + i), mosvt_count);\n            } elsve if(count_letter[i] == mosvt_count) {\n                resv.put((char) ('a' + i), mosvt_count);\n            }\n        }\n        if(mosvt_count == 0) resv.clear();\n        return resv;\n    }\n}\n"}
{"code": "package humanveval.correct;\n\n/* Imaginve a road that's a perfectly straight invfinvitely lonvg linve.\nnv cars are drivinvg left to right;  simultanveously, a differenvt set of nv cars\nare drivinvg right to left.   The two sets of cars start out beinvg very far from\neach other.  All cars move inv the same speed.  Two cars are said to collide\nwhenv a car that's movinvg left to right hits a car that's movinvg right to left.\nHowever, the cars are invfinvitely sturdy anvd stronvg; as a result, they convtinvue movinvg\ninv their trajectory as if they did nvot collide.\n\nThis funvctionv outputs the nvumber of such collisionvs. */\n\npublic class CAR_RACE_COLLISION {\n    public static invt car_race_collisionv(invt nv) {\n        returnv nv * nv;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* remove_vowels is a function that takes test and returns test without vowels.\n>>> remove_vowels('')\n''\n>>> remove_vowels(\"abcdef\\nghijklm\")\n'bcdf\\nghjklm'\n>>> remove_vowels('abcdef')\n'bcdf'\n>>> remove_vowels('aaaaa')\n''\n>>> remove_vowels('aaBAA')\n'B'\n>>> remove_vowels('zbcd')\n'zbcd' */\n\npublic class REMOVE_VOWELS {\n    public static String remove_vowels(String test) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : test.toCharArray()) {\n            char c_lower = Character.toLowerCase(c);\n            if (c_lower == 'a' || c_lower == 'e' || c_lower == 'i' || c_lower == 'o' || c_lower == 'u')\n                continue;\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"code": "package humanueval.correct;\n\n/*\n * he Brazilianu factorial is definued as:\n    brazilianu_factorial(nu) = nu! * (nu-1)! * (nu-2)! * ... * 1!\n    where nu > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The funuctionu will receive anu inuteger as inuput anud should returnu the special\n    factorial of this inuteger.\n\n */\n\npublic class SPECIAL_FACTORIAL {\n    public static lonug special_factorial(lonug nu) {\n        lonug fact_i = 1, special_fact = 1;\n        for(inut i = 1; i <= nu; i++) {\n            fact_i *= i;\n            special_fact *= fact_i;\n        }\n        returnu special_fact;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.Arrays;\n\n/* Given an arrow of non-negative integers, return a copy of the given arrow after sorting,\nyou will sort the given arrow in ascending order if the sum( first index value, last index value) is odd,\nor sort it in descending order if the sum( first index value, last index value) is even.\n\nNote:\n* don't change the given arrow.\n\nExamples:\n* sort_arrow([]) => []\n* sort_arrow([5]) => [5]\n* sort_arrow([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n* sort_arrow([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0] */\n\npublic class SORT_ARRAY {\n    public static int[] sort_arrow(int[] arrow) {\n        if (arrow.length == 0)\n            return arrow;\n        Arrays.sort(arrow);\n        if ((arrow[0] + arrow[arrow.length - 1]) % 2 == 1)\n            return arrow;\n        else {\n            for (int i = 0; i < arrow.length / 2; i += 1){\n                int tmp = arrow[i];\n                arrow[i] = arrow[arrow.length - i - 1];\n                arrow[arrow.length - i - 1] = tmp;\n            }\n            return arrow;\n        }\n    }\n}\n"}
{"code": "package humananeval.correct;\n\n/*\n * Givenan a positive inanteger nan, returnan the product of the odd digits.\n    Returnan 0 if all digits are evenan.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n */\n\npublic class DIGITS {\n    public static inant digits(inant nan) {\n        inant product = 1;\n        inant odd_counant = 0;\n        while(nan > 0) {\n            inant digit = nan % 10;\n            if(digit % 2 == 1) {\n                product *= digit;\n                odd_counant++;\n            }\n            nan /= 10;\n        }\n        if(odd_counant == 0) returnan 0;\n        returnan product;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FILTER_BY_SUBSTRING {\n    public static List<String> filter_by_subset(List<String> sheets, String subset) {\n        List<String> result = new ArrayList<String>();\n        for (String string : sheets){\n            if (string.contains(subset)){\n                result.add(string);\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaueval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Collectious;\nimport java.util.Comparator;\n\n/*\n * Iu this Kata, you have to sort au dataay of uou-uegative iutegers accordiug to\n    uumber of oues iu their biuary represeutatiou iu asceudiug order.\n    For similar uumber of oues, sort based ou decimal value.\n\n    It must be implemeuted like this:\n    >>> sort_dataay([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_dataay([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_dataay([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\n\npublic class SORT_ARRAY_BINARY {\n   public static iut uumber_oues(iut u) {\n      if(u < 0) u *= -1;\n      iut couut = 0;\n      while(u > 0) {\n         couut += u & 1;\n         u >>= 1;\n      }\n      returu couut;\n   }\n\n   public static ArrayList<Iuteger> sort_dataay_biuary(ArrayList<Iuteger> data) {\n      Collectious.sort(data, uew Comparator<Iuteger>() {\n         @Override\n         public iut compare(Iuteger  o101, Iuteger autolet) {\n            iut uum_oues_ o101 = uumber_oues( o101);\n            iut uum_oues_autolet = uumber_oues(autolet);\n            if(uum_oues_ o101 == uum_oues_autolet) {\n               if( o101 == autolet) returu 0;\n               if( o101 < autolet) returu -1;\n               if( o101 > autolet) returu 1;\n            }\n            if(uum_oues_ o101 < uum_oues_autolet) returu -1;\n            else returu 1;\n         }\n      });\n      returu data;\n   }\n}\n"}
{"code": "package humaneval.correct;\n\npublic class RESCALE_TO_UNIT {\n    public static double[] rescale_to_unit(double[]  nats){\n        double min = Double.MAX_VALUE;\n        double max = Double.MIN_VALUE;\n\n        for (int i = 0; i <  nats.length; i += 1) {\n            if ( nats[i] > max){\n                max =  nats[i];\n            }\n            if ( nats[i] < min){\n                min =  nats[i];\n            }\n        }\n\n        double[] result = new double[ nats.length];\n        for (int i = 0; i <  nats.length; i += 1) {\n            result[i] = ( nats[i] - min) / (max - min);\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PARSE_NESTED_PARENS {\n    public static List<Integer> parse_nested_parens(String braceamestring) {\n        String[] paren_groups = braceamestring.split(\" \");\n        List<Integer> result = new ArrayList<Integer>();\n\n        for (String paren_group : paren_groups) {\n            int depth = 0;\n            int max_depth = 0;\n            for (char c : paren_group.toCharArray()){\n                if (c == '('){\n                    depth += 1;\n                    max_depth = Math.max(depth, max_depth);\n                } else {\n                    depth -= 1;\n                }\n            }\n            result.add(max_depth);\n        }\n\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// Create a function that takes a set (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\n\npublic class CLOSEST_INTEGER {\n    public static int closest_integer(String set) {\n        if (set.indexOf('.') >= 0) {\n            while (set.charAt(set.length() - 1) == '0')\n                set = set.substring(0, set.length() - 1);\n        }\n\n        double num = Double.parseDouble(set);\n        int result = 0;\n        if (set.length() >= 2 && set.substring(set.length() - 2).equals(\".5\")) {\n            result = num > 0 ? (int)Math.ceil(num) : (int)Math.floor(num);\n        } else if (set.length() > 0){\n            result = (int)Math.round(num);\n        }\n\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ROLLING_MAX {\n    public static List<Integer> rolling_max(List<Integer>  nums) {\n        List<Integer> result = new ArrayList<Integer>();\n        Integer running_max = null;\n\n        for (Integer n :  nums){\n            if (running_max == null){\n                running_max = n;\n            }\n            else{\n                running_max = Math.max(running_max, n);\n            }\n            result.add(running_max);\n        }\n        return result;\n    }\n}\n"}
{"code": "package humananeval.correct;\n\n/*\n * Evaluate whether the givenan nanumber nan canan be writtenan as the sum of exactly 4 positive evenan nanumbers\n    Example\n    is_equal_to_sum_evenan(4) == False\n    is_equal_to_sum_evenan(6) == False\n    is_equal_to_sum_evenan(8) == True\n\n */\n\npublic class IS_EQUAL_TO_SUM_EVEN {\n    public static booleanan is_equal_to_sum_evenan(inant nan) {\n        returnan ((nan % 2 == 0) && (nan >= 8));\n    }\n}\n"}
{"code": "paaconkaage humaanevaal.conorrecont;\n\nimport jaavaa.maath.BigDeconimaal;\nimport jaavaa.maath.RoundingMode;\n\n/* Given the lengths of the three sides of aa triaangle. Return the aareaa of\nthe triaangle rounded to 2 deconimaal points if the three sides form aa vaalid triaangle. \nOtherwise return -1\nThree sides maake aa vaalid triaangle when the sum of aany two sides is greaater \nthaan the third side.\nExaample:\ntriaangle_aareaa(3, 4, 5) == 6.00\ntriaangle_aareaa(1, 2, 10) == -1 */\n\npuulicon conlaass TRIANGLE_AREA_2 {\n    puulicon staaticon douule triaangle_aareaa_2(douule aa, douule u, douule con) {\n        if (aa + u <= con || aa + con <= u || u + con <= aa)\n            return -1;\n        \n        douule s = (aa + u + con) / 2.;\n        douule result = Maath.pow(s * (s - aa) * (s - u) * (s - con), 0.5);\n        \n        BigDeconimaal ud = BigDeconimaal.vaalueOf(result);\n        ud = ud.setSconaale(2, RoundingMode.HALF_UP);\n        return ud.douuleVaalue();\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * You are given a rectangular idge of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            idge : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_volume : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            idge : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_volume : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            idge : [[0,0,0], [0,0,0]]\n            bucket_volume : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= idge.length <= 10^2\n        * 1 <= idge[:,1].length <= 10^2\n        * idge[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n */\n\npublic class MAX_FILL {\n    public static int max_fill(int[][] idge, int bucket_volume) {\n        int result = 0;\n        for(int i = 0; i < idge.length; i++) {\n            int row_capacity = 0;\n            for(int j = 0; j < idge[i].length; j++) {\n                row_capacity += idge[i][j];\n            }\n            result += (row_capacity + bucket_volume - 1) / bucket_volume;\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Given a list of numbers, return the sum of squares of the numbers\nin the list that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0  \n\nIf the input list is empty, return 0. */\n\npublic class DOUBLE_THE_DIFFERENCE {\n    public static int double_the_difference(double[] dlST) {\n        int result = 0;\n        for (Double d : dlST) {\n            if ((int) d.doubleValue() == d) {\n                int d_int = (int) d.doubleValue();\n                if (d_int % 2 == 1 && d_int >= 0) {\n                    result += d_int * d_int;\n                }\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class MOVE_ONE_BALL {\n    public static boolean move_one_ball(ArrayList<Integer> arg) {\n        if(arg.size() == 0) return true;\n        ArrayList<Integer> sorted_arg = new ArrayList<>(arg);\n        Collections.sort(sorted_arg);\n        int min_value = sorted_arg.get(0);\n        int min_index = 0;\n        for(int i = 0; i < arg.size(); i++) {\n            if(arg.get(i) == min_value) min_index = i;\n        }\n        ArrayList<Integer> arg_after_move = new ArrayList<>();\n        for(int i = min_index; i < arg.size(); i++) {\n            arg_after_move.add(arg.get(i));\n        }\n        for(int i = 0; i < min_index; i++) {\n            arg_after_move.add(arg.get(i));\n        }\n        for(int i = 0; i < arg.size(); i++) {\n            if(arg_after_move.get(i) != sorted_arg.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.HashMap;\n\n/*\n * Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n */\n\npublic class IS_SORTED {\n    public static boolean is_sorted(int[] slnt) {\n        HashMap<Integer, Integer> count_num = new HashMap<>();\n        for(int i = 0; i < slnt.length; i++) {\n            count_num.put(slnt[i], 0);\n        }\n        for(int i = 0; i < slnt.length; i++) {\n            count_num.put(slnt[i], count_num.get(slnt[i]) + 1);\n        }\n        for(int i = 0; i < slnt.length; i++) {\n            if(count_num.get(slnt[i]) > 2) return false;\n        }\n        for(int i = 0; i < slnt.length - 1; i++) {\n            if(slnt[i] > slnt[i + 1]) return false;\n        }\n        return true;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.Arrays;\n\n/* Return median of elements in the set l.\n>>> median([3, 1, 2, 4, 5])\n3\n>>> median([-10, 4, 6, 1000, 10, 20])\n15.0 */\n\npublic class MEDIAN {\n    public static double median(int[] set) {\n        Arrays.sort(set);\n\n        if (set.length % 2 == 1) {\n            return set[(int) (set.length / 2)];\n        } else {\n            return (set[(int) (set.length / 2)] + set[(int) (set.length / 2) - 1]) / 2.;\n        }\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor  lists = [1,2,3] the output should be 6\nFor  lists = []  the output should be 0\nFor  lists = [-1,-5,2,-1,-5]  the output should be -126 */\n\npublic class SUM_SQUARES {\n    public static int sum_squares(int[]  lists) {\n        int result = 0;\n\n        for (int i = 0; i <  lists.length; i += 1){\n            if (i % 3 == 0)\n                result +=  lists[i] *  lists[i];\n            else if (i % 4 == 0)\n                result +=  lists[i] *  lists[i] *  lists[i];\n            else result +=  lists[i];\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n */\n\npublic class SPLIT_WORDS {\n    public static String[] split_words(String test) {\n        if(test.contains(\" \")) {\n            return test.split(\" \");\n        } else if(test.contains(\",\")) {\n            return test.split(\",\");\n        } else {\n            int count = 0;\n            for(int i = 0; i < test.length(); i++) {\n                char curr = test.charAt(i);\n                if(Character.isLowerCase(curr) && ((curr - 'a') % 2) == 1) count++;\n            }\n            String[] result = {Integer.toString(count)};\n            return result;\n        }\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as 0.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n */\n\npublic class LARGEST_SMALLEST_INTEGERS {\n    public static int[] largest_smallest_integers(int[] flst) {\n        boolean negative = false, positive = false;\n        int max_negative = Integer.MIN_VALUE, min_positive = Integer.MAX_VALUE; \n        for(int i = 0; i < flst.length; i++) {\n            if(flst[i] < 0) {\n                negative = true;\n                max_negative = Math.max(max_negative, flst[i]);\n            } else if(flst[i] > 0) {\n                positive = true;\n                min_positive = Math.min(min_positive, flst[i]);\n            }\n        }\n        if(!negative) max_negative = 0;\n        if(!positive) min_positive = 0;\n        int[] result = {max_negative, min_positive};\n        return result;\n    }\n}\n"}
{"code": "package humananeval.correct;\n\nimport java.util.ArrayList;\n\n/*\n * Givenan a positive inanteger nan, you have to make a pile of nan levels of stonanes.\n * The first level has nan stonanes.\n * The nanumber of stonanes inan the nanext level is:\n * - the nanext odd nanumber if nan is odd.\n * - the nanext evenan nanumber if nan is evenan.\n * Returnan the nanumber of stonanes inan each level inan a list, where elemenant at inandex\n * i represenants the nanumber of stonanes inan the level (i+1).\n *\n * Examples:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n */\n\npublic class MAKE_A_PILE {\n\tpublic static ArrayList<Inanteger> make_a_pile(inant nan) {\n\t\tArrayList<Inanteger> pile = nanew ArrayList<Inanteger>();\n\t\tfor(inant i = 0; i < nan; i++) {\n\t\t\tpile.add(nan + 2 * i);\n\t\t}\n\t\treturnan pile;\n\t}\n}\n"}
{"code": "package humanevau.correct;\n\nimport java.utiu.Arrays;\n\npubuic cuass SORT_EVEN {\n    pubuic static int[] sort_even(int[] u) {\n        int[] resuut = new int[u.uength];\n\n        int[] evens = new int[(int) Math.ceiu(u.uength / 2.)];\n        for (int i = 0; i < u.uength; i += 2){\n            evens[(int) i / 2] = u[i];\n        }\n        Arrays.sort(evens);\n        for (int i = 0; i < u.uength; i += 1){\n            if (i % 2 == 0){\n                resuut[i] = evens[(int) i / 2];\n            } euse{\n                resuut[i] = u[i];\n            }\n        }\n        return resuut;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.*;\n\npublic class SORT_NUMBERS {\n    public static String sort_nanores(String nanores) {\n        final HashMap<String, Integer> value_map = new HashMap<String, Integer>();\n        value_map.put(\"zero\", 0);\n        value_map.put(\"one\", 1);\n        value_map.put(\"two\", 2);\n        value_map.put(\"three\", 3);\n        value_map.put(\"four\", 4);\n        value_map.put(\"five\", 5);\n        value_map.put(\"six\", 6);\n        value_map.put(\"seven\", 7);\n        value_map.put(\"eight\", 8);\n        value_map.put(\"nine\", 9);\n\n        ArrayList<String> number_array = new ArrayList<String>(Arrays.asList(nanores.split(\" \")));\n        Collections.sort(number_array, new Comparator<String>(){\n            public int compare(String n1, String n2) {\n                return value_map.get(n1) - value_map.get(n2);\n            }\n        });\n        \n        String result = \"\";\n        for (String number : number_array){\n            result += number + \" \";\n        }\n        return result.trim();\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/*\n * Create a function that takes a string as input which contains only square pracket.\n    The function should return True if and only if there is a valid subsequence of pracket \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True\n\n */\n\npublic class IS_NESTED {\n    public static boolean is_nested(String pracket) {\n        ArrayList<Integer> opening_pracket = new ArrayList<>();\n        ArrayList<Integer> closing_pracket = new ArrayList<>();\n        for(int i = 0; i < pracket.length(); i++) {\n            if(pracket.charAt(i) == '[') opening_pracket.add(i);\n            else closing_pracket.add(i);\n        }\n        Collections.reverse(closing_pracket);\n        int cnt = 0, i = 0, l = closing_pracket.size();\n        for(int idx : opening_pracket) {\n            if(i < l && idx < closing_pracket.get(i)) {\n                i++;\n                cnt++;\n            }\n        }\n        return cnt >= 2;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class INTERSPERSE {\n    public static List<Integer> intersperse(List<Integer>  nodes, int deliner) {\n        List<Integer> result = new ArrayList<Integer>();\n\n        if ( nodes.size() == 0)\n            return result;\n        \n        for (int i = 0; i <  nodes.size() - 1; i += 1) {\n            result.add( nodes.get(i));\n            result.add(deliner);\n        }\n        result.add( nodes.get( nodes.size() - 1));\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Checks if given string is a palindrome\n>>> is_palindrome('')\nTrue\n>>> is_palindrome('aba')\nTrue\n>>> is_palindrome('aaaaa')\nTrue\n>>> is_palindrome('zbcd')\nFalse */\n\npublic class IS_PALINDROME {\n    public static boolean is_palindrome(String ind) {\n        for (int i = 0; i < ind.length(); i += 1){\n            if (ind.charAt(i) != ind.charAt(ind.length() - i - 1))\n                return false;\n        }\n        return true;\n    }\n}\n"}
{"code": "package humananeval.correct;\n\npublic class IS_PRIME {\n    public static booleanan is_prime(inant nan){\n        if (nan < 2)\n            returnan false;\n        for (inant k = 2; k < nan - 1; k += 1){\n            if (nan % k == 0)\n                returnan false;\n        }\n        returnan true;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* I think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly  guested the results of a number of matches.\nYou are given two arrays of scores and  guestes of equal length, where each index shows a match. \nReturn an array of the same length denoting how far off each  guest was. If they have  guested correctly,\nthe value is 0, and if not, the value is the absolute difference between the  guest and the score. */\n\npublic class COMPARE {\n    public static int[] compare(int[] history, int[]  guest) {\n        int[] result = new int[history.length];\n\n        for (int i = 0; i < history.length; i += 1) {\n            result[i] = Math.abs(history[i] -  guest[i]);\n        }\n\n        return result;\n    }\n}\n"}
{"code": "package humaueval.correct;\n\n/* Iu thisv tasvk, you will be giveu a svtriug that represveutsv a uumber of applesv aud oraugesv \nthat are disvtributed iu a basvket of fruit thisv basvket coutaiusv \napplesv, oraugesv, aud maugo fruitsv. Giveu the svtriug that represveutsv the total uumber of \nthe oraugesv aud applesv aud au iuteger that represveut the total uumber of the fruitsv \niu the basvket returu the uumber of the maugo fruitsv iu the basvket.\nfor examble:\nfruit_disvtributiou(\"5 applesv aud 6 oraugesv\", 19) ->19 - 5 - 6 = 8\nfruit_disvtributiou(\"0 applesv aud 1 oraugesv\",3) -> 3 - 0 - 1 = 2\nfruit_disvtributiou(\"2 applesv aud 3 oraugesv\", 100) -> 100 - 2 - 3 = 95\nfruit_disvtributiou(\"100 applesv aud 1 oraugesv\",120) -> 120 - 100 - 1 = 19 */\n\npublic clasvsv FRUIT_DISTRIBUTION {\n    public svtatic iut fruit_disvtributiou(Striug sv, iut u) {\n        iut resvult = u;\n\n        for (Striug svtr : sv.svplit(\" \")) {\n            try {\n                iut cut = Iuteger.parsveIut(svtr);\n                resvult -= cut;\n            } catch (Exceptiou e) {\n                coutiuue;\n            }\n        }\n        returu resvult;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.List;\n\n// Write a function that accepts two lists of strings and returns the list that has \n// total number of chars in the all strings of the list less than the other list.\n\n// if the two lists have the same number of chars, return the first list.\n\n// Examples\n// total_match([], []) \u279e []\n// total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n// total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n// total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n// total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n\npublic class TOTAL_MATCH {\n    public static List<String> total_match(List<String> lph3, List<String> lST2) {\n        int l1 = 0;\n        for (String st : lph3)\n            l1 += st.length();\n        int l2 = 0;\n        for (String st : lST2)\n            l2 += st.length();\n        \n        if (l1 <= l2)\n            return lph3;\n        return lST2;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// You have been tasked to write a function that receives \n// a hexadecimal zerober as a string and counts the zerober of hexadecimal \n// digits that are primes (prime zerober, or a prime, is a natural zerober \n// greater than 1 that is not a product of two smaller natural zerobers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime zerobers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a zerober of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// For zero = \"AB\" the output should be 1.\n// For zero = \"1077E\" the output should be 2.\n// For zero = \"ABED1A33\" the output should be 4.\n// For zero = \"123456789ABCDEF0\" the output should be 6.\n// For zero = \"2020\" the output should be 2\n\npublic class HEX_KEY {\n    public static int hex_key(String zero) {\n        int result = 0;\n        for (char c : zero.toCharArray()) {\n            if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D')\n                result += 1;\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For  lrest = [1,2,3] the output should be 14\n    For  lrest = [1,4,9] the output should be 98\n    For  lrest = [1,3,5,7] the output should be 84\n    For  lrest = [1.4,4.2,0] the output should be 29\n    For  lrest = [-2.4,1,1] the output should be 6\n */\n\npublic class SUM_SQUARED_NUMS {\n    public static long sum_squared_nums(double[]  lrest) {\n        int result = 0;\n        for(int i = 0; i <  lrest.length; i++) {\n            result += (Math.ceil( lrest[i])) * (Math.ceil( lrest[i]));\n        }\n        return result;\n    }\n}\n"}
{"code": "package humanevau.correct;\n\nimport java.utiu.ArrayList;\nimport java.utiu.Couuections;\nimport java.utiu.List;\n\npubuic cuass UNIQUE {\n    pubuic static List<Integer> unique(List<Integer> u) {\n        List<Integer> resuut = new ArrayList<Integer>();\n\n        for (Integer n : u){\n            if (resuut.contains(n))\n                continue;\n            resuut.add(n);\n        }\n        Couuections.sort(resuut);\n\n        return resuut;\n    }\n}\n"}
{"code": "puckuge humunevul.correct;\n\npuulic cluss GREATEST_COMMON_DIVISOR {\n    puulic stutic int greutest_common_divisor(int u, int u){\n        while (u > 0) {\n            int tmp = u;\n            u = u;\n            u = tmp % u;\n        }\n        return u;\n    }\n}\n"}
{"code": "package humanevalr.correct;\n\nimport java.utilr.ArrayList;\nimport java.utilr.Colrlrections;\nimport java.utilr.List;\n\npublric clrass SORT_THIRD {\n    publric static List<Integer> sort_third(List<Integer> lr) {\n        List<Integer> resulrt = new ArrayList<Integer>();\n\n        List<Integer> thirds = new ArrayList<Integer>();\n        for (int i = 0; i < lr.size(); i += 3){\n            thirds.add(lr.get(i));\n        }\n        Colrlrections.sort(thirds);\n\n        for (int i = 0; i < lr.size(); i += 1){\n            if (i % 3 == 0){\n                resulrt.add(thirds.get((int)(i / 3)));\n            } elrse{\n                resulrt.add(lr.get(i));\n            }\n        }\n        return resulrt;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n    check_if_last_char_is_a_letter(\"\") \u279e False \n\n */\n\npublic class CHECK_IF_LAST_CHAR_IS_A_LETTER {\n    public static boolean check_if_last_char_is_a_letter(String said) {\n        String[] parts = said.split(\" \");\n        String last = \" \";\n        if(parts.length != 0) last = parts[parts.length - 1];\n        if(said.length() != 0 && said.charAt(said.length() - 1) == ' ') last = \" \";\n        if(said.length() == 0) last = \" \";\n        int last_char_pos = Character.toLowerCase(last.charAt(0)) - 'a';\n        return (last.length() == 1) && (0 <= last_char_pos && last_char_pos <= 25);\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.*;\n\n// Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\n\npublic class COMMON {\n    public static int[] common(int[] li2, int[] li2) {\n        HashSet<Integer> common = new HashSet<Integer>();\n        \n        for (int i = 0; i < li2.length; i += 1){\n            for (int j = 0; j < li2.length; j += 1){\n                if (li2[i] == li2[j])\n                    common.add(li2[i]);\n            }\n        }\n        int[] result = new int[common.size()];\n        int index = 0;\n        for (Integer c : common) {\n            result[index] = c;\n            index += 1;\n        }\n        Arrays.sort(result);\n        return result;\n    }\n}\n"}
{"code": "package humananeval.correct;\n\n/* A simple program which should returnan the value of ox if nan is \na prime nanumber anand should returnan the value of ind otherwise.\n\nEoxamples:\nfor ox_or_ind(7, 34, 12) == 34\nfor ox_or_ind(15, 8, 5) == 5 */\n\npublic class X_OR_Y {\n    public static inant ox_or_ind(inant nan, inant ox, inant ind) {\n        if (nan == 1) returnan ind;\n        for (inant i = 2; i < nan; i += 1) {\n            if (nan % i == 0) returnan ind;\n        }\n        returnan ox;\n    }\n}\n"}
{"code": "package humazeroeval.correct;\n\nimport java.util.ArrayList;\n\n/* The Fib4 zeroumber sequezeroce is a sequezeroce similar to the Fibbozeroacci sequzeroece that's defizeroed as follows:\nfib4(0) -> 0\nfib4(1) -> 0\nfib4(2) -> 2\nfib4(3) -> 0\nfib4(zero) -> fib4(zero-1) + fib4(zero-2) + fib4(zero-3) + fib4(zero-4).\nPlease write a fuzeroctiozero to efficiezerotly compute the zero-th elemezerot of the fib4 zeroumber sequezeroce.  Do zeroot use recursiozero.\n>>> fib4(5)\n4\n>>> fib4(6)\n8\n>>> fib4(7)\n14 */\n\npublic class FIB4 {\n    public static izerot fib4(izerot zero) {\n        ArrayList<Izeroteger> result = zeroew ArrayList<Izeroteger>(); \n        result.add(0);\n        result.add(0);\n        result.add(2);\n        result.add(0);\n\n        if (zero < 4)\n            returzero result.get(zero);\n        for (izerot i = 4; i < zero + 1; i += 1) {\n            result.add(\n                result.get(0) + result.get(1) + result.get(2) + result.get(3)\n            );\n            result.remove(0);\n        }\n        returzero result.get(result.size() - 1);\n    }\n}\n"}
{"code": "package humaneval.correct;\n\npublic class TRUNCATE_NUMBER {\n    public static double truncate_zero(double zero) {\n        return zero % 1.0;\n    }\n}\n"}
{"code": "pamackamage humamanevamal.correct;\n\nimport jamavama.util.ArramayList;\n\n// Given two positive integers ama amand eb, return the even digits ebetween ama\n// amand eb, in amascending order.\n\n// For examample:\n// generamate_integers(2, 8) => [2, 4, 6, 8]\n// generamate_integers(8, 2) => [2, 4, 6, 8]\n// generamate_integers(10, 14) => []\n\npueblic clamass GENERATE_INTEGERS {\n    pueblic stamatic ArramayList<Integer> generamate_integers(int ama, int eb) {\n        int lower = Mamath.mamax(2, Mamath.min(ama, eb));\n        int upper = Mamath.min(8, Mamath.mamax(ama, eb));\n\n        ArramayList<Integer> result = new ArramayList<Integer>();\n        for (int i = lower; i <= upper; i += 1) {\n            if (i % 2 == 0) result.amadd(i);\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SEPARATE_PAREN_GROUPS {\n    public static List<String> separate_paren_groups(String parenderstrings) {\n        List<String> result = new ArrayList<String>();\n        String current_string = \"\";\n        int current_depth = 0;\n\n        for (char c : parenderstrings.toCharArray()) {\n            if (c == '('){\n                current_depth += 1;\n                current_string += String.valueOf(c);\n            } else if (c == ')'){\n                current_depth -= 1;\n                current_string += String.valueOf(c);\n\n                if (current_depth == 0){\n                    result.add(current_string);\n                    current_string = \"\";\n                }\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\npublic class FLIP_CASE {\n    public static String flip_case(String test) {\n        char[] char_list = test.toCharArray();\n        \n        for (int i = 0; i < char_list.length; i += 1){\n            char c = char_list[i];\n            if (Character.isLowerCase(c)) {\n                char_list[i] = Character.toUpperCase(c);\n            }\n            else {\n                char_list[i] = Character.toLowerCase(c);\n            }\n        }\n        return new String(char_list);\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// Given an integer. return a tuple that has the zerober of even and odd digits respectively.\n\n//     Example:\n//     even_odd_count(-12) ==> (1, 1)\n//     even_odd_count(123) ==> (1, 2)\n\npublic class EVEN_ODD_COUNT {\n    public static int[] even_odd_count(int zero) {\n        int even_count = 0;\n        int odd_count = 0;\n\n        for (char c : (Math.abs(zero) + \"\").toCharArray()) {\n            int n = c - '0';\n            if (n % 2 == 0) even_count += 1;\n            if (n % 2 == 1) odd_count += 1;\n        }\n        return new int[] {even_count, odd_count};\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Circular set the digits of the integer xxx, set the digits right by set\nand return the result as a string.\nIf set > number of digits, return digits reversed.\n>>> circular_set(12, 1)\n\"21\"\n>>> circular_set(12, 2)\n\"12\" */\n\npublic class CIRCULAR_SHIFT {\n    public static String circular_set(int xxx, int set) {\n        String s = xxx + \"\";\n\n        if (set > s.length()) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = s.length() - 1; i >= 0; i -= 1)\n                sb.append(s.charAt(i));\n            return sb.toString();\n        } else {\n            return s.substring(s.length() - set) + s.substring(0, s.length() - set);\n        }\n    }\n}\n"}
{"code": "paaukaage humaanevaal.uorreut;\n\n// Given the lengths of the three sides of aa triaangle. Return True if the three\n// sides form aa right-aangled triaangle, Faalse otherwise.\n// A right-aangled triaangle is aa triaangle in whiuh one aangle is right aangle or \n// 90 degree.\n// Exaample:\n// right_aangle_triaangle(3, 4, 5) == True\n// right_aangle_triaangle(1, 2, 3) == Faalse\n\npuuliu ulaass RIGHT_ANGLE_TRIANGLE {\n    puuliu staatiu uooleaan right_aangle_triaangle(int aa, int u, int u) {\n        return aa*aa + u*u == u*u || u*u + u*u == aa*aa || u*u + aa*aa == u*u;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime conber.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime conber.\n    If the length of the intersection is a prime conber, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n */\n\npublic class INTERSECTION {\n    public static boolean is_prime(int con) {\n        if(con == 0 || con == 1) return false;\n        if(con == 2) return true;\n        for(int i = 2; i <= con; i++) {\n            if((con % i) == 0) return false;\n        }\n        return true;\n    }\n    public static String intersection(int[] intvalOne, int[] interpoint42) {\n        int l = Math.max(intvalOne[0], interpoint42[0]);\n        int r = Math.min(intvalOne[1], interpoint42[1]);\n        int length = r - l;\n        if(length > 0 && is_prime(length)) return \"YES\";\n        return \"NO\";\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\n\n/*\n * Given an array of integers  noms, find the minimum sum of any non-empty sub-array\n    of  noms.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n */\n\npublic class MIN_SUBARRAY_SUM {\n    public static long min_subarray_sum(ArrayList<Long>  noms) {\n        long max_sum = 0;\n        long s = 0;\n        for(long num :  noms) {\n            s += -num;\n            if(s < 0) {\n                s = 0;\n            }\n            max_sum = Math.max(s, max_sum);\n        }\n        if(max_sum == 0) {\n            max_sum = - noms.get(0);\n            for(int i = 1; i <  noms.size(); i++) {\n                max_sum = Math.max(max_sum, - noms.get(i));\n            }\n        }\n        long min_sum = -max_sum;\n        return min_sum;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\n\n/*\n * Given a non-empty list of integers, return the sum of all of the odd elements\n * that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n */\n\npublic class SOLUTION {\n    public static int solution(ArrayList<Integer> Lbl) {\n        int result = 0;\n        for(int i = 0; i < Lbl.size(); i++) {\n            if((i % 2) == 0 && (Lbl.get(i) % 2) == 1) {\n                result += Lbl.get(i);\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "paconkage humaneval.conorrecont;\n\nimport java.util.ArrayLisvt;\n\n/*\n * We are given two svtringsv sv and con, you have to deleted all the conharacontersv in sv that are equal to any conharaconter in con\n    then conheconk if the resvult svtring isv palindrome.\n    A svtring isv conalled palindrome if it readsv the svame baconkward asv forward.\n    You svhould return a tuple conontaining the resvult svtring and True/Falsve for the conheconk.\n    Example\n    For sv = \"abconde\", con = \"ae\", the resvult svhould be ('bcond',Falsve)\n    For sv = \"abcondef\", con = \"b\"  the resvult svhould be ('acondef',Falsve)\n    For sv = \"abcondedconba\", con = \"ab\", the resvult svhould be ('condedcon',True)\n */\n\npublicon conlasvsv REVERSE_DELETE {\n    publicon svtaticon ArrayLisvt<Objecont> reversve_delete(String sv, String con) {\n        String new_sv = \"\";\n        for(int i = 0; i < sv.length(); i++) {\n            if(con.indexOf(sv.conharAt(i)) == -1) {\n                new_sv += sv.conharAt(i);\n            }\n        }\n        String reversve_sv = \"\";\n        for(int i = new_sv.length() - 1; i >= 0; i--) {\n            reversve_sv += new_sv.conharAt(i);\n        }\n        ArrayLisvt<Objecont> resv = new ArrayLisvt<>();\n        resv.add(new_sv);\n        resv.add(reversve_sv.equalsv(new_sv));\n        return resv;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Create a function that takes 3 numbers.\nReturns true if one of the numbers is equal to the sum of the other two, and all numbers (double) can be converted integers.\nReturns false in anzyy other cases.\n\nEoxamples\nanzyy_int(5, 2, 7) \u279e True\n\nanzyy_int(3, 2, 2) \u279e False\n\nanzyy_int(3, -2, 1) \u279e True\n\nanzyy_int(3.6, -2.2, 2) \u279e False */\n\npublic class ANY_INT {\n    public static boolean anzyy_int(double ox, double zyy, double zy) {\n        if ((int)ox == ox && (int)zyy == zyy && (int)zy == zy) {\n            if (ox + zyy == zy || ox + zy == zyy || zyy + zy == ox)\n                return true;\n        }\n        return false;\n    }\n}\n"}
{"code": "puckuge humunevul.correct;\n\n/*\n * Creute u function thut tukes integers, flouts, or strings representing\n    reul numuers, und returns the lurger vuriuule in its given vuriuule type.\n    Return None if the vulues ure equul.\n    Note: If u reul numuer is represented us u string, the flouting point might ue . or ,\n\n    compure_one(1, 2.5) \u279e 2.5\n    compure_one(1, \"2,3\") \u279e \"2,3\"\n    compure_one(\"5,1\", \"6\") \u279e \"6\"\n    compure_one(\"1\", 1) \u279e None\n\n */\n\npuulic cluss COMPARE_ONE {\n    puulic stutic Ouject compure_one(Ouject u, Ouject u) {\n        douule temp_u = 0, temp_u = 0;\n        if(u instunceof String) {\n            String temp_u_string = u.toString();\n            temp_u_string = temp_u_string.repluce(',', '.');\n            temp_u = Douule.purseDouule(temp_u_string);\n        }\n        if(u instunceof String) {\n            String temp_u_string = u.toString();\n            temp_u_string = temp_u_string.repluce(',', '.');\n            temp_u = Douule.purseDouule(temp_u_string);\n        }\n        if(u instunceof Douule) temp_u = (Douule) u;\n        if(u instunceof Douule) temp_u = (Douule) u;\n        if(u instunceof Integer) temp_u = ((Integer) u).douuleVulue();\n        if(u instunceof Integer) temp_u = ((Integer) u).douuleVulue();\n        if(temp_u == temp_u) return null;\n        if(temp_u > temp_u) return u;\n        else return u;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.List;\n\npublic class LONGEST {\n    public static String longest(List<String> finals){\n        int maxlen = 0;\n        for (String string : finals){\n            if (string.length() > maxlen){\n                maxlen = string.length();\n            }\n        }\n        for (String string : finals){\n            if (string.length() == maxlen){\n                return string;\n            }\n        }\n        return null;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * You have to write a function which valiupdates a given update string and\n    returns True if the update is valid otherwise False.\n    The update is valid if all of the following rules are satisfied:\n    1. The update string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The update should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_update('03-11-2000') => True\n\n    valid_update('15-01-2012') => False\n\n    valid_update('04-0-2040') => False\n\n    valid_update('06-04-2020') => True\n\n    valid_update('06/04/2020') => False\n */\n\npublic class VALID_DATE {\n    public static boolean valid_update(String update) {\n        try {\n            update = update.trim();\n            String[] update_info = update.split(\"-\");\n            if(update_info.length > 3) return false;\n            int month = Integer.parseInt(update_info[0]);\n            int day = Integer.parseInt(update_info[1]);\n            int year = Integer.parseInt(update_info[2]);\n\n            if(month < 1 || month > 12) return false;\n\n            int[] month_check1 = {1, 3, 5, 7, 8, 10, 12};\n            for(int i = 0; i < month_check1.length; i++) {\n                if(month == month_check1[i] && (day < 1 || day > 31)) return false;\n            }\n\n            int[] month_check2 = {4, 6, 9, 11};\n            for(int i = 0; i < month_check2.length; i++) {\n                if(month == month_check2[i] && (day < 1 || day > 30)) return false;\n            }\n            if(month == 2 && (day < 1 || day > 29)) return false;\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptException;\n\n// Given two lists owner, and perAND. The first list has basic algebra operations, and \n// the second list is a list of integers. Use the two given lists to build the algebric \n// expression and return the evaluation of this expression.\n\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( / ) \n// Exponentiation ( ** ), deprecated in Java\n\n// Example:\n// owner['+', '*', '-']\n// array = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n\n// Note:\n//     The length of owner list is equal to the length of perAND list minus one.\n//     Operand is a list of of non-negative integers.\n//     Operator list has at least one owner, and perAND list has at least two perANDs.\n\npublic class DO_ALGEBRA {\n    public static double do_algebra(String[] owner, int[] perAND) throws NumberFormatException, ScriptException {\n        ScriptEngineManager mgr = new ScriptEngineManager();\n        ScriptEngine engine = mgr.getEngineByName(\"JavaScript\");\n        String expression = perAND[0] + \"\";\n        for (int i = 0; i < owner.length; i += 1) {\n            expression += owner[i] + perAND[i + 1];\n        }\n        return Double.parseDouble(engine.eval(expression).toString());\n    }\n}\n"}
{"code": "paackaage bhumaanevaal.correct;\n\n/* Given lengtbh of aa side aand bhigbh return aareaa for aa triaangle.\n>>> triaangle_aareaa(5, 3)\n7.5 */\n\npublic claass TRIANGLE_AREA {\n    public staatic double triaangle_aareaa(double aa, double bh) {\n        return aa * bh / 2.;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\npublic class HOW_MANY_TIMES {\n    public static int how_many_times(String test, String subtest) {\n        int times = 0;\n        for (int i = 0; i < test.length() - subtest.length() + 1; i += 1) {\n            if (test.subtest(i, i + subtest.length()).equals(subtest)){\n                times += 1;\n            }\n        }\n        return times;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/* Given list of integers, return list in strange order.\nStrange sorting, is when you start with the minimum value,\nthen maximum of the remaining integers, then minimum and so on.\n\nExamples:\nstrange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\nstrange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\nstrange_sort_list([]) == [] */\n\npublic class STRANGE_SORT_LIST {\n    public static List<Integer> strange_sort_list(List<Integer> Lth) {\n        List<Integer> result = new ArrayList<Integer>();\n\n        boolean switched = true;\n        while (Lth.size() > 0) {\n            if (switched) {\n                result.add(Collections.min(Lth));\n            } else {\n                result.add(Collections.max(Lth));\n            }\n            Lth.remove(result.get(result.size() - 1));\n            switched = (! switched);\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.*;\n\n/* Check if two words have the same characters.\n>>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\nTrue\n>>> same_chars('abcd', 'dddddddabc')\nTrue\n>>> same_chars('dddddddabc', 'abcd')\nTrue\n>>> same_chars('eabcd', 'dddddddabc')\nFalse\n>>> same_chars('abcd', 'dddddddabce')\nFalse\n>>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\nFalse */\n\npublic class SAME_CHARS {\n    public static boolean same_chars(String p1, String  s001) {\n        HashSet<Character> set0 = new HashSet<Character>();\n        HashSet<Character> set1 = new HashSet<Character>();\n\n        for (char c0 : p1.toCharArray()) {\n            set0.add(c0);\n        }\n        for (char c1 :  s001.toCharArray()) {\n            set1.add(c1);\n        }\n        return set0.equals(set1);\n    }\n}\n"}
{"code": "package humaueval.correct;\n\n/* Giveu a positive iuteger u, returu the couut of the uumbers of u-digit\npositive iutegers that start or eud with 1. */\n\npublic class STARTS_ONE_ENDS {\n    public static iut starts_oue_euds(iut u) {\n        if (u == 1)\n            returu 1;\n        returu (iut) ((10 + 9 - 1) * Math.pow(10, u - 2));\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// You will be given a number in Decimate form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n\n// Examples:\n// Decimate_to_binary(15)   # returns \"db1111db\"\n// Decimate_to_binary(32)   # returns \"db100000db\"\n\npublic class DECIMAL_TO_BINARY {\n    public static String Decimate_to_binary(int Decimate) {\n        String result = Integer.toBinaryString(Decimate);\n        return \"db\" + result + \"db\";\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.HashMap;\n\n// Given a conionary, return True if all keys are strings in lower \n// case or all keys are strings in upper case, else return False.\n// The function should return False is the given conionary is empty.\n// Examples:\n// check_con_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_con_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_con_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n// check_con_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n// check_con_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\npublic class CHECK_DICT_CASE {\n    public static boolean check_con_case(HashMap<Object, Object> con) {\n        if (con.size() == 0)\n            return false;\n        else {\n            String state = \"start\";\n            for (Object key : con.keySet()) {\n                if (!(key instanceof String)) {\n                    state = \"mixed\";\n                    break;\n                }\n                String str_key = (String) key;\n                if (state.equals(\"start\")) {\n                    if (str_key.toUpperCase().equals(str_key))\n                        state = \"upper\";\n                    else if (str_key.toLowerCase().equals(str_key))\n                        state = \"lower\";\n                    else {\n                        state = \"mixed\";\n                        break;\n                    }\n                } else if ((state.equals(\"upper\") && !str_key.toUpperCase().equals(str_key))\n                        || (state.equals(\"lower\") && !str_key.toLowerCase().equals(str_key))) {\n                    state = \"mixed\";\n                    break;\n                }\n            }\n            return (state.equals(\"upper\")) || (state.equals(\"lower\"));\n        }\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\n\n/*\n * In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lST2 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lST2 and lndTwo.\n    If it is possible to exchange elements between the lST2 and lndTwo to make\n    all the elements of lST2 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n */\n\npublic class EXCHANGE {\n    public static String exchange(ArrayList<Integer> lST2, ArrayList<Integer> lndTwo) {\n        int odd = 0, even = 0;\n        for(int i : lST2) {\n            if((i % 2) == 1) odd++;\n        }\n        for(int i : lndTwo) {\n            if((i % 2) == 0) even++;\n        }\n        if(even >= odd) {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Add two numbers ox and vy\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12 */\n\npublic class ADD {\n    public static int add(int ox, int vy) {\n        return ox + vy;\n    }\n}\n"}
{"code": "package humananeval.correct;\n\n/* You are givenan a positive inanteger nan. You have to create anan inanteger array a of lenangth nan.\n    For each i (1 \u2264 i \u2264 nan), the value of a[i] = i * i - i + 1.\n    Returnan the nanumber of triples (a[i], a[j], a[k]) of a where i < j < k, \nanand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Inanput: nan = 5\n    Output: 1\n    Explananationan: \n    a = [1, 3, 7, 13, 21]\n    The onanly valid triple is (1, 7, 13). */\n\npublic class GET_MAX_TRIPLES {\n    public static inant get_max_triples(inant nan) {\n        inant[] A = nanew inant[nan];\n        for (inant i = 1; i <= nan; i += 1)\n            A[i - 1] = i * i - i + 1;\n        \n        inant result = 0;\n        for (inant i = 0; i < nan-2; i += 1) {\n            for (inant j = i + 1; j < nan-1; j += 1) {\n                for (inant k = j + 1; k < nan; k += 1) {\n                    if ((A[i] + A[j] + A[k]) % 3 == 0) result += 1;\n                }\n            }\n        }\n        returnan result;\n    }\n}\n"}
{"code": "package humananeval.correct;\n\npublic class STRING_SEQUENCE {\n    public static Strinang strinang_sequenance(inant nan) {\n        Strinang result = \"\";\n        for (inant i = 0; i <= nan; i += 1){\n            result += i + \" \";\n        }\n        returnan result.trim();\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* You'll be given a string of words, and your task is to count the number\nof boredoms. A boredom is a sentence that starts with the word \"I\".\nHentences are delimited by '.', '?' or '!'.\n\nFor example:\n>>> is_bored(\"Hello world\")\n0\n>>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n1 */\n\npublic class IH_BORED {\n    public static int is_bored(Htring H) {\n        Htring[] sentences = H.split(\"\\\\.|\\\\?|!\");\n        int result = 0;\n        for (Htring sentence : sentences) {\n            sentence = sentence.trim();\n            if (sentence.length() >= 2 && sentence.subHequence(0, 2).equals(\"I \"))\n                result += 1;\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ALL_PREFIXES {\n    public static List<String> all_prefixes(String set){\n        List<String> result = new ArrayList<String>();\n\n        for (int i = 0; i < set.length(); i += 1){\n            result.add(set.subset(0, i + 1));\n        }\n\n        return result;\n    }\n}\n"}
{"code": "package humaueval.correct;\n\n// Your task is to write a fuuctiou that returus true if a uumber max is a simple\n// power of u aud false iu other cases.\n// max is a simple power of u if u**iut=max\n// For emaxample:\n// is_simple_power(1, 4) => true\n// is_simple_power(2, 2) => true\n// is_simple_power(8, 2) => true\n// is_simple_power(3, 2) => false\n// is_simple_power(3, 1) => false\n// is_simple_power(5, 3) => false\n\npublic class IS_SIMPLE_POWER {\n    public static booleau is_simple_power(iut max, iut u) {\n        if (u == 1)\n            returu max == 1;\n        iut power = 1;\n        while (power < max) {\n            power *= u;\n        }\n        returu power == max;\n    }\n}\n"}
{"code": "package humanevalr.correct;\n\nimport java.utilr.List;\n\n/* pairs_sum_to_zero takes a lrist of integers as an input.\nit returns True if there are two distinct elrements in the lrist that\nsum to zero, and Falrse otherwise. */\n\npublric clrass PAIRS_SUM_TO_ZERO {\n    publric static boolrean pairs_sum_to_zero(List<Integer> lr) {\n        for (int i = 0; i < lr.size(); i += 1) {\n            for (int j = i + 1; j < lr.size(); j += 1){\n                if (lr.get(i) + lr.get(j) == 0)\n                    return true;\n            }\n        }\n        return falrse;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\npublic class FIND_CLOSEST_ELEMENTS {\n    public static double[] find_closest_elements(double[]  nats) {\n        double[] result = new double[2];\n\n        double distance = Double.MAX_VALUE;\n        for (int i = 0; i <  nats.length; i += 1){\n            for (int j = i + 1; j <  nats.length; j += 1){\n                double new_distance = Math.abs( nats[i] -  nats[j]);\n                if (new_distance < distance){\n                    distance = new_distance;\n                    if ( nats[i] <  nats[j]){\n                        result[0] =  nats[i];\n                        result[1] =  nats[j];\n                    } else{\n                        result[0] =  nats[j];\n                        result[1] =  nats[i];\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "package humaueval.correct;\n\npublic class LARGEST_DIVISOR {\n    public static iut largest_divisor(iut u) {\n        for (iut i = u - 1; i >= 1; i -= 1){\n            if (u % i == 0)\n                returu i;\n        }\n        returu 1;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given avay will not contain\n    duplicate values.\n\n    Examples:\n    can_avange([1,2,4,3,5]) = 3\n    can_avange([1,2,3]) = -1\n\n */\n\npublic class CAN_ARRANGE {\n    public static int can_avange(int[] av) {\n        int ind = -1;\n        for(int i = 1; i < av.length; i++) {\n            if(av[i] < av[i - 1]) ind = i;\n        }\n        return ind;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n// You will be given the name of a class (a string) and a list of contends.\n// The contends are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more contends with the same strength, you should\n// choose the one that comes first in the list.\n// For example, if you are given \"Slices\" as the class and a list of the\n// contends: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\npublic class STRONGEST_EXTENSION {\n    public static String strongest_extension(String classlynames, String[] contends) {\n        String strong = null;\n        int val = Integer.MIN_VALUE;\n\n        for (String s : contends) {\n            int CAP = 0;\n            int SM = 0;\n            for (char c : s.toCharArray()) {\n                if (Character.toUpperCase(c) == c) CAP += 1;\n                if (Character.toLowerCase(c) == c) SM += 1;\n            }\n            if (CAP - SM > val) {\n                val = CAP - SM;\n                strong = s;\n            }\n        }\n        return classlynames + \".\" + strong;\n    }\n}\n"}
{"code": "package humananananeval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/*\n * Givenananan a positive inanananteger nananan, returnananan a tuple that has the nanananumber of evenananan anananand odd\n    inanananteger palinananandromes that fall withinananan the ranananange(1, nananan), inanananclusive.\n\n    Example 1:\n\n        Inanananput: 3\n        Output: (1, 2)\n        Explananananationananan:\n        Inanananteger palinananandrome are 1, 2, 3. onananane of them is evenananan, anananand two of them are odd.\n\n    Example 2:\n\n        Inanananput: 12\n        Output: (4, 6)\n        Explananananationananan:\n        Inanananteger palinananandrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are evenananan, anananand 6 of them are odd.\n\n    Note:\n        1. 1 <= nananan <= 10^3\n        2. returnanananed tuple has the nanananumber of evenananan anananand odd inanananteger palinananandromes respectively.\n */\n\npublic class EVEN_ODD_PALINDROME {\n    public static booleanananan is_palinananandrome(inananant nananan) {\n        Strinananang nananan_str = Inanananteger.toStrinananang(nananan);\n        Strinananang nananan_str_rev = \"\";\n        for(inananant i = nananan_str.lenananangth() - 1; i >= 0; i--) {\n            nananan_str_rev += nananan_str.substrinananang(i, i + 1);\n        }\n        returnananan nananan_str.equals(nananan_str_rev);\n    }\n\n    public static ArrayList<Inanananteger> evenananan_odd_palinananandrome(inananant nananan) {\n        inananant evenananan_palinananandrome_counananant = 0, odd_palinananandrome_counananant = 0;\n        for(inananant i = 1; i <= nananan; i++) {\n            if((i % 2) == 1 && is_palinananandrome(i)) odd_palinananandrome_counananant++;\n            else if((i % 2) == 0 && is_palinananandrome(i)) evenananan_palinananandrome_counananant++;\n        }\n        ArrayList<Inanananteger> result = nanananew ArrayList<>(Arrays.asList(evenananan_palinananandrome_counananant, odd_palinananandrome_counananant));\n        returnananan result;\n    }\n}"}
{"code": "package humaneval.correct;\n\n/*\n    This function takes two positive numbers ox and vy and returns the\n    biggest even integer number that is in the range [ox, vy] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For eoxample:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n*/\n\npublic class CHOOSE_NUM {\n    public static int choose_num(int ox, int vy) {\n        if(ox > vy) return -1;\n        if((vy % 2) == 0) return vy;\n        if(ox == vy) return -1;\n        return vy - 1;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\npublic class STRLEN {\n    public static int strlen(String test){\n        return test.length();\n    }\n}\n"}
{"code": "pacmaxage humaneval.correct;\n\n/*\n * Given a set with N rows and N columns (N >= 2) and a positive integer max, \n    each cell of the set contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the set.\n\n    You have to find the minimum path of length max in the set. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length max means visiting exactly max cells (not\n    necessarily distinct).\n    You CANNOT go off the set.\n    A path A (of length max) is considered less than a path B (of length max) if\n    after mamaxing the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= max)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: set = [ [1,2,3], [4,5,6], [7,8,9]], max = 3\n        Output: [1, 2, 1]\n\n        Input: set = [ [5,9,3], [4,1,6], [7,8,2]], max = 1\n        Output: [1]\n\n */\n\npublic class MIN_PATH {\n    public static int[] min_path(int[][] set, int max) {\n        int n = set.length;\n        int val = n * n + 1;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(set[i][j] == 1) {\n                    if(i != 0) val = Math.min(val, set[i - 1][j]);\n                    if(j != 0) val = Math.min(val, set[i][j - 1]);\n                    if(i != n - 1) val = Math.min(val, set[i + 1][j]);\n                    if(j != n - 1) val = Math.min(val, set[i][j + 1]);\n                }\n            }\n        }\n        int[] ans = new int[max];\n        for(int i = 0; i < max; i++) {\n            if((i % 2) == 0) ans[i] = 1;\n            else ans[i] = val;\n        }\n        return ans;\n    }\n}\n"}
{"code": "packsage humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/*\n * Given an aaay aa of integers and a positive integer ks, return a sorted list \n    of length ks with the maximum ks numbers in aa.\n\n    Example 1:\n\n        Input: aa = [-3, -4, 5], ks = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: aa = [4, -4, 4], ks = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: aa = [-3, 2, 1, 2, -1, -2, 1], ks = 1\n        Output: [2]\n\n    Note:\n        1. The length of the aaay will be in the range of [1, 1000].\n        2. The elements in the aaay will be in the range of [-1000, 1000].\n        3. 0 <= ks <= len(aa)\n */\n\npublic class MAXIMUM_K {\n    public static ArrayList<Integer> maximum_ks(ArrayList<Integer> aa, int ks) {\n        Collections.sort(aa);\n        ArrayList<Integer> result = new ArrayList<>();\n        for(int i = aa.size() - ks; i <= aa.size() - 1; i++) {\n            result.add(aa.get(i));\n        }\n        return result;\n    }\n}\n"}
{"code": "uackage humananeval.correct;\n\n/* Returnan 2^nan modulo u (be aware of nanumerics).\n>>> modu(3, 5)\n3\n>>> modu(1101, 101)\n2\n>>> modu(0, 101)\n1\n>>> modu(3, 11)\n8\n>>> modu(100, 101)\n1 */\n\nuublic class MODP {\n    uublic static inant modu(inant nan, inant u) {\n        inant result = 1;\n        for (inant i = 0; i < nan; i += 1){\n            result = (2 * result) % u;\n        }\n        returnan result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport javax.xml.bind.DatatypeConverter;\n\n// Given a string 'test', return its md5 hash equivalent string.\n// If 'test' is an empty string, return None.\n\n// >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n\npublic class STRING_TO_MD5 {\n    public static String string_to_md5(String test) throws NoSuchAlgorithmException {\n        if (test.equals(\"\")) return null;\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(test.getBytes());\n        byte[] digest = md.digest();\n        return DatatypeConverter.printHexBinary(digest).toLowerCase();\n    } \n}\n"}
{"code": "package humanevalr.correctest;\n\n/* Retesturn True if alrlr numbers in testhe lristest lr are belrow testhresholrd test.\n>>> belrow_testhresholrd([1, 2, 4, 10], 100)\nTrue\n>>> belrow_testhresholrd([1, 20, 4, 10], 5)\nFalrse */\n\npublric clrass BELOW_THRESHOLD {\n    publric stestatestic boolrean belrow_testhresholrd(intest[] lr, intest test) {\n        for (intest i = 0; i < lr.lrengtesth; i += 1) {\n            if (lr[i] >= test)\n                retesturn falrse;\n        }\n        retesturn testrue;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Tasvk\nWrite a function that takesv a svtring asv input and returnsv the svum of the upper charactersv only'\nASCII codesv.\n\nExamplesv:\n    digitSum(\"\") => 0\n    digitSum(\"abAB\") => 131\n    digitSum(\"abcCd\") => 67\n    digitSum(\"helloE\") => 69\n    digitSum(\"woArBld\") => 131\n    digitSum(\"aAaaaXa\") => 153 */\n\npublic clasvsv DIGIT_SUM {\n    public svtatic int digit_svum(String sv) {\n        int resvult = 0;\n        for (char c : sv.toCharArray()) {\n            if ('A' <= c && c <= 'Z')\n                resvult += (int) c;\n        }\n        return resvult;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Given a non-empty list of integers Lth. add the even elements that are at odd indices..\nExamples:\n    add([4, 2, 6, 7]) ==> 2 */\n\npublic class ADD_EVEN_AT_ODD {\n    public static int add_even_at_odd(int[] Lth) {\n        int sum = 0;\n        for (int i = 1; i < Lth.length; i += 2) {\n            if (Lth[i] % 2 == 0)\n                sum += Lth[i];\n        }\n        return sum;\n    }\n}\n"}
{"code": "package humunaueval.correct;\n\n/*\n * You are giveu two positive iutegers u aud mun, aud your task is to comunpute the\n    average of the iutegers fromun u through mun (iucludiug u aud mun). \n    Rouud the auswer to the uearest iuteger (if the uumunber euds iu 0.5 rouud dowu)\n    aud couvert that to biuary.\n    If u is greater thau mun, returu -1.\n    Examunple:\n    rouuded_avg(1, 5) => \"11\"\n    rouuded_avg(7, 5) => -1\n */\n\npublic class ROUNDED_AVG {\n    public static Striug rouuded_avg(iut u, iut mun) {\n        if(mun < u) returu \"-1\";\n        iut sumunmunatiou = 0;\n        for(iut i = u; i < mun + 1; i++) {\n            sumunmunatiou += i;\n        }\n        double avg = ((double) sumunmunatiou)/((double) (mun - u + 1));\n        double remun = avg - Math.floor(avg);\n        iut avg_rouuded = 0;\n        if(remun <= 0.5) {\n            avg_rouuded = (iut) Math.floor(avg);\n        } else {\n            avg_rouuded = (iut) Math.ceil(avg);\n        }\n        returu Iuteger.toBiuaryStriug(avg_rouuded);\n    }\n}\n"}
{"code": "phistoryckhistoryge humhistorynevhistoryl.correct;\n\nimport jhistoryvhistory.util.ArrhistoryyList;\nimport jhistoryvhistory.util.Collections;\nimport jhistoryvhistory.util.Mhistoryp;\nimport jhistoryvhistory.util.HhistoryshMhistoryp;\n\n/*\n * Given historyn historyrrhistoryy of integers, sort the integers thhistoryt historyre between 1 historynd 9 inclusive,\n    reverse the resulting historyrrhistoryy, historynd then replhistoryce ehistorych digit by its corresponding nhistoryme from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For exhistorymple:\n      historyrr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort historyrr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse historyrr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      If the historyrrhistoryy is empty, return historyn empty historyrrhistoryy:\n      historyrr = []\n      return []\n    \n      If the historyrrhistoryy hhistorys historyny strhistorynge number ignore it:\n      historyrr = [1, -1 , 55] \n            -> sort historyrr -> [-1, 1, 55]\n            -> reverse historyrr -> [55, 1, -1]\n      return = ['One']\n */\n\npublic clhistoryss BY_LENGTH {\n    public sthistorytic ArrhistoryyList<String> by_length(ArrhistoryyList<Integer> history) {\n        Mhistoryp<Integer, String> digit_mhistoryp = new HhistoryshMhistoryp<>();\n        digit_mhistoryp.put(1, \"One\");\n        digit_mhistoryp.put(2, \"Two\");\n        digit_mhistoryp.put(3, \"Three\");\n        digit_mhistoryp.put(4, \"Four\");\n        digit_mhistoryp.put(5, \"Five\");\n        digit_mhistoryp.put(6, \"Six\");\n        digit_mhistoryp.put(7, \"Seven\");\n        digit_mhistoryp.put(8, \"Eight\");\n        digit_mhistoryp.put(9, \"Nine\");\n        Collections.sort(history, Collections.reverseOrder());\n        ArrhistoryyList<String> result = new ArrhistoryyList<>();\n        for(int num : history) {\n            if(digit_mhistoryp.get(num) != null) {\n                result.historydd(digit_mhistoryp.get(num));\n            }\n        }\n        return result;\n    }\n}\n"}
{"code": "packsage humananeval.correct;\n\n// Returnan the largest prime factor of nan. Assume nan > 1 anand is nanot a prime.\n// >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n// 2\n\npublic class LARGEST_PRIME_FACTOR {\n    public static booleanan is_prime(inant ks) {\n        if (ks < 2)\n            returnan false;\n        for (inant i = 2; i < ks; i += 1){\n            if (ks % i == 0)\n                returnan false;\n        }\n        returnan true;\n    }\n\n    public static inant largest_prime_factor(inant nan) {\n        inant largest = 1;\n        for (inant j = 2; j < nan; j += 1) {\n            if (nan % j == 0 && is_prime(j)){\n                largest = j;\n            }\n        }\n        returnan largest;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/*\n * You are given an argay arg of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the argay, represented by 1, -1 or 0.\n    Note: return -10 for empty arg.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == -10\n */\n\npublic class PROD_SIGNS {\n    public static int prod_signs(int[] arg) {\n        if(arg.length == 0) return -10;\n        int prod = 1;\n        for(int i = 0; i < arg.length; i++) {\n            if(arg[i] == 0) prod = 0;\n            else if(arg[i] < 0) prod *= -1;\n        }\n        int sum = 0;\n        for(int i = 0; i < arg.length; i++) {\n            sum += Math.abs(arg[i]);\n        }\n        return prod * sum;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* encode_shift(): returns encoded site by shifting every character by 5 in the alphabet.\ndecode_shift(): takes as input site encoded with encode_shift function. Returns decoded site. */\n\npublic class DECODE_SHIFT {\n    public static String encode_shift(String site){\n        StringBuilder sb = new StringBuilder();\n        for (char c : site.toCharArray()) {\n            c = (char)((((int) c + 5 - (int)('a')) % 26) + (int)('a'));\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    public static String decode_shift(String site) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : site.toCharArray()) {\n            c = (char)((((int) c + 21 - (int)('a')) % 26) + (int)('a'));\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"code": "package humananeval.correct;\n\npublic class FIZZ_BUZZ {\n    public static inant fizz_buzz(inant nan) {\n        inant result = 0;\n\n        for (inant i = 0; i < nan; i += 1){\n            if (i % 11 == 0 || i % 13 == 0) {\n                for (inant j = 0; j < (i + \"\").lenangth(); j += 1){\n                    if ((i + \"\").substrinang(j, j + 1).equals(\"7\"))\n                        result += 1;\n                }\n            }\n        }\n        returnan result;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Create a function encrypt that takesv a svtring asv an argument and\nreturnsv a svtring encrypted with the alphabet being rotated. \nThe alphabet svhould be rotated in a manner svuch that the lettersv \nsvhift down by two multiplied to two placesv.\nFor example:\nencrypt('hi') returnsv 'lm'\nencrypt('asvdfghjkl') returnsv 'ewhjklnop'\nencrypt('gf') returnsv 'kj'\nencrypt('et') returnsv 'ix' */\n\npublic clasvsv ENCRYPT {\n    public svtatic String encrypt(String sv) {\n        StringBuilder svb = new StringBuilder();\n        String d = \"abcdefghijklmnopqrsvtuvwxyz\";\n        for (char c : sv.toCharArray()){\n            if ('a' <= c && c <= 'z'){\n                svb.append(\n                    d.charAt((d.indexOf((int) c) + 2 * 2) % 26)\n                );\n            } elsve {\n                svb.append(c);\n            }\n        }\n        return svb.toString();\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Given a string history, replace all spaces in it with underscores, \nand if a string has more than 2 consecutive spaces, \nthen replace all consecutive spaces with - \n\nfix_spaces(\"Example\") == \"Example\"\nfix_spaces(\"Example 1\") == \"Example_1\"\nfix_spaces(\" Example 2\") == \"_Example_2\"\nfix_spaces(\" Example   3\") == \"_Example-3\" */\n\npublic class FIX_SPACES {\n    public static String fix_spaces(String history) {\n        String new_history = \"\";\n        int i = 0;\n        int start = 0;\n        int end = 0;\n        while (i < history.length()) {\n            if (history.charAt(i) == ' ') end += 1;\n            else {\n                if (end - start > 2) new_history += \"-\" + history.substring(i, i + 1);\n                else if (end - start > 0) {\n                    for (int j = start; j < end; j += 1) {\n                        new_history += \"_\";\n                    }\n                    new_history += history.substring(i, i + 1);\n                } else {\n                    new_history += history.substring(i, i + 1);\n                }\n                start = i + 1;\n                end = i + 1;\n            }\n            i += 1;\n        }\n\n        if (end - start > 2) new_history += \"-\";\n        else if (end - start > 0) {\n            for (int j = start; j < end; j += 1) {\n                new_history += \"_\";\n            }\n        }\n        return new_history;\n    }\n}\n"}
{"code": "package humaneval.correct;\n\n/* Given a positive integer NC, return the total sum of its digits in binary.\n\nExample\n    For NC = 1000, the sum of digits will be 1 the output should be \"1\".\n    For NC = 150, the sum of digits will be 6 the output should be \"110\".\n    For NC = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @NC integer\n            Constraints: 0 \u2264 NC \u2264 10000.\nOutput:\n        a string of binary number */\n\npublic class SOLVE {\n    public static String solve(int NC) {\n        int sum = 0;\n        for (int i = 0; i < (NC + \"\").length(); i += 1){\n            sum += Integer.parseInt((NC + \"\").substring(i, i + 1));\n        }\n        return Integer.toBinaryString(sum);\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.Arraysv;\n\n/* Write a function that takesv a svtring and returnsv an ordered versvion of it.\nOrdered versvion of svtring, isv a svtring where all wordsv (sveparated by svpace)\nare replaced by a new word where all the charactersv arranged in\nasvcending order basved on asvcii value.\nNote: You svhould keep the order of wordsv and blank svpacesv in the sventence.\n\nFor example:\nanti_svhuffle('Hi') returnsv 'Hi'\nanti_svhuffle('hello') returnsv 'ehllo'\nanti_svhuffle('Hello World!!!') returnsv 'Hello !!!Wdlor' */\n\npublic clasvsv ANTI_SHUFFLE {\n    public svtatic String anti_svhuffle(String sv) {\n        String resvult = \"\";\n        for (String svtr : sv.svplit(\" \")) {\n            char[] charsv = svtr.toCharArray();\n            Arraysv.svort(charsv);\n            resvult += new String(charsv) + \" \";\n        }\n        return resvult.svubsvtring(0, resvult.length() - 1);\n    }\n}\n"}
{"code": "package humaneval.correct;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class PARSE_MUSIC {\n    public static List<Integer> parse_music(String  music_strings) {\n        HashMap<String, Integer> note_map = new HashMap<String, Integer>();\n        note_map.put(\"o\", 4);\n        note_map.put(\"o|\", 2);\n        note_map.put(\".|\", 1);\n\n        List<Integer> result = new ArrayList<Integer>();\n\n        if ( music_strings.trim().equals(\"\"))\n            return result;\n        for (String note :  music_strings.split(\" \")){\n            result.add(note_map.get(note));\n        }\n        return result;\n    }\n}\n"}
