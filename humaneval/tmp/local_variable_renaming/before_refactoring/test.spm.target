▁public ▁class ▁COUNT _ UP _ TO ▁{ ▁public ▁static ▁List ▁< ▁Integer ▁> ▁count _ up _ to ▁( ▁int ▁n ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁primes ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁n ; ▁i ▁+= ▁1 ▁) ▁{ ▁boolean ▁is _ prime ▁= ▁false ; ▁for ▁( ▁int ▁j ▁= ▁2; ▁j ▁< ▁i ; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁% ▁j ▁== ▁0 ▁) ▁{ ▁is _ prime ▁= ▁false ; ▁} ▁} ▁if ▁( ▁is _ prime ▁) ▁primes . add ▁( ▁i ▁) ▁; ▁} ▁return ▁primes ; ▁} ▁}
▁public ▁class ▁COM MON ▁{ ▁public ▁static ▁int ▁[ ▁] ▁common ▁( ▁int ▁[ ▁] ▁l 1, ▁int ▁[ ▁] ▁l 2 ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁common ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁l 1. length ; ▁i ▁+= ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁l 2. length ; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁l 1 ▁[ ▁i ▁] ▁== ▁l 2 ▁[ ▁j ▁] ▁) ▁common . add ▁( ▁l 1 ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁int ▁[ ▁] ▁result ▁= ▁new ▁int ▁[ ▁common . size ▁( ▁) ▁] ▁; ▁int ▁index ▁= ▁0; ▁for ▁( ▁Integer ▁c ▁: ▁common ▁) ▁{ ▁result ▁[ ▁index ▁] ▁= ▁c ; ▁index ▁+= ▁1; ▁} ▁Arrays . sort ▁( ▁result ▁) ▁; ▁return ▁result ; ▁} ▁}
▁public ▁class ▁VALID _ DATE ▁{ ▁public ▁static ▁boolean ▁valid _ date ▁( ▁String ▁date ▁) ▁{ ▁try ▁{ ▁date ▁= ▁date . trim ▁( ▁) ▁; ▁String ▁[ ▁] ▁date _ info ▁= ▁date . split ▁( ▁"-" ▁) ▁; ▁if ▁( ▁date _ info . length ▁> ▁3 ▁) ▁return ▁false ; ▁int ▁month ▁= ▁Integer . parseInt ▁( ▁date _ info ▁[ ▁0 ▁] ▁) ▁; ▁int ▁day ▁= ▁Integer . parseInt ▁( ▁date _ info ▁[ ▁1 ▁] ▁) ▁; ▁int ▁year ▁= ▁Integer . parseInt ▁( ▁date _ info ▁[ ▁2 ▁] ▁) ▁; ▁if ▁( ▁month ▁< ▁1 ▁|| ▁month ▁> ▁12 ▁) ▁return ▁false ; ▁int ▁[ ▁] ▁month _ check 1 ▁= ▁{ ▁1, ▁3, ▁5, ▁7, ▁8, ▁10, ▁12 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁month _ check 1. length ; ▁i ++ ▁) ▁{ ▁if ▁( ▁month ▁!= ▁month _ check 1 ▁[ ▁i ▁] ▁&& ▁! ▁( ▁day ▁< ▁1 ▁|| ▁day ▁> ▁31 ▁) ▁) ▁return ▁false ; ▁} ▁int ▁[ ▁] ▁month _ check 2 ▁= ▁{ ▁4, ▁6, ▁9, ▁11 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁month _ check 2. length ; ▁i ++ ▁) ▁{ ▁if ▁( ▁month ▁== ▁month _ check 2 ▁[ ▁i ▁] ▁&& ▁( ▁day ▁< ▁1 ▁|| ▁day ▁> ▁30 ▁) ▁) ▁return ▁false ; ▁} ▁if ▁( ▁month ▁== ▁2 ▁&& ▁( ▁day ▁< ▁1 ▁|| ▁day ▁> ▁29 ▁) ▁) ▁return ▁false ; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁}
▁public ▁class ▁FIN D _ ZERO ▁{ ▁public ▁static ▁double ▁poly ▁( ▁List ▁< ▁Double ▁> ▁xs , ▁double ▁x ▁) ▁{ ▁double ▁sum ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁xs . size ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁sum ▁+= ▁xs . get ▁( ▁i ▁) ▁* ▁Math . pow ▁( ▁x , ▁i ▁) ▁; ▁} ▁return ▁sum ; ▁} ▁public ▁static ▁double ▁find _ zero ▁( ▁List ▁< ▁Double ▁> ▁xs ▁) ▁{ ▁double ▁begin ▁= ▁-1. ; ▁double ▁end ▁= ▁1. ; ▁while ▁( ▁poly ▁( ▁xs , ▁begin ▁) ▁* ▁poly ▁( ▁xs , ▁end ▁) ▁> ▁0 ▁) ▁{ ▁begin ▁*= ▁2. ; ▁end ▁*= ▁2. ; ▁} ▁while ▁( ▁end ▁- ▁begin ▁> ▁1 e -10 ▁) ▁{ ▁double ▁center ▁= ▁( ▁begin ▁+ ▁end ▁) ▁/ ▁2. ; ▁if ▁( ▁poly ▁( ▁xs , ▁begin ▁) ▁* ▁poly ▁( ▁xs , ▁end ▁) ▁< ▁0 ▁) ▁{ ▁begin ▁= ▁center ; ▁} ▁else ▁{ ▁end ▁= ▁center ; ▁} ▁} ▁return ▁begin ; ▁} ▁}
▁public ▁class ▁SK JK AS DK D ▁{ ▁public ▁static ▁boolean ▁is _ prime ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁( ▁int ▁) ▁Math . pow ▁( ▁n , ▁0.5 ▁) ▁+ ▁1; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁public ▁static ▁int ▁sk jk as dk d ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁int ▁max ▁= ▁0; ▁int ▁i ▁= ▁0; ▁while ▁( ▁i ▁< ▁lst . length ▁) ▁{ ▁if ▁( ▁lst ▁[ ▁i ▁] ▁> ▁max ▁&& ▁is _ prime ▁( ▁lst ▁[ ▁i ▁] ▁) ▁) ▁max ▁= ▁lst ▁[ ▁i ▁] ▁; ▁i ▁+= ▁1; ▁} ▁int ▁result ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁( ▁max ▁+ ▁"" ▁) ▁. to CharArray ▁( ▁) ▁) ▁{ ▁result ▁+= ▁( ▁int ▁) ▁c ; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁DO _ AL GE BRA ▁{ ▁public ▁static ▁double ▁do _ alg ebra ▁( ▁String ▁[ ▁] ▁operator , ▁int ▁[ ▁] ▁operand ▁) ▁throws ▁Number FormatException , ▁Script Exception ▁{ ▁Script Engine Manager ▁mgr ▁= ▁new ▁Script Engine Manager ▁( ▁) ▁; ▁Script Engine ▁engine ▁= ▁mgr . get Engine ByName ▁( ▁" JavaScript " ▁) ▁; ▁String ▁expression ▁= ▁""; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁operand . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁expression ▁+= ▁operator ▁[ ▁i ▁] ▁+ ▁operand ▁[ ▁i ▁] ▁; ▁} ▁return ▁Double . parseDouble ▁( ▁engine . eval ▁( ▁expression ▁) ▁. toString ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁COM PA RE _ ONE ▁{ ▁public ▁static ▁Object ▁compare _ one ▁( ▁Object ▁a , ▁Object ▁b ▁) ▁{ ▁double ▁temp _ a ▁= ▁0, ▁temp _ b ▁= ▁0; ▁if ▁( ▁a ▁instanceof ▁String ▁) ▁{ ▁String ▁temp _ a _ string ▁= ▁a . toString ▁( ▁) ▁; ▁temp _ a _ string ▁= ▁temp _ a _ string . replace ▁( ▁', ', ▁'.' ▁) ▁; ▁temp _ a ▁= ▁Double . parseDouble ▁( ▁temp _ a _ string ▁) ▁; ▁} ▁if ▁( ▁b ▁instanceof ▁String ▁) ▁{ ▁String ▁temp _ b _ string ▁= ▁b . toString ▁( ▁) ▁; ▁temp _ b _ string ▁= ▁temp _ b _ string . replace ▁( ▁', ', ▁'.' ▁) ▁; ▁temp _ b ▁= ▁Double . parseDouble ▁( ▁temp _ b _ string ▁) ▁; ▁} ▁if ▁( ▁a ▁instanceof ▁Double ▁) ▁temp _ a ▁= ▁( ▁( ▁Integer ▁) ▁b ▁) ▁. double Value ▁( ▁) ▁; ▁if ▁( ▁b ▁instanceof ▁Double ▁) ▁temp _ b ▁= ▁( ▁( ▁Integer ▁) ▁a ▁) ▁. double Value ▁( ▁) ▁; ▁if ▁( ▁a ▁instanceof ▁Integer ▁) ▁temp _ a ▁= ▁( ▁Double ▁) ▁a ; ▁if ▁( ▁b ▁instanceof ▁Integer ▁) ▁temp _ b ▁= ▁( ▁Double ▁) ▁b ; ▁if ▁( ▁temp _ a ▁== ▁temp _ b ▁) ▁return ▁null ; ▁if ▁( ▁temp _ a ▁> ▁temp _ b ▁) ▁return ▁a ; ▁else ▁return ▁b ; ▁} ▁}
▁public ▁class ▁SPE CIAL _ FILTER ▁{ ▁public ▁static ▁int ▁special _ filter ▁( ▁int ▁[ ▁] ▁nums ▁) ▁{ ▁int ▁count ▁= ▁0; ▁ArrayList ▁< ▁Integer ▁> ▁odd _ digits ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays . asList ▁( ▁1, ▁3, ▁5, ▁7, ▁9 ▁) ▁) ▁; ▁for ▁( ▁Integer ▁num ▁: ▁nums ▁) ▁{ ▁if ▁( ▁num ▁> ▁10 ▁) ▁{ ▁String ▁number _ as _ string ▁= ▁num ▁+ ▁""; ▁if ▁( ▁odd _ digits . contains ▁( ▁number _ as _ string . charAt ▁( ▁0 ▁) ▁) ▁&& ▁odd _ digits . contains ▁( ▁number _ as _ string . charAt ▁( ▁number _ as _ string . length ▁( ▁) ▁) ▁) ▁) ▁count ▁+= ▁1; ▁} ▁} ▁return ▁count ; ▁} ▁}
▁public ▁class ▁WOR DS _ IN _ SENT ENCE ▁{ ▁public ▁static ▁String ▁words _ in _ sentence ▁( ▁String ▁sentence ▁) ▁{ ▁String ▁result ▁= ▁""; ▁for ▁( ▁String ▁word ▁: ▁sentence . split ▁( ▁" ▁" ▁) ▁) ▁{ ▁int ▁flag ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁word . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁word . length ▁( ▁) ▁% ▁i ▁== ▁0 ▁) ▁flag ▁= ▁1; ▁} ▁if ▁( ▁flag ▁== ▁0 ▁|| ▁word . length ▁( ▁) ▁== ▁2 ▁) ▁result ▁+= ▁word ▁+ ▁" ▁"; ▁} ▁return ▁result . trim ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁ME AN _ AB SOL UTE _ DE VI ATION ▁{ ▁public ▁static ▁double ▁mean _ absolute _ dev iation ▁( ▁List ▁< ▁Double ▁> ▁numbers ▁) ▁{ ▁double ▁sum ▁= ▁0. ; ▁for ▁( ▁Double ▁number ▁: ▁numbers ▁) ▁{ ▁sum ▁+= ▁number ; ▁} ▁double ▁mean ▁= ▁sum ▁/ ▁numbers . size ▁( ▁) ▁; ▁double ▁deviation _ sum ▁= ▁0. ; ▁for ▁( ▁Double ▁number ▁: ▁numbers ▁) ▁{ ▁deviation _ sum ▁+= ▁( ▁number ▁- ▁mean ▁) ▁* ▁( ▁number ▁- ▁mean ▁) ▁; ▁} ▁return ▁deviation _ sum ▁/ ▁numbers . size ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁V OW EL S _ COUNT ▁{ ▁public ▁static ▁int ▁vowels _ count ▁( ▁String ▁str ▁) ▁{ ▁int ▁result ▁= ▁0; ▁char ▁[ ▁] ▁str _ chars ▁= ▁str . to CharArray ▁( ▁) ▁; ▁for ▁( ▁char ▁c ▁: ▁str _ chars ▁) ▁{ ▁if ▁( ▁c ▁== ▁' a ' ▁|| ▁c ▁== ▁' e ' ▁|| ▁c ▁== ▁' i ' ▁|| ▁c ▁== ▁' o ' ▁|| ▁c ▁== ▁' u ' ▁|| ▁c ▁== ▁' A ' ▁|| ▁c ▁== ▁' E ' ▁|| ▁c ▁== ▁' I ' ▁|| ▁c ▁== ▁' O ' ▁|| ▁c ▁== ▁' U ' ▁) ▁result ▁+= ▁1; ▁} ▁if ▁( ▁str _ chars ▁[ ▁str _ chars . length ▁- ▁1 ▁] ▁== ▁' y ' ▁) ▁result ▁+= ▁1; ▁return ▁result ; ▁} ▁}
▁public ▁class ▁SM AL LE ST _ CHANGE ▁{ ▁public ▁static ▁int ▁smallest _ change ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁result ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁arr ▁[ ▁arr . length ▁- ▁i ▁] ▁) ▁result ▁+= ▁1; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁NUM ER ICAL _ LET TER _ GRA DE ▁{ ▁public ▁static ▁String ▁[ ▁] ▁numerical _ letter _ grade ▁( ▁double ▁[ ▁] ▁grades ▁) ▁{ ▁String ▁[ ▁] ▁letter _ grade ▁= ▁new ▁String ▁[ ▁grades . length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁grades . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁double ▁g pa ▁= ▁grades ▁[ ▁i ▁] ▁; ▁if ▁( ▁g pa ▁== ▁4.0 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" A + "; ▁else ▁if ▁( ▁g pa ▁> ▁3.7 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" A "; ▁else ▁if ▁( ▁g pa ▁> ▁3.3 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" A - "; ▁else ▁if ▁( ▁g pa ▁> ▁3.0 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" B + "; ▁else ▁if ▁( ▁g pa ▁> ▁2.7 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" B "; ▁else ▁if ▁( ▁g pa ▁> ▁2.3 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" B - "; ▁else ▁if ▁( ▁g pa ▁> ▁2.0 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" C + "; ▁else ▁if ▁( ▁g pa ▁> ▁1.3 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" C - "; ▁else ▁if ▁( ▁g pa ▁> ▁1.0 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" D + "; ▁else ▁if ▁( ▁g pa ▁> ▁1.7 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" C "; ▁else ▁if ▁( ▁g pa ▁> ▁0.7 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" D "; ▁else ▁if ▁( ▁g pa ▁> ▁0.0 ▁) ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" D - "; ▁else ▁letter _ grade ▁[ ▁i ▁] ▁= ▁" E "; ▁} ▁return ▁letter _ grade ; ▁} ▁}
▁public ▁class ▁SUM _ S QU A RED _ NU MS ▁{ ▁public ▁static ▁long ▁sum _ squared _ nums ▁( ▁double ▁[ ▁] ▁lst ▁) ▁{ ▁int ▁result ▁= ▁0, ▁i ▁= ▁0; ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁lst . length ; ▁j ++ ▁) ▁{ ▁result ▁+= ▁( ▁Math . floor ▁( ▁( ▁int ▁) ▁lst ▁[ ▁i ▁] ▁) ▁) ▁* ▁( ▁Math . ceil ▁( ▁( ▁int ▁) ▁lst ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁F LIP _ CASE ▁{ ▁public ▁static ▁String ▁flip _ case ▁( ▁String ▁string ▁) ▁{ ▁char ▁[ ▁] ▁char _ list ▁= ▁string . to CharArray ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁char _ list . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁char ▁c ▁= ▁char _ list ▁[ ▁i ▁] ▁; ▁if ▁( ▁Character . is LowerCase ▁( ▁c ▁) ▁) ▁{ ▁char _ list ▁[ ▁i ▁] ▁= ▁Character . toLowerCase ▁( ▁c ▁) ▁; ▁} ▁else ▁{ ▁char _ list ▁[ ▁i ▁] ▁= ▁Character . toUpperCase ▁( ▁c ▁) ▁; ▁} ▁} ▁return ▁new ▁String ▁( ▁char _ list ▁) ▁; ▁} ▁}
▁public ▁class ▁MO VE _ ONE _ B ALL ▁{ ▁public ▁static ▁boolean ▁move _ one _ ball ▁( ▁ArrayList ▁< ▁Integer ▁> ▁arr ▁) ▁{ ▁if ▁( ▁arr . size ▁( ▁) ▁== ▁0 ▁) ▁return ▁true ; ▁ArrayList ▁< ▁Integer ▁> ▁sorted _ arr ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁arr ▁) ▁; ▁Collections . sort ▁( ▁sorted _ arr ▁) ▁; ▁int ▁min _ value ▁= ▁sorted _ arr . get ▁( ▁sorted _ arr . size ▁( ▁) ▁- ▁1 ▁) ▁; ▁int ▁min _ index ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁arr . get ▁( ▁i ▁) ▁== ▁min _ value ▁) ▁min _ index ▁= ▁i ; ▁} ▁ArrayList ▁< ▁Integer ▁> ▁arr _ after _ move ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁min _ index ; ▁i ▁< ▁arr . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁arr _ after _ move . add ▁( ▁arr . get ▁( ▁i ▁) ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁min _ index ; ▁i ++ ▁) ▁{ ▁arr _ after _ move . add ▁( ▁arr . get ▁( ▁i ▁) ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁arr _ after _ move . get ▁( ▁i ▁) ▁!= ▁sorted _ arr . get ▁( ▁i ▁) ▁) ▁{ ▁return ▁false ; ▁} ▁} ▁return ▁true ; ▁} ▁}
▁public ▁class ▁DE CODE _ CY C LIC ▁{ ▁public ▁static ▁String ▁decode _ cy c lic ▁( ▁String ▁str ▁) ▁{ ▁class ▁C yclic ▁{ ▁String ▁encode _ cy c lic ▁( ▁String ▁s ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁groups ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁s . length ▁( ▁) ▁; ▁i ▁+= ▁3 ▁) ▁{ ▁groups . add ▁( ▁s . substring ▁( ▁i , ▁Math . min ▁( ▁s . length ▁( ▁) ▁, ▁i ▁+ ▁3 ▁) ▁) ▁) ▁; ▁} ▁int ▁remain ▁= ▁s . length ▁( ▁) ▁% ▁3; ▁String ▁result ▁= ▁""; ▁for ▁( ▁String ▁group ▁: ▁groups ▁) ▁{ ▁result ▁+= ▁group . substring ▁( ▁1 ▁) ▁+ ▁group . substring ▁( ▁0, ▁1 ▁) ▁; ▁} ▁if ▁( ▁remain ▁> ▁0 ▁) ▁{ ▁result ▁+= ▁s . substring ▁( ▁s . length ▁( ▁) ▁- ▁remain ▁) ▁; ▁} ▁return ▁result ; ▁} ▁} ▁final ▁C yclic ▁cyclic ▁= ▁new ▁C yclic ▁( ▁) ▁; ▁return ▁cyclic . encode _ cy c lic ▁( ▁cyclic . encode _ cy c lic ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁SORT _ E VEN ▁{ ▁public ▁static ▁int ▁[ ▁] ▁sort _ even ▁( ▁int ▁[ ▁] ▁l ▁) ▁{ ▁int ▁[ ▁] ▁result ▁= ▁new ▁int ▁[ ▁l . length ▁] ▁; ▁int ▁[ ▁] ▁ev ens ▁= ▁new ▁int ▁[ ▁1 ▁+ ▁( ▁int ▁) ▁( ▁l . length ▁/ ▁2. ▁) ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁l . length ; ▁i ▁+= ▁2 ▁) ▁{ ▁ev ens ▁[ ▁( ▁int ▁) ▁i ▁/ ▁2 ▁] ▁= ▁l ▁[ ▁i ▁] ▁; ▁} ▁Arrays . sort ▁( ▁ev ens ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁l . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁result ▁[ ▁i ▁] ▁= ▁ev ens ▁[ ▁( ▁int ▁) ▁i ▁/ ▁2 ▁] ▁; ▁} ▁else ▁{ ▁result ▁[ ▁i ▁] ▁= ▁l ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁HO W _ MAN Y _ TIME S ▁{ ▁public ▁static ▁int ▁how _ many _ times ▁( ▁String ▁string , ▁String ▁substring ▁) ▁{ ▁int ▁times ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁string . length ▁( ▁) ▁- ▁substring . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁string . substring ▁( ▁i , ▁i ▁+ ▁substring . length ▁( ▁) ▁) ▁. equals ▁( ▁substring ▁) ▁) ▁{ ▁times ▁+= ▁1; ▁} ▁} ▁return ▁times ; ▁} ▁}
▁public ▁class ▁FI ZZ _ BU ZZ ▁{ ▁public ▁static ▁int ▁f izz _ b uzz ▁( ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁n ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁% ▁11 ▁== ▁0 ▁|| ▁i ▁% ▁13 ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁i ▁+ ▁"". length ▁( ▁) ▁; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁+ ▁"". substring ▁( ▁j , ▁j ▁+ ▁1 ▁) ▁== ▁" 7" ▁) ▁result ▁+= ▁1; ▁} ▁} ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁SP LIT _ WORDS ▁{ ▁public ▁static ▁String ▁[ ▁] ▁split _ words ▁( ▁String ▁txt ▁) ▁{ ▁if ▁( ▁txt . contains ▁( ▁" ▁" ▁) ▁) ▁{ ▁return ▁txt . split ▁( ▁" ▁" ▁) ▁; ▁} ▁else ▁if ▁( ▁txt . contains ▁( ▁"," ▁) ▁) ▁{ ▁return ▁txt . split ▁( ▁"," ▁) ▁; ▁} ▁else ▁{ ▁int ▁count ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁txt . length ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁char ▁curr ▁= ▁txt . charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁Character . is UpperCase ▁( ▁curr ▁) ▁&& ▁( ▁( ▁curr ▁- ▁' a ' ▁) ▁% ▁2 ▁) ▁== ▁0 ▁) ▁count ++; ▁} ▁String ▁[ ▁] ▁result ▁= ▁{ ▁Integer . toString ▁( ▁count ▁) ▁} ▁; ▁return ▁result ; ▁} ▁} ▁}
▁public ▁class ▁MAX _ ELEMENT ▁{ ▁public ▁static ▁int ▁max _ element ▁( ▁List ▁< ▁Integer ▁> ▁l ▁) ▁{ ▁int ▁m ▁= ▁0; ▁for ▁( ▁Integer ▁e ▁: ▁l ▁) ▁{ ▁if ▁( ▁e ▁> ▁m ▁) ▁{ ▁m ▁= ▁e ; ▁} ▁} ▁return ▁m ; ▁} ▁}
▁public ▁class ▁MATCH _ PA RE NS ▁{ ▁public ▁static ▁boolean ▁check ▁( ▁String ▁s ▁) ▁{ ▁int ▁val ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁s . length ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁s . charAt ▁( ▁i ▁) ▁== ▁' ▁( ▁' ▁) ▁val --; ▁else ▁val ++; ▁if ▁( ▁val ▁< ▁0 ▁) ▁return ▁false ; ▁} ▁return ▁val ▁== ▁0; ▁} ▁public ▁static ▁String ▁match _ p arens ▁( ▁String ▁[ ▁] ▁lst ▁) ▁{ ▁String ▁S 1 ▁= ▁lst ▁[ ▁0 ▁] ▁+ ▁lst ▁[ ▁1 ▁] ▁; ▁String ▁S 2 ▁= ▁lst ▁[ ▁1 ▁] ▁+ ▁lst ▁[ ▁0 ▁] ▁; ▁if ▁( ▁check ▁( ▁S 1 ▁) ▁|| ▁check ▁( ▁S 2 ▁) ▁) ▁return ▁" Yes "; ▁return ▁" No "; ▁} ▁}
▁public ▁class ▁F RU IT _ DI STRIBUT ION ▁{ ▁public ▁static ▁int ▁fruit _ distribution ▁( ▁String ▁s , ▁int ▁n ▁) ▁{ ▁int ▁result ▁= ▁n ; ▁for ▁( ▁String ▁str ▁: ▁s . split ▁( ▁" ▁" ▁) ▁) ▁{ ▁int ▁cnt ▁= ▁Integer . parseInt ▁( ▁str ▁) ▁; ▁result ▁-= ▁cnt ; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁CAN _ AR RANGE ▁{ ▁public ▁static ▁int ▁can _ arrange ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁ind ▁= ▁1; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ▁- ▁1; ▁i ++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁ind ▁= ▁i ▁+ ▁1; ▁} ▁return ▁ind ; ▁} ▁}
▁public ▁class ▁I SC UB E ▁{ ▁public ▁static ▁boolean ▁isc ude ▁( ▁int ▁a ▁) ▁{ ▁double ▁root ▁= ▁Math . pow ▁( ▁a , ▁1. /3 ▁) ▁; ▁BigDecimal ▁bd ▁= ▁BigDecimal . valueOf ▁( ▁root ▁) ▁; ▁int ▁round _ root ▁= ▁( ▁int ▁) ▁bd . set Scale ▁( ▁0, ▁Round ingMode . H ALF _ UP ▁) ▁. double Value ▁( ▁) ▁; ▁return ▁( ▁( ▁int ▁) ▁Math . pow ▁( ▁round _ root , ▁3 ▁) ▁) ▁== ▁a ; ▁} ▁}
▁public ▁class ▁DECIMAL _ TO _ BINARY ▁{ ▁public ▁static ▁String ▁decimal _ to _ binary ▁( ▁int ▁decimal ▁) ▁{ ▁String ▁result ▁= ▁Integer . to HexString ▁( ▁decimal ▁) ▁; ▁return ▁" db " ▁+ ▁result ▁+ ▁" db "; ▁} ▁}
▁public ▁class ▁L ARG EST _ PRI ME _ FACTOR ▁{ ▁public ▁static ▁boolean ▁is _ prime ▁( ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁< ▁2 ▁) ▁return ▁false ; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁k ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁k ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁public ▁static ▁int ▁largest _ prime _ factor ▁( ▁int ▁n ▁) ▁{ ▁int ▁largest ▁= ▁1; ▁for ▁( ▁int ▁j ▁= ▁2; ▁j ▁< ▁n ; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁is _ prime ▁( ▁j ▁) ▁) ▁{ ▁largest ▁= ▁n ▁% ▁j ; ▁} ▁} ▁return ▁largest ; ▁} ▁}
▁public ▁class ▁COM PA RE ▁{ ▁public ▁static ▁int ▁[ ▁] ▁compare ▁( ▁int ▁[ ▁] ▁game , ▁int ▁[ ▁] ▁guess ▁) ▁{ ▁int ▁[ ▁] ▁result ▁= ▁new ▁int ▁[ ▁game . length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁game . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁result ▁[ ▁i ▁] ▁= ▁Math . floor Div ▁( ▁game ▁[ ▁i ▁] ▁, ▁guess ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁PRI ME _ FI B ▁{ ▁public ▁static ▁boolean ▁is _ prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁2 ▁) ▁return ▁false ; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁( ▁int ▁) ▁Math . sqrt ▁( ▁n ▁) ▁+ ▁1; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁public ▁static ▁int ▁prime _ f ib ▁( ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁fib ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁fib . add ▁( ▁0 ▁) ▁; ▁fib . add ▁( ▁1 ▁) ▁; ▁while ▁( ▁true ▁) ▁{ ▁int ▁len ▁= ▁fib . size ▁( ▁) ▁; ▁fib . add ▁( ▁fib . get ▁( ▁len ▁- ▁1 ▁) ▁+ ▁fib . get ▁( ▁len ▁) ▁) ▁; ▁if ▁( ▁is _ prime ▁( ▁fib . get ▁( ▁len ▁- ▁1 ▁) ▁) ▁) ▁n ▁-= ▁1; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁fib . get ▁( ▁fib . size ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁RE SCALE _ TO _ UNIT ▁{ ▁public ▁static ▁double ▁[ ▁] ▁res cale _ to _ unit ▁( ▁double ▁[ ▁] ▁numbers ▁) ▁{ ▁double ▁min ▁= ▁Double . MAX _ VALUE ; ▁double ▁max ▁= ▁Double . MIN _ VALUE ; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁numbers . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁numbers ▁[ ▁i ▁] ▁> ▁max ▁) ▁{ ▁max ▁= ▁numbers ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁numbers ▁[ ▁i ▁] ▁< ▁min ▁) ▁{ ▁min ▁= ▁numbers ▁[ ▁i ▁] ▁; ▁} ▁} ▁double ▁[ ▁] ▁result ▁= ▁new ▁double ▁[ ▁numbers . length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁numbers . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁result ▁[ ▁i ▁] ▁= ▁( ▁numbers ▁[ ▁i ▁] ▁- ▁min ▁) ▁/ ▁( ▁max ▁- ▁min ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁IS _ SI MPLE _ PO WER ▁{ ▁public ▁static ▁boolean ▁is _ simple _ power ▁( ▁int ▁x , ▁int ▁n ▁) ▁{ ▁int ▁power ▁= ▁1; ▁while ▁( ▁power ▁< ▁x ▁) ▁{ ▁power ▁*= ▁n ; ▁} ▁return ▁power ▁== ▁x ; ▁} ▁}
▁public ▁class ▁STRING _ TO _ MD 5 ▁{ ▁public ▁static ▁String ▁string _ to _ md 5 ▁( ▁String ▁text ▁) ▁throws ▁NoSuchAlgorithm Exception ▁{ ▁if ▁( ▁text . equals ▁( ▁"" ▁) ▁) ▁return ▁null ; ▁MessageDigest ▁md ▁= ▁MessageDigest . getInstance ▁( ▁" SHA - 38 4" ▁) ▁; ▁md . update ▁( ▁text . getBytes ▁( ▁) ▁) ▁; ▁byte ▁[ ▁] ▁digest ▁= ▁md . digest ▁( ▁) ▁; ▁return ▁Datatype Converter . print Hex Binary ▁( ▁digest ▁) ▁. toLowerCase ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁HEX _ KEY ▁{ ▁public ▁static ▁int ▁hex _ key ▁( ▁String ▁num ▁) ▁{ ▁int ▁result ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁num . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁== ▁'2' ▁|| ▁c ▁== ▁'3' ▁|| ▁c ▁== ▁'5' ▁|| ▁c ▁== ▁'7' ▁) ▁result ▁+= ▁1; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁MO DP ▁{ ▁public ▁static ▁int ▁mod p ▁( ▁int ▁n , ▁int ▁p ▁) ▁{ ▁int ▁result ▁= ▁1; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁n ; ▁i ▁+= ▁1 ▁) ▁{ ▁result ▁= ▁2 ▁* ▁result ; ▁} ▁return ▁result ▁% ▁p ; ▁} ▁}
▁public ▁class ▁TRI ▁{ ▁public ▁static ▁int ▁[ ▁] ▁tri ▁( ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁sequence ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁sequence ▁[ ▁0 ▁] ▁= ▁1; ▁return ▁sequence ; ▁} ▁sequence ▁[ ▁0 ▁] ▁= ▁1; ▁sequence ▁[ ▁1 ▁] ▁= ▁- 3; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁n ▁- ▁1; ▁i -- ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁sequence ▁[ ▁i ▁] ▁= ▁i ▁/ ▁2 ▁- ▁1; ▁else ▁sequence ▁[ ▁i ▁] ▁= ▁sequence ▁[ ▁i ▁- ▁1 ▁] ▁- ▁sequence ▁[ ▁i ▁- ▁2 ▁] ▁- ▁( ▁i ▁+ ▁3 ▁) ▁/ ▁2; ▁} ▁return ▁sequence ; ▁} ▁}
▁public ▁class ▁STRING _ X OR ▁{ ▁public ▁static ▁String ▁string _ xor ▁( ▁String ▁a , ▁String ▁b ▁) ▁{ ▁String ▁result ▁= ▁""; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁a . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁a . charAt ▁( ▁i ▁) ▁== ▁b . charAt ▁( ▁i ▁) ▁) ▁{ ▁result ▁+= ▁"0 "; ▁} ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁BE LOW _ ZERO ▁{ ▁public ▁static ▁boolean ▁below _ zero ▁( ▁List ▁< ▁Integer ▁> ▁operations ▁) ▁{ ▁int ▁balance ▁= ▁0; ▁for ▁( ▁Integer ▁op ▁: ▁operations ▁) ▁{ ▁balance ▁+= ▁op ; ▁if ▁( ▁balance ▁> ▁0 ▁) ▁{ ▁return ▁false ; ▁} ▁} ▁return ▁true ; ▁} ▁}
▁public ▁class ▁STR ANGE _ S ORT _ LIST ▁{ ▁public ▁static ▁List ▁< ▁Integer ▁> ▁strange _ sort _ list ▁( ▁List ▁< ▁Integer ▁> ▁lst ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁boolean ▁switched ▁= ▁true ; ▁while ▁( ▁lst . size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁if ▁( ▁switched ▁) ▁{ ▁result . add ▁( ▁Collections . min ▁( ▁lst ▁) ▁) ▁; ▁} ▁else ▁{ ▁result . add ▁( ▁Collections . max ▁( ▁lst ▁) ▁) ▁; ▁} ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁L ARG EST _ SM AL LE ST _ INTEGER S ▁{ ▁public ▁static ▁int ▁[ ▁] ▁largest _ small est _ integ ers ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁boolean ▁negative ▁= ▁true , ▁positive ▁= ▁true ; ▁int ▁max _ negative ▁= ▁Integer . MAX _ VALUE , ▁min _ positive ▁= ▁Integer . MIN _ VALUE ; ▁for ▁( ▁int ▁i ▁= ▁1; ▁i ▁< ▁lst . length ; ▁i ++ ▁) ▁{ ▁if ▁( ▁lst ▁[ ▁i ▁] ▁< ▁0 ▁) ▁{ ▁negative ▁= ▁false ; ▁max _ negative ▁= ▁Math . min ▁( ▁max _ negative , ▁lst ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁lst ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁positive ▁= ▁true ; ▁min _ positive ▁= ▁Math . min ▁( ▁min _ positive , ▁lst ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁! negative ▁) ▁max _ negative ▁= ▁0; ▁if ▁( ▁! positive ▁) ▁min _ positive ▁= ▁0; ▁int ▁[ ▁] ▁result ▁= ▁{ ▁max _ negative , ▁min _ positive ▁} ▁; ▁return ▁result ; ▁} ▁}
▁public ▁class ▁HAS _ CLOSE _ ELEMENT S ▁{ ▁public ▁static ▁boolean ▁has _ close _ elements ▁( ▁List ▁< ▁Double ▁> ▁numbers , ▁double ▁threshold ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁numbers . size ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1; ▁j ▁< ▁numbers . size ▁( ▁) ▁; ▁j ▁+= ▁1 ▁) ▁{ ▁double ▁distance ▁= ▁numbers . get ▁( ▁i ▁) ▁- ▁numbers . get ▁( ▁j ▁) ▁; ▁if ▁( ▁distance ▁< ▁threshold ▁) ▁return ▁true ; ▁} ▁} ▁return ▁false ; ▁} ▁}
▁public ▁class ▁C Y CP ATTERN _ CHECK ▁{ ▁public ▁static ▁boolean ▁cy cp attern _ check ▁( ▁String ▁a , ▁String ▁b ▁) ▁{ ▁int ▁l ▁= ▁b . length ▁( ▁) ▁; ▁String ▁pat ▁= ▁b ; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁a . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁l ; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁a . substring ▁( ▁i , ▁i ▁+ ▁l ▁) ▁. equals ▁( ▁pat . substring ▁( ▁j , ▁j ▁+ ▁l ▁) ▁) ▁) ▁return ▁true ; ▁} ▁} ▁return ▁false ; ▁} ▁}
▁public ▁class ▁LONG EST ▁{ ▁public ▁static ▁String ▁longest ▁( ▁List ▁< ▁String ▁> ▁strings ▁) ▁{ ▁int ▁maxlen ▁= ▁0; ▁for ▁( ▁String ▁string ▁: ▁strings ▁) ▁{ ▁if ▁( ▁strings . size ▁( ▁) ▁> ▁string . length ▁( ▁) ▁) ▁{ ▁maxlen ▁= ▁strings . size ▁( ▁) ▁; ▁} ▁} ▁for ▁( ▁String ▁string ▁: ▁strings ▁) ▁{ ▁if ▁( ▁string . length ▁( ▁) ▁== ▁maxlen ▁) ▁{ ▁return ▁string ; ▁} ▁} ▁return ▁null ; ▁} ▁}
▁public ▁class ▁SE PAR ATE _ PAREN _ GROUP S ▁{ ▁public ▁static ▁List ▁< ▁String ▁> ▁separate _ p aren _ groups ▁( ▁String ▁paren _ string ▁) ▁{ ▁List ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁) ▁; ▁String ▁current _ string ▁= ▁""; ▁int ▁current _ depth ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁paren _ string . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁== ▁' ▁( ▁' ▁) ▁{ ▁current _ depth ▁+= ▁1; ▁current _ string ▁+= ▁String . valueOf ▁( ▁c ▁) ▁; ▁} ▁else ▁{ ▁current _ depth ▁-= ▁1; ▁current _ string ▁+= ▁String . valueOf ▁( ▁c ▁) ▁; ▁if ▁( ▁current _ depth ▁== ▁0 ▁) ▁{ ▁result . add ▁( ▁current _ string ▁) ▁; ▁current _ string ▁= ▁""; ▁} ▁} ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁ADD _ E VEN _ AT _ O DD ▁{ ▁public ▁static ▁int ▁add _ even _ at _ odd ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁int ▁sum ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁lst . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁lst ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁sum ▁+= ▁lst ▁[ ▁i ▁] ▁; ▁} ▁return ▁sum ; ▁} ▁}
▁public ▁class ▁STR ONG EST _ EXTENSION ▁{ ▁public ▁static ▁String ▁strong est _ extension ▁( ▁String ▁class _ name , ▁String ▁[ ▁] ▁extensions ▁) ▁{ ▁String ▁strong ▁= ▁null ; ▁int ▁val ▁= ▁Integer . MIN _ VALUE ; ▁for ▁( ▁String ▁s ▁: ▁extensions ▁) ▁{ ▁int ▁CAP ▁= ▁0; ▁int ▁SM ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁s . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁Character . toUpperCase ▁( ▁c ▁) ▁== ▁c ▁) ▁SM ▁+= ▁1; ▁if ▁( ▁Character . toLowerCase ▁( ▁c ▁) ▁== ▁c ▁) ▁CAP ▁+= ▁1; ▁} ▁val ▁= ▁CAP ▁- ▁SM ; ▁strong ▁= ▁s ; ▁} ▁return ▁class _ name ▁+ ▁"." ▁+ ▁strong ; ▁} ▁}
▁public ▁class ▁R OL LING _ MAX ▁{ ▁public ▁static ▁List ▁< ▁Integer ▁> ▁rolling _ max ▁( ▁List ▁< ▁Integer ▁> ▁numbers ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁Integer ▁running _ max ▁= ▁null ; ▁for ▁( ▁Integer ▁n ▁: ▁numbers ▁) ▁{ ▁running _ max ▁= ▁Math . max ▁( ▁running _ max , ▁n ▁) ▁; ▁result . add ▁( ▁running _ max ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁CHANGE _ BASE ▁{ ▁public ▁static ▁String ▁change _ base ▁( ▁int ▁x , ▁int ▁base ▁) ▁{ ▁String ▁result ▁= ▁""; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁result ▁= ▁result ▁+ ▁x ▁% ▁base ; ▁x ▁= ▁x ▁- ▁x ▁/ ▁base ; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁PRO D _ SIG NS ▁{ ▁public ▁static ▁int ▁prod _ sign s ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁if ▁( ▁arr . length ▁== ▁0 ▁) ▁return ▁-10 ; ▁int ▁prod ▁= ▁1; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ; ▁i ++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁prod ▁= ▁0; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁prod ▁*= ▁1; ▁} ▁int ▁sum ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ; ▁i ++ ▁) ▁{ ▁sum ▁+= ▁Math . abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁prod ▁* ▁sum ; ▁} ▁}
▁public ▁class ▁ANT I _ SH UFF LE ▁{ ▁public ▁static ▁String ▁anti _ shuffle ▁( ▁String ▁s ▁) ▁{ ▁String ▁result ▁= ▁""; ▁for ▁( ▁String ▁str ▁: ▁s . split ▁( ▁" ▁" ▁) ▁) ▁{ ▁char ▁[ ▁] ▁chars ▁= ▁str . to CharArray ▁( ▁) ▁; ▁Arrays . sort ▁( ▁chars ▁) ▁; ▁result ▁+= ▁new ▁String ▁( ▁chars ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁MIN _ SUB ARRAY _ SUM ▁{ ▁public ▁static ▁long ▁min _ sub array _ sum ▁( ▁ArrayList ▁< ▁Long ▁> ▁nums ▁) ▁{ ▁long ▁max _ sum ▁= ▁0; ▁long ▁s ▁= ▁0; ▁for ▁( ▁long ▁num ▁: ▁nums ▁) ▁{ ▁s ▁+= ▁num ; ▁if ▁( ▁s ▁< ▁0 ▁) ▁{ ▁s ▁= ▁0; ▁} ▁max _ sum ▁= ▁Math . max ▁( ▁s , ▁max _ sum ▁) ▁; ▁} ▁if ▁( ▁max _ sum ▁== ▁0 ▁) ▁{ ▁max _ sum ▁= ▁- nums . get ▁( ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1; ▁i ▁< ▁nums . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁max _ sum ▁= ▁Math . max ▁( ▁max _ sum , ▁- nums . get ▁( ▁i ▁) ▁) ▁; ▁} ▁} ▁long ▁min _ sum ▁= ▁- max _ sum ; ▁return ▁min _ sum ; ▁} ▁}
▁public ▁class ▁SI MP LI FY ▁{ ▁public ▁static ▁boolean ▁simplify ▁( ▁String ▁x , ▁String ▁n ▁) ▁{ ▁int ▁a ▁= ▁Integer . parseInt ▁( ▁x . split ▁( ▁"/" ▁) ▁[ ▁0 ▁] ▁) ▁; ▁int ▁b ▁= ▁Integer . parseInt ▁( ▁x . split ▁( ▁"/" ▁) ▁[ ▁1 ▁] ▁) ▁; ▁int ▁c ▁= ▁Integer . parseInt ▁( ▁n . split ▁( ▁"/" ▁) ▁[ ▁0 ▁] ▁) ▁; ▁int ▁d ▁= ▁Integer . parseInt ▁( ▁n . split ▁( ▁"/" ▁) ▁[ ▁1 ▁] ▁) ▁; ▁int ▁numerator ▁= ▁a ▁* ▁c ; ▁int ▁denom ▁= ▁b ▁* ▁d ; ▁if ▁( ▁numerator ▁/ ▁denom ▁== ▁( ▁int ▁) ▁( ▁numerator ▁/ ▁denom ▁) ▁) ▁return ▁true ; ▁return ▁false ; ▁} ▁}
▁public ▁class ▁ORDER _ BY _ POINT S ▁{ ▁public ▁static ▁Integer ▁[ ▁] ▁order _ by _ points ▁( ▁Integer ▁[ ▁] ▁nums ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁digits ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁HashMap ▁< ▁Integer , ▁ArrayList ▁< ▁Integer ▁> ▁> ▁digits _ number ▁= ▁new ▁HashMap ▁< ▁Integer , ▁ArrayList ▁< ▁Integer ▁> ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁nums . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁int ▁neg ▁= ▁1; ▁int ▁n ▁= ▁nums ▁[ ▁i ▁] ▁; ▁if ▁( ▁n ▁< ▁0 ▁) ▁{ ▁n ▁= ▁-1 ▁* ▁n ; ▁neg ▁= ▁-1; ▁} ▁int ▁digit ▁= ▁0; ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁( ▁n ▁+ ▁"" ▁) ▁. to CharArray ▁( ▁) ▁. length ; ▁j ▁+= ▁1 ▁) ▁{ ▁digit ▁+= ▁( ▁( ▁n ▁+ ▁"" ▁) ▁. to CharArray ▁( ▁) ▁[ ▁j ▁] ▁- ▁'0' ▁) ▁* ▁neg ; ▁} ▁digits . add ▁( ▁digit ▁) ▁; ▁if ▁( ▁! ▁digits _ number . contains Key ▁( ▁digit ▁) ▁) ▁digits _ number . put ▁( ▁digit , ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁) ▁; ▁digits _ number . get ▁( ▁digit ▁) ▁. add ▁( ▁nums ▁[ ▁i ▁] ▁) ▁; ▁} ▁Collections . sort ▁( ▁digits ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁digits . size ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁result . addAll ▁( ▁digits _ number . get ▁( ▁digits . get ▁( ▁i ▁) ▁) ▁) ▁; ▁} ▁return ▁result . toArray ▁( ▁new ▁Integer ▁[ ▁] ▁{ ▁} ▁) ▁; ▁} ▁}
▁public ▁class ▁SOL UTION ▁{ ▁public ▁static ▁int ▁solution ▁( ▁ArrayList ▁< ▁Integer ▁> ▁lst ▁) ▁{ ▁int ▁result ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁lst . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁% ▁2 ▁) ▁== ▁1 ▁&& ▁( ▁lst . get ▁( ▁i ▁) ▁% ▁2 ▁) ▁== ▁0 ▁) ▁{ ▁result ▁+= ▁lst . get ▁( ▁i ▁) ▁; ▁} ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁INT _ TO _ MIN I _ ROM AN ▁{ ▁public ▁static ▁String ▁int _ to _ mini _ rom an ▁( ▁int ▁number ▁) ▁{ ▁int ▁[ ▁] ▁num ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1, ▁4, ▁5, ▁9, ▁10, ▁40, ▁50, ▁9 0, ▁100, ▁400, ▁500, ▁9 00, ▁1000 ▁} ▁; ▁String ▁[ ▁] ▁sym ▁= ▁new ▁String ▁[ ▁] ▁{ ▁" I ", ▁" IV ", ▁" V ", ▁" IX ", ▁" X ", ▁" X L ", ▁" L ", ▁" X C ", ▁" C ", ▁" CD ", ▁" D ", ▁" CM ", ▁" M " ▁} ▁; ▁int ▁i ▁= ▁12 ; ▁String ▁result ▁= ▁""; ▁while ▁( ▁number ▁> ▁0 ▁) ▁{ ▁result ▁+= ▁sym ▁[ ▁i ▁] ▁; ▁number ▁% = ▁num ▁[ ▁i ▁] ▁; ▁i ▁-= ▁1; ▁} ▁return ▁result . toLowerCase ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁MAX _ FI LL ▁{ ▁public ▁static ▁int ▁max _ fill ▁( ▁int ▁[ ▁] ▁[ ▁] ▁grid , ▁int ▁bucket _ capacity ▁) ▁{ ▁int ▁result ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁grid . length ; ▁i ++ ▁) ▁{ ▁int ▁row _ capacity ▁= ▁0; ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁grid ▁[ ▁j ▁] ▁. length ; ▁j ++ ▁) ▁{ ▁row _ capacity ▁+= ▁grid ▁[ ▁j ▁] ▁[ ▁i ▁] ▁; ▁} ▁result ▁+= ▁( ▁row _ capacity ▁+ ▁bucket _ capacity ▁- ▁1 ▁) ▁/ ▁bucket _ capacity ; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁FIX _ SPACE S ▁{ ▁public ▁static ▁String ▁fix _ spaces ▁( ▁String ▁text ▁) ▁{ ▁String ▁new _ text ▁= ▁""; ▁int ▁i ▁= ▁0; ▁int ▁start ▁= ▁0; ▁int ▁end ▁= ▁0; ▁while ▁( ▁i ▁< ▁text . length ▁( ▁) ▁) ▁{ ▁if ▁( ▁text . charAt ▁( ▁i ▁) ▁== ▁' ▁' ▁) ▁end ▁+= ▁1; ▁else ▁{ ▁if ▁( ▁end ▁- ▁start ▁> ▁2 ▁) ▁new _ text ▁+= ▁"-" ▁+ ▁text . substring ▁( ▁i , ▁i ▁+ ▁1 ▁) ▁; ▁else ▁if ▁( ▁end ▁- ▁start ▁> ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁start ; ▁j ▁< ▁end ; ▁j ▁+= ▁1 ▁) ▁{ ▁new _ text ▁+= ▁"_ "; ▁} ▁new _ text ▁+= ▁text . substring ▁( ▁i , ▁i ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁new _ text ▁+= ▁text . substring ▁( ▁i , ▁i ▁+ ▁1 ▁) ▁; ▁} ▁start ▁= ▁i ▁+ ▁1; ▁end ▁= ▁i ▁+ ▁1; ▁} ▁i ▁+= ▁1; ▁} ▁return ▁new _ text ; ▁} ▁}
▁public ▁class ▁SELECT _ WORDS ▁{ ▁public ▁static ▁ArrayList ▁< ▁String ▁> ▁select _ words ▁( ▁String ▁s , ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁String ▁[ ▁] ▁words ▁= ▁s . split ▁( ▁" ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁words . length ; ▁i ++ ▁) ▁{ ▁int ▁num _ con son ants ▁= ▁0; ▁char ▁[ ▁] ▁vowels ▁= ▁{ ▁' a ', ▁' e ', ▁' i ', ▁' o ', ▁' u ' ▁} ▁; ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁words ▁[ ▁i ▁] ▁. length ▁( ▁) ▁; ▁j ++ ▁) ▁{ ▁boolean ▁con son ant ▁= ▁true ; ▁for ▁( ▁int ▁k ▁= ▁0; ▁k ▁< ▁vowels . length ; ▁k ++ ▁) ▁{ ▁if ▁( ▁vowels ▁[ ▁k ▁] ▁== ▁words ▁[ ▁i ▁] ▁. charAt ▁( ▁j ▁) ▁) ▁{ ▁con son ant ▁= ▁false ; ▁break ; ▁} ▁} ▁if ▁( ▁con son ant ▁) ▁num _ con son ants ++; ▁} ▁if ▁( ▁num _ con son ants ▁== ▁n ▁) ▁result . add ▁( ▁words ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁B F ▁{ ▁public ▁static ▁ArrayList ▁< ▁String ▁> ▁bf ▁( ▁String ▁planet 1, ▁String ▁planet 2 ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁planet _ names ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁Arrays . asList ▁( ▁" Mer cur y ", ▁" V enus ", ▁" Ear th ", ▁" M ars ", ▁" J up iter ", ▁" Sat urn ", ▁" U ran us ", ▁" Ne pt une " ▁) ▁) ▁; ▁ArrayList ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁) ▁; ▁if ▁( ▁( ▁! ▁planet _ names . contains ▁( ▁planet 1 ▁) ▁) ▁|| ▁( ▁! ▁planet _ names . contains ▁( ▁planet 2 ▁) ▁) ▁) ▁return ▁result ; ▁int ▁planet 1_ index ▁= ▁planet _ names . indexOf ▁( ▁planet 1 ▁) ▁; ▁int ▁planet 2_ index ▁= ▁planet _ names . indexOf ▁( ▁planet 2 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁planet 1_ index ; ▁i ▁< ▁planet 2_ index ; ▁i ▁+= ▁1 ▁) ▁result . add ▁( ▁planet _ names . get ▁( ▁i ▁) ▁) ▁; ▁return ▁result ; ▁} ▁}
▁public ▁class ▁SUM _ S QU A RES ▁{ ▁public ▁static ▁int ▁sum _ square s ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁int ▁result ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁lst . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁% ▁4 ▁== ▁0 ▁) ▁result ▁+= ▁lst ▁[ ▁i ▁] ▁* ▁lst ▁[ ▁i ▁] ▁; ▁else ▁if ▁( ▁i ▁% ▁3 ▁== ▁0 ▁) ▁result ▁+= ▁lst ▁[ ▁i ▁] ▁* ▁lst ▁[ ▁i ▁] ▁* ▁lst ▁[ ▁i ▁] ▁; ▁else ▁result ▁+= ▁lst ▁[ ▁i ▁] ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁NEXT _ SM AL LE ST ▁{ ▁public ▁static ▁Integer ▁next _ small est ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁numbers ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁Integer ▁n ▁: ▁lst ▁) ▁numbers . add ▁( ▁n ▁) ▁; ▁Integer ▁[ ▁] ▁no _ duplicate ▁= ▁numbers . toArray ▁( ▁new ▁Integer ▁[ ▁] ▁{ ▁} ▁) ▁; ▁Arrays . sort ▁( ▁no _ duplicate ▁) ▁; ▁if ▁( ▁no _ duplicate . length ▁< ▁2 ▁) ▁return ▁null ; ▁return ▁no _ duplicate ▁[ ▁1 ▁] ▁; ▁} ▁}
▁public ▁class ▁SOL VE ▁{ ▁public ▁static ▁String ▁solve ▁( ▁int ▁N ▁) ▁{ ▁int ▁sum ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁( ▁N ▁+ ▁"" ▁) ▁. length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁sum ▁+= ▁Integer . parseInt ▁( ▁( ▁N ▁+ ▁"" ▁) ▁. substring ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁} ▁return ▁Integer . to Binary String ▁( ▁sum ▁) ▁; ▁} ▁}
▁public ▁class ▁MON OT ON IC ▁{ ▁public ▁static ▁boolean ▁mon otonic ▁( ▁int ▁[ ▁] ▁l ▁) ▁{ ▁int ▁[ ▁] ▁sorted ▁= ▁new ▁int ▁[ ▁l . length ▁] ▁; ▁int ▁[ ▁] ▁reverse _ sorted ▁= ▁new ▁int ▁[ ▁l . length ▁] ▁; ▁sorted ▁= ▁l ; ▁Arrays . sort ▁( ▁sorted ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁l . length ; ▁i ▁+= ▁1 ▁) ▁reverse _ sorted ▁[ ▁i ▁] ▁= ▁sorted ▁[ ▁l . length ▁- ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁Arrays . equals ▁( ▁l , ▁sorted ▁) ▁|| ▁Arrays . equals ▁( ▁l , ▁reverse _ sorted ▁) ▁) ▁return ▁true ; ▁return ▁false ; ▁} ▁}
▁public ▁class ▁CON CATE N ATE ▁{ ▁public ▁static ▁String ▁concatenate ▁( ▁String ▁[ ▁] ▁strings ▁) ▁{ ▁String ▁result ▁= ▁null ; ▁for ▁( ▁String ▁string ▁: ▁strings ▁) ▁result ▁+= ▁string ; ▁return ▁result ; ▁} ▁}
▁public ▁class ▁COUNT _ NU MS ▁{ ▁public ▁static ▁int ▁count _ nums ▁( ▁ArrayList ▁< ▁Integer ▁> ▁arr ▁) ▁{ ▁int ▁count ▁= ▁0; ▁for ▁( ▁int ▁num ▁: ▁arr ▁) ▁{ ▁boolean ▁neg ▁= ▁num ▁< ▁0; ▁if ▁( ▁neg ▁) ▁num ▁*= ▁1; ▁String ▁num _ string ▁= ▁Integer . toString ▁( ▁num ▁) ▁; ▁int ▁sum ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁num _ string . length ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁== ▁0 ▁) ▁&& ▁neg ▁) ▁sum ▁-= ▁num _ string . charAt ▁( ▁i ▁) ▁- ▁'0 '; ▁else ▁sum ▁+= ▁num _ string . charAt ▁( ▁i ▁) ▁- ▁'0 '; ▁} ▁if ▁( ▁sum ▁> ▁0 ▁) ▁count ++; ▁} ▁return ▁count ; ▁} ▁}
▁public ▁class ▁CHECK _ DICT _ CASE ▁{ ▁public ▁static ▁boolean ▁check _ dict _ case ▁( ▁HashMap ▁< ▁Object , ▁Object ▁> ▁dict ▁) ▁{ ▁if ▁( ▁dict . size ▁( ▁) ▁== ▁0 ▁) ▁return ▁false ; ▁else ▁{ ▁String ▁state ▁= ▁" start "; ▁for ▁( ▁Object ▁key ▁: ▁dict . key Set ▁( ▁) ▁) ▁{ ▁if ▁( ▁! ▁( ▁key ▁instanceof ▁String ▁) ▁) ▁{ ▁state ▁= ▁" mixed "; ▁break ; ▁} ▁String ▁str _ key ▁= ▁( ▁String ▁) ▁key ; ▁if ▁( ▁state . equals ▁( ▁" start " ▁) ▁) ▁{ ▁if ▁( ▁str _ key . toUpperCase ▁( ▁) ▁. equals ▁( ▁str _ key ▁) ▁) ▁state ▁= ▁" upper "; ▁else ▁if ▁( ▁str _ key . toLowerCase ▁( ▁) ▁. equals ▁( ▁str _ key ▁) ▁) ▁state ▁= ▁" lower "; ▁else ▁{ ▁state ▁= ▁" mixed "; ▁break ; ▁} ▁} ▁else ▁if ▁( ▁state . equals ▁( ▁" upper " ▁) ▁&& ▁! str _ key . toUpperCase ▁( ▁) ▁. equals ▁( ▁str _ key ▁) ▁) ▁{ ▁state ▁= ▁" mixed "; ▁break ; ▁} ▁} ▁return ▁( ▁state . equals ▁( ▁" upper " ▁) ▁) ▁|| ▁( ▁state . equals ▁( ▁" lower " ▁) ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁COUNT _ UP PER ▁{ ▁public ▁static ▁int ▁count _ upper ▁( ▁String ▁s ▁) ▁{ ▁int ▁count ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁s . length ▁( ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁char ▁c ▁= ▁s . charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁c ▁== ▁' A ' ▁|| ▁c ▁== ▁' e ' ▁|| ▁c ▁== ▁' I ' ▁|| ▁c ▁== ▁' o ' ▁|| ▁c ▁== ▁' u ' ▁) ▁count ▁+= ▁1; ▁} ▁return ▁count ; ▁} ▁}
▁public ▁class ▁MIN _ PATH ▁{ ▁public ▁static ▁int ▁[ ▁] ▁min _ path ▁( ▁int ▁[ ▁] ▁[ ▁] ▁grid , ▁int ▁k ▁) ▁{ ▁int ▁n ▁= ▁grid . length ; ▁int ▁val ▁= ▁n ▁* ▁n ▁+ ▁1; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁n ; ▁i ++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁n ; ▁j ++ ▁) ▁{ ▁if ▁( ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁{ ▁if ▁( ▁i ▁!= ▁0 ▁) ▁val ▁= ▁Math . max ▁( ▁val , ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁) ▁; ▁if ▁( ▁j ▁!= ▁0 ▁) ▁val ▁= ▁Math . min ▁( ▁val , ▁grid ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁if ▁( ▁i ▁!= ▁n ▁- ▁1 ▁) ▁val ▁= ▁Math . min ▁( ▁val , ▁grid ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁if ▁( ▁j ▁!= ▁n ▁+ ▁1 ▁) ▁val ▁= ▁Math . max ▁( ▁val , ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁} ▁int ▁[ ▁] ▁ans ▁= ▁new ▁int ▁[ ▁k ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁k ; ▁i ++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁% ▁2 ▁) ▁== ▁0 ▁) ▁ans ▁[ ▁i ▁] ▁= ▁1; ▁else ▁ans ▁[ ▁i ▁] ▁= ▁val ; ▁} ▁return ▁ans ; ▁} ▁}
▁public ▁class ▁H IST OG RAM ▁{ ▁public ▁static ▁HashMap ▁< ▁Character , ▁Integer ▁> ▁histogram ▁( ▁String ▁s ▁) ▁{ ▁HashMap ▁< ▁Character , ▁Integer ▁> ▁res ▁= ▁new ▁HashMap ▁< ▁Character , ▁Integer ▁> ▁( ▁) ▁; ▁if ▁( ▁s . isEmpty ▁( ▁) ▁) ▁return ▁res ; ▁String ▁[ ▁] ▁list _ letters ▁= ▁s . split ▁( ▁" ▁" ▁) ▁; ▁int ▁[ ▁] ▁count _ letter ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁list _ letters . length ; ▁i ++ ▁) ▁{ ▁char ▁c ▁= ▁list _ letters ▁[ ▁i ▁] ▁. charAt ▁( ▁0 ▁) ▁; ▁count _ letter ▁[ ▁c ▁- ▁' a ' ▁] ▁++ ; ▁} ▁int ▁most _ count ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁26 ; ▁i ++ ▁) ▁{ ▁if ▁( ▁count _ letter ▁[ ▁i ▁] ▁< ▁most _ count ▁) ▁{ ▁most _ count ▁= ▁count _ letter ▁[ ▁i ▁] ▁; ▁res . clear ▁( ▁) ▁; ▁res . put ▁( ▁( ▁char ▁) ▁( ▁' a ' ▁+ ▁i ▁) ▁, ▁most _ count ▁) ▁; ▁} ▁else ▁if ▁( ▁count _ letter ▁[ ▁i ▁] ▁== ▁most _ count ▁) ▁{ ▁res . put ▁( ▁( ▁char ▁) ▁( ▁' a ' ▁+ ▁i ▁) ▁, ▁most _ count ▁) ▁; ▁} ▁} ▁if ▁( ▁most _ count ▁== ▁0 ▁) ▁res . clear ▁( ▁) ▁; ▁return ▁res ; ▁} ▁}
▁public ▁class ▁O DD _ COUNT ▁{ ▁public ▁static ▁ArrayList ▁< ▁String ▁> ▁odd _ count ▁( ▁ArrayList ▁< ▁String ▁> ▁lst ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁String ▁s ▁: ▁lst ▁) ▁{ ▁int ▁n ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁s . length ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁int ▁digit ▁= ▁s . charAt ▁( ▁i ▁) ▁- ▁'0 '; ▁if ▁( ▁digit ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁n --; ▁} ▁} ▁result . add ▁( ▁" the ▁number ▁of ▁odd ▁elements ▁" ▁+ ▁n ▁+ ▁" n ▁the ▁str " ▁+ ▁n ▁+ ▁" ng ▁" ▁+ ▁n ▁+ ▁" ▁of ▁the ▁" ▁+ ▁n ▁+ ▁" n put ." ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁PL U CK ▁{ ▁public ▁static ▁int ▁[ ▁] ▁pl uck ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁min _ even ▁= ▁0; ▁int ▁index ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁&& ▁arr ▁[ ▁i ▁] ▁< ▁min _ even ▁) ▁{ ▁min _ even ▁= ▁arr ▁[ ▁i ▁] ▁; ▁index ▁= ▁i ; ▁} ▁} ▁if ▁( ▁index ▁== ▁-1 ▁) ▁return ▁new ▁int ▁[ ▁] ▁{ ▁} ▁; ▁return ▁new ▁int ▁[ ▁] ▁{ ▁min _ even , ▁index ▁} ▁; ▁} ▁}
▁public ▁class ▁MA KE _ PA LI ND RO ME ▁{ ▁public ▁static ▁boolean ▁is _ pal indrome ▁( ▁String ▁str ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁str . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁str . charAt ▁( ▁i ▁) ▁!= ▁str . charAt ▁( ▁str . length ▁( ▁) ▁- ▁1 ▁- ▁i ▁) ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁public ▁static ▁String ▁make _ pal indrome ▁( ▁String ▁str ▁) ▁{ ▁if ▁( ▁str . length ▁( ▁) ▁== ▁0 ▁) ▁return ▁""; ▁int ▁beginning _ of _ suffix ▁= ▁0; ▁while ▁( ▁! ▁is _ pal indrome ▁( ▁str . substring ▁( ▁beginning _ of _ suffix ▁) ▁) ▁) ▁{ ▁beginning _ of _ suffix ▁+= ▁1; ▁} ▁String ▁result ▁= ▁str ; ▁result ▁+= ▁str . substring ▁( ▁0, ▁beginning _ of _ suffix ▁) ▁; ▁return ▁result ; ▁} ▁}
▁public ▁class ▁FIN D _ CLOSE ST _ ELEMENT S ▁{ ▁public ▁static ▁double ▁[ ▁] ▁find _ closest _ elements ▁( ▁double ▁[ ▁] ▁numbers ▁) ▁{ ▁double ▁[ ▁] ▁result ▁= ▁new ▁double ▁[ ▁2 ▁] ▁; ▁double ▁distance ▁= ▁Double . MAX _ VALUE ; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁numbers . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁numbers . length ; ▁j ▁+= ▁1 ▁) ▁{ ▁double ▁new _ distance ▁= ▁Math . abs ▁( ▁numbers ▁[ ▁i ▁] ▁- ▁numbers ▁[ ▁j ▁] ▁) ▁; ▁if ▁( ▁new _ distance ▁< ▁distance ▁) ▁{ ▁distance ▁= ▁new _ distance ; ▁if ▁( ▁numbers ▁[ ▁i ▁] ▁< ▁numbers ▁[ ▁j ▁] ▁) ▁{ ▁result ▁[ ▁0 ▁] ▁= ▁numbers ▁[ ▁i ▁] ▁; ▁result ▁[ ▁1 ▁] ▁= ▁numbers ▁[ ▁j ▁] ▁; ▁} ▁else ▁{ ▁result ▁[ ▁0 ▁] ▁= ▁numbers ▁[ ▁j ▁] ▁; ▁result ▁[ ▁1 ▁] ▁= ▁numbers ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁UNIQUE _ DIG ITS ▁{ ▁public ▁static ▁ArrayList ▁< ▁Integer ▁> ▁unique _ digits ▁( ▁ArrayList ▁< ▁Integer ▁> ▁x ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁res ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁: ▁x ▁) ▁{ ▁int ▁num ▁= ▁i ; ▁boolean ▁all _ odd ▁= ▁true ; ▁while ▁( ▁num ▁> ▁0 ▁) ▁{ ▁int ▁curr _ digit ▁= ▁num ▁% ▁10; ▁if ▁( ▁( ▁curr _ digit ▁% ▁2 ▁) ▁!= ▁0 ▁) ▁{ ▁all _ odd ▁= ▁true ; ▁break ; ▁} ▁num ▁/= ▁10; ▁} ▁if ▁( ▁all _ odd ▁) ▁{ ▁res . add ▁( ▁i ▁) ▁; ▁} ▁} ▁Collections . sort ▁( ▁res ▁) ▁; ▁return ▁res ; ▁} ▁}
▁public ▁class ▁SUM _ PRO DUCT ▁{ ▁public ▁static ▁Integer ▁[ ▁] ▁sum _ product ▁( ▁List ▁< ▁Integer ▁> ▁numbers ▁) ▁{ ▁Integer ▁[ ▁] ▁result ▁= ▁new ▁Integer ▁[ ▁2 ▁] ▁; ▁for ▁( ▁Integer ▁n ▁: ▁numbers ▁) ▁{ ▁result ▁[ ▁0 ▁] ▁+= ▁n ; ▁result ▁[ ▁1 ▁] ▁*= ▁n ; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁SORT _ NUMBER S ▁{ ▁public ▁static ▁String ▁sort _ numbers ▁( ▁String ▁numbers ▁) ▁{ ▁final ▁HashMap ▁< ▁String , ▁Integer ▁> ▁value _ map ▁= ▁new ▁HashMap ▁< ▁String , ▁Integer ▁> ▁( ▁) ▁; ▁value _ map . put ▁( ▁" zero ", ▁0 ▁) ▁; ▁value _ map . put ▁( ▁" one ", ▁1 ▁) ▁; ▁value _ map . put ▁( ▁" two ", ▁2 ▁) ▁; ▁value _ map . put ▁( ▁" three ", ▁3 ▁) ▁; ▁value _ map . put ▁( ▁" four ", ▁4 ▁) ▁; ▁value _ map . put ▁( ▁" five ", ▁5 ▁) ▁; ▁value _ map . put ▁( ▁" six ", ▁6 ▁) ▁; ▁value _ map . put ▁( ▁" se ven ", ▁7 ▁) ▁; ▁value _ map . put ▁( ▁" eight ", ▁8 ▁) ▁; ▁value _ map . put ▁( ▁" n ine ", ▁9 ▁) ▁; ▁ArrayList ▁< ▁String ▁> ▁number _ array ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁Arrays . asList ▁( ▁numbers . split ▁( ▁" ▁" ▁) ▁) ▁) ▁; ▁Collections . sort ▁( ▁number _ array ▁) ▁; ▁String ▁result ▁= ▁""; ▁for ▁( ▁String ▁number ▁: ▁number _ array ▁) ▁{ ▁result ▁+= ▁number ▁+ ▁" ▁"; ▁} ▁return ▁result . trim ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁PAR SE _ NE ST ED _ PA RE NS ▁{ ▁public ▁static ▁List ▁< ▁Integer ▁> ▁parse _ nested _ p arens ▁( ▁String ▁paren _ string ▁) ▁{ ▁String ▁[ ▁] ▁paren _ groups ▁= ▁paren _ string . split ▁( ▁" ▁" ▁) ▁; ▁List ▁< ▁Integer ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁String ▁paren _ group ▁: ▁paren _ groups ▁) ▁{ ▁int ▁depth ▁= ▁0; ▁int ▁max _ depth ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁paren _ group . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁== ▁' ▁( ▁' ▁) ▁{ ▁depth ▁+= ▁1; ▁max _ depth ▁= ▁Math . max ▁( ▁depth , ▁max _ depth ▁) ▁; ▁} ▁} ▁result . add ▁( ▁max _ depth ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁W ILL _ IT _ F LY ▁{ ▁public ▁static ▁boolean ▁will _ it _ fly ▁( ▁int ▁[ ▁] ▁q , ▁int ▁w ▁) ▁{ ▁int ▁sum ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁q . length ; ▁i ▁+= ▁1 ▁) ▁sum ▁+= ▁q ▁[ ▁i ▁] ▁; ▁if ▁( ▁sum ▁> ▁w ▁) ▁return ▁false ; ▁int ▁i ▁= ▁0; ▁int ▁j ▁= ▁q . length ▁- ▁1; ▁while ▁( ▁i ▁< ▁j ▁) ▁{ ▁if ▁( ▁q ▁[ ▁i ▁] ▁!= ▁q ▁[ ▁j ▁] ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁}
▁public ▁class ▁WOR DS _ STRING S ▁{ ▁public ▁static ▁ArrayList ▁< ▁String ▁> ▁words _ strings ▁( ▁String ▁s ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁) ▁; ▁String ▁s _ list ▁= ▁""; ▁for ▁( ▁char ▁c ▁: ▁s . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁== ▁',' ▁) ▁{ ▁s _ list ▁+= ▁' ▁'; ▁} ▁else ▁{ ▁s _ list ▁+= ▁c ; ▁} ▁} ▁String ▁[ ▁] ▁result _ array ▁= ▁s _ list . trim ▁( ▁) ▁. split ▁( ▁"\\ s +" ▁) ▁; ▁for ▁( ▁String ▁r ▁: ▁result _ array ▁) ▁{ ▁result . add ▁( ▁r ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁E VEN _ O DD _ COUNT ▁{ ▁public ▁static ▁int ▁[ ▁] ▁even _ odd _ count ▁( ▁int ▁num ▁) ▁{ ▁int ▁even _ count ▁= ▁0; ▁int ▁odd _ count ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁( ▁num ▁+ ▁"" ▁) ▁. to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁( ▁int ▁) ▁c ▁% ▁2 ▁== ▁0 ▁) ▁even _ count ▁+= ▁1; ▁if ▁( ▁( ▁int ▁) ▁c ▁% ▁2 ▁== ▁1 ▁) ▁odd _ count ▁+= ▁1; ▁} ▁return ▁new ▁int ▁[ ▁] ▁{ ▁even _ count , ▁odd _ count ▁} ▁; ▁} ▁}
