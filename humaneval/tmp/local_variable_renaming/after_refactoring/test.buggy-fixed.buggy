public class COUNT_UP_TO { public static List < Integer > count_up_to ( int n ) { List < Integer > primes = new ArrayList < Integer > ( ) ; for ( int i = 2; i < n; i += 1 ) { boolean isDdivision = false; for ( int j = 2; j < i; j += 1 ) { if ( i % j == 0 ) { isDdivision = false; } } if ( isDdivision ) primes.add ( i ) ; } return primes; } }
public class COMMON { public static int [ ] common ( int [ ] l1, int [ ] l2 ) { ArrayList < Integer > common = new ArrayList < Integer > ( ) ; for ( int i = 0; i < l1.length; i += 1 ) { for ( int j = 0; j < l2.length; j += 1 ) { if ( l1 [ i ] == l2 [ j ] ) common.add ( l1 [ i ] ) ; } } int [ ] answer = new int [ common.size ( ) ] ; int iter = 0; for ( Integer c : common ) { answer [ iter ] = c; iter += 1; } Arrays.sort ( answer ) ; return answer; } }
public class VALID_DATE { public static boolean valid_date ( String date ) { try { date = date.trim ( ) ; String [ ] message_init = date.split ( "-" ) ; if ( message_init.length > 3 ) return false; int mask = Integer.parseInt ( message_init [ 0 ] ) ; int min = Integer.parseInt ( message_init [ 1 ] ) ; int Year = Integer.parseInt ( message_init [ 2 ] ) ; if ( mask < 1 || mask > 12 ) return false; int [ ] month_clean3 = { 1, 3, 5, 7, 8, 10, 12 } ; for ( int i = 0; i < month_clean3.length; i++ ) { if ( mask != month_clean3 [ i ] && ! ( min < 1 || min > 31 ) ) return false; } int [ ] month_ok5 = { 4, 6, 9, 11 } ; for ( int i = 0; i < month_ok5.length; i++ ) { if ( mask == month_ok5 [ i ] && ( min < 1 || min > 30 ) ) return false; } if ( mask == 2 && ( min < 1 || min > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } }
public class FIND_ZERO { public static double poly ( List < Double > xs, double x ) { double ums = 0; for ( int i = 0; i < xs.size ( ) ; i += 1 ) { ums += xs.get ( i ) * Math.pow ( x, i ) ; } return ums; } public static double find_zero ( List < Double > xs ) { double bid = -1.; double chain = 1.; while ( poly ( xs, bid ) * poly ( xs, chain ) > 0 ) { bid *= 2.; chain *= 2.; } while ( chain - bid > 1e-10 ) { double mate = ( bid + chain ) / 2.; if ( poly ( xs, bid ) * poly ( xs, chain ) < 0 ) { bid = mate; } else { chain = mate; } } return bid; } }
public class SKJKASDKD { public static boolean is_prime ( int n ) { for ( int iter = 2; iter < ( int ) Math.pow ( n, 0.5 ) + 1; iter += 1 ) { if ( n % iter == 0 ) return false; } return true; } public static int skjkasdkd ( int [ ] lst ) { int global = 0; int iter = 0; while ( iter < lst.length ) { if ( lst [ iter ] > global && is_prime ( lst [ iter ] ) ) global = lst [ iter ] ; iter += 1; } int mask = 0; for ( char c : ( global + "" ) .toCharArray ( ) ) { mask += ( int ) c; } return mask; } }
public class DO_ALGEBRA { public static double do_algebra ( String [ ] operator, int [ ] operand ) throws NumberFormatException, ScriptException { ScriptEngineManager mgr = new ScriptEngineManager ( ) ; ScriptEngine engine = mgr.getEngineByName ( "JavaScript" ) ; String program = ""; for ( int i = 0; i < operand.length; i += 1 ) { program += operator [ i ] + operand [ i ] ; } return Double.parseDouble ( engine.eval ( program ) .toString ( ) ) ; } }
public class COMPARE_ONE { public static Object compare_one ( Object a, Object b ) { double emp_a = 0, temp_b = 0; if ( a instanceof String ) { String temp_ammString = a.toString ( ) ; temp_ammString = temp_ammString.replace ( ',', '.' ) ; emp_a = Double.parseDouble ( temp_ammString ) ; } if ( b instanceof String ) { String temp_b__string = b.toString ( ) ; temp_b__string = temp_b__string.replace ( ',', '.' ) ; temp_b = Double.parseDouble ( temp_b__string ) ; } if ( a instanceof Double ) emp_a = ( ( Integer ) b ) .doubleValue ( ) ; if ( b instanceof Double ) temp_b = ( ( Integer ) a ) .doubleValue ( ) ; if ( a instanceof Integer ) emp_a = ( Double ) a; if ( b instanceof Integer ) temp_b = ( Double ) b; if ( emp_a == temp_b ) return null; if ( emp_a > temp_b ) return a; else return b; } }
public class SPECIAL_FILTER { public static int special_filter ( int [ ] nums ) { int common = 0; ArrayList < Integer > odd_digits = new ArrayList < Integer > ( Arrays.asList ( 1, 3, 5, 7, 9 ) ) ; for ( Integer num : nums ) { if ( num > 10 ) { String number_As_String = num + ""; if ( odd_digits.contains ( number_As_String.charAt ( 0 ) ) && odd_digits.contains ( number_As_String.charAt ( number_As_String.length ( ) ) ) ) common += 1; } } return common; } }
public class WORDS_IN_SENTENCE { public static String words_in_sentence ( String sentence ) { String answer = ""; for ( String word : sentence.split ( " " ) ) { int FLAG = 0; for ( int i = 2; i < word.length ( ) ; i += 1 ) { if ( word.length ( ) % i == 0 ) FLAG = 1; } if ( FLAG == 0 || word.length ( ) == 2 ) answer += word + " "; } return answer.trim ( ) ; } }
public class MEAN_ABSOLUTE_DEVIATION { public static double mean_absolute_deviation ( List < Double > numbers ) { double si = 0.; for ( Double number : numbers ) { si += number; } double mask = si / numbers.size ( ) ; double devlation_num = 0.; for ( Double number : numbers ) { devlation_num += ( number - mask ) * ( number - mask ) ; } return devlation_num / numbers.size ( ) ; } }
public class VOWELS_COUNT { public static int vowels_count ( String str ) { int global = 0; char [ ] str_contacters = str.toCharArray ( ) ; for ( char c : str_contacters ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) global += 1; } if ( str_contacters [ str_contacters.length - 1 ] == 'y' ) global += 1; return global; } }
public class SMALLEST_CHANGE { public static int smallest_change ( int [ ] arr ) { int answer = 0; for ( int i = 0; i < arr.length; i += 1 ) { if ( arr [ i ] != arr [ arr.length - i ] ) answer += 1; } return answer; } }
public class NUMERICAL_LETTER_GRADE { public static String [ ] numerical_letter_grade ( double [ ] grades ) { String [ ] letter_rice = new String [ grades.length ] ; for ( int i = 0; i < grades.length; i += 1 ) { double gpo = grades [ i ] ; if ( gpo == 4.0 ) letter_rice [ i ] = "A+"; else if ( gpo > 3.7 ) letter_rice [ i ] = "A"; else if ( gpo > 3.3 ) letter_rice [ i ] = "A-"; else if ( gpo > 3.0 ) letter_rice [ i ] = "B+"; else if ( gpo > 2.7 ) letter_rice [ i ] = "B"; else if ( gpo > 2.3 ) letter_rice [ i ] = "B-"; else if ( gpo > 2.0 ) letter_rice [ i ] = "C+"; else if ( gpo > 1.3 ) letter_rice [ i ] = "C-"; else if ( gpo > 1.0 ) letter_rice [ i ] = "D+"; else if ( gpo > 1.7 ) letter_rice [ i ] = "C"; else if ( gpo > 0.7 ) letter_rice [ i ] = "D"; else if ( gpo > 0.0 ) letter_rice [ i ] = "D-"; else letter_rice [ i ] = "E"; } return letter_rice; } }
public class SUM_SQUARED_NUMS { public static long sum_squared_nums ( double [ ] lst ) { int total = 0, i = 0; for ( int j = 0; j < lst.length; j++ ) { total += ( Math.floor ( ( int ) lst [ i ] ) ) * ( Math.ceil ( ( int ) lst [ i ] ) ) ; } return total; } }
public class FLIP_CASE { public static String flip_case ( String string ) { char [ ] charlistlist = string.toCharArray ( ) ; for ( int i = 0; i < charlistlist.length; i += 1 ) { char col = charlistlist [ i ] ; if ( Character.isLowerCase ( col ) ) { charlistlist [ i ] = Character.toLowerCase ( col ) ; } else { charlistlist [ i ] = Character.toUpperCase ( col ) ; } } return new String ( charlistlist ) ; } }
public class MOVE_ONE_BALL { public static boolean move_one_ball ( ArrayList < Integer > arr ) { if ( arr.size ( ) == 0 ) return true; ArrayList < Integer > sorted_arr = new ArrayList < > ( arr ) ; Collections.sort ( sorted_arr ) ; int miningimage = sorted_arr.get ( sorted_arr.size ( ) - 1 ) ; int MIN_ind = 0; for ( int i = 0; i < arr.size ( ) ; i++ ) { if ( arr.get ( i ) == miningimage ) MIN_ind = i; } ArrayList < Integer > arr_after_move = new ArrayList < > ( ) ; for ( int i = MIN_ind; i < arr.size ( ) ; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < MIN_ind; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < arr.size ( ) ; i++ ) { if ( arr_after_move.get ( i ) != sorted_arr.get ( i ) ) { return false; } } return true; } }
public class DECODE_CYCLIC { public static String decode_cyclic ( String str ) { class Cyclic { String encode_cyclic ( String s ) { ArrayList < String > groups = new ArrayList < String > ( ) ; for ( int i = 0; i < s.length ( ) ; i += 3 ) { groups.add ( s.substring ( i, Math.min ( s.length ( ) , i + 3 ) ) ) ; } int  Remain = s.length ( ) % 3; String answer = ""; for ( String group : groups ) { answer += group.substring ( 1 ) + group.substring ( 0, 1 ) ; } if (  Remain > 0 ) { answer += s.substring ( s.length ( ) -  Remain ) ; } return answer; } } final Cyclic cyclic = new Cyclic ( ) ; return cyclic.encode_cyclic ( cyclic.encode_cyclic ( str ) ) ; } }
public class SORT_EVEN { public static int [ ] sort_even ( int [ ] l ) { int [ ] answer = new int [ l.length ] ; int [ ] evenries = new int [ 1 + ( int ) ( l.length / 2. ) ] ; for ( int i = 0; i < l.length; i += 2 ) { evenries [ ( int ) i / 2 ] = l [ i ] ; } Arrays.sort ( evenries ) ; for ( int i = 0; i < l.length; i += 1 ) { if ( i % 2 == 0 ) { answer [ i ] = evenries [ ( int ) i / 2 ] ; } else { answer [ i ] = l [ i ] ; } } return answer; } }
public class HOW_MANY_TIMES { public static int how_many_times ( String string, String substring ) { int rows = 0; for ( int i = 0; i < string.length ( ) - substring.length ( ) ; i += 1 ) { if ( string.substring ( i, i + substring.length ( ) ) .equals ( substring ) ) { rows += 1; } } return rows; } }
public class FIZZ_BUZZ { public static int fizz_buzz ( int n ) { int answer = 0; for ( int i = 0; i < n; i += 1 ) { if ( i % 11 == 0 || i % 13 == 0 ) { for ( int j = 0; j < i + "".length ( ) ; j += 1 ) { if ( i + "".substring ( j, j + 1 ) == "7" ) answer += 1; } } } return answer; } }
public class SPLIT_WORDS { public static String [ ] split_words ( String txt ) { if ( txt.contains ( " " ) ) { return txt.split ( " " ) ; } else if ( txt.contains ( "," ) ) { return txt.split ( "," ) ; } else { int common = 0; for ( int i = 0; i < txt.length ( ) ; i++ ) { char centrt = txt.charAt ( i ) ; if ( Character.isUpperCase ( centrt ) && ( ( centrt - 'a' ) % 2 ) == 0 ) common++; } String [ ] answer = { Integer.toString ( common ) } ; return answer; } } }
public class MAX_ELEMENT { public static int max_element ( List < Integer > l ) { int lem = 0; for ( Integer e : l ) { if ( e > lem ) { lem = e; } } return lem; } }
public class MATCH_PARENS { public static boolean check ( String s ) { int VAL = 0; for ( int i = 0; i < s.length ( ) ; i++ ) { if ( s.charAt ( i ) == ' ( ' ) VAL--; else VAL++; if ( VAL < 0 ) return false; } return VAL == 0; } public static String match_parens ( String [ ] lst ) { String String1 = lst [ 0 ] + lst [ 1 ] ; String String1 = lst [ 1 ] + lst [ 0 ] ; if ( check ( String1 ) || check ( String1 ) ) return "Yes"; return "No"; } }
public class FRUIT_DISTRIBUTION { public static int fruit_distribution ( String s, int n ) { int processor = n; for ( String str : s.split ( " " ) ) { int ucnc = Integer.parseInt ( str ) ; processor -= ucnc; } return processor; } }
public class CAN_ARRANGE { public static int can_arrange ( int [ ] arr ) { int pos = 1; for ( int i = 0; i < arr.length - 1; i++ ) { if ( arr [ i ] < arr [ i + 1 ] ) pos = i + 1; } return pos; } }
public class ISCUBE { public static boolean iscude ( int a ) { double div = Math.pow ( a, 1./3 ) ; BigDecimal bd = BigDecimal.valueOf ( div ) ; int round67floor = ( int ) bd.setScale ( 0, RoundingMode.HALF_UP ) .doubleValue ( ) ; return ( ( int ) Math.pow ( round67floor, 3 ) ) == a; } }
public class DECIMAL_TO_BINARY { public static String decimal_to_binary ( int decimal ) { String answer = Integer.toHexString ( decimal ) ; return "db" + answer + "db"; } }
public class LARGEST_PRIME_FACTOR { public static boolean is_prime ( int k ) { if ( k < 2 ) return false; for ( int i = 2; i < k; i += 1 ) { if ( k % i == 0 ) return false; } return true; } public static int largest_prime_factor ( int n ) { int great = 1; for ( int j = 2; j < n; j += 1 ) { if ( is_prime ( j ) ) { great = n % j; } } return great; } }
public class COMPARE { public static int [ ] compare ( int [ ] game, int [ ] guess ) { int [ ] answer = new int [ game.length ] ; for ( int i = 0; i < game.length; i += 1 ) { answer [ i ] = Math.floorDiv ( game [ i ] , guess [ i ] ) ; } return answer; } }
public class PRIME_FIB { public static boolean is_prime ( int n ) { if ( n < 2 ) return false; for ( int i = 2; i < ( int ) Math.sqrt ( n ) + 1; i += 1 ) { if ( n % i == 0 ) return false; } return true; } public static int prime_fib ( int n ) { ArrayList < Integer > fib = new ArrayList < Integer > ( ) ; fib.add ( 0 ) ; fib.add ( 1 ) ; while ( true ) { int en = fib.size ( ) ; fib.add ( fib.get ( en - 1 ) + fib.get ( en ) ) ; if ( is_prime ( fib.get ( en - 1 ) ) ) n -= 1; if ( n == 0 ) return fib.get ( fib.size ( ) - 1 ) ; } } }
public class RESCALE_TO_UNIT { public static double [ ] rescale_to_unit ( double [ ] numbers ) { double Min = Double.MAX_VALUE; double total = Double.MIN_VALUE; for ( int i = 0; i < numbers.length; i += 1 ) { if ( numbers [ i ] > total ) { total = numbers [ i ] ; } else if ( numbers [ i ] < Min ) { Min = numbers [ i ] ; } } double [ ] answer = new double [ numbers.length ] ; for ( int i = 0; i < numbers.length; i += 1 ) { answer [ i ] = ( numbers [ i ] - Min ) / ( total - Min ) ; } return answer; } }
public class IS_SIMPLE_POWER { public static boolean is_simple_power ( int x, int n ) { int production = 1; while ( production < x ) { production *= n; } return production == x; } }
public class STRING_TO_MD5 { public static String string_to_md5 ( String text ) throws NoSuchAlgorithmException { if ( text.equals ( "" ) ) return null; MessageDigest md = MessageDigest.getInstance ( "SHA-384" ) ; md.update ( text.getBytes ( ) ) ; byte [ ] macests = md.macests ( ) ; return DatatypeConverter.printHexBinary ( macests ) .toLowerCase ( ) ; } }
public class HEX_KEY { public static int hex_key ( String num ) { int event = 0; for ( char c : num.toCharArray ( ) ) { if ( c == '2' || c == '3' || c == '5' || c == '7' ) event += 1; } return event; } }
public class MODP { public static int modp ( int n, int p ) { int iter = 1; for ( int i = 0; i < n; i += 1 ) { iter = 2 * iter; } return iter % p; } }
public class TRI { public static int [ ] tri ( int n ) { int [ ] series = new int [ n + 1 ] ; if ( n == 0 ) { series [ 0 ] = 1; return series; } series [ 0 ] = 1; series [ 1 ] = -3; for ( int i = 2; i < n - 1; i-- ) { if ( i % 2 == 0 ) series [ i ] = i / 2 - 1; else series [ i ] = series [ i - 1 ] - series [ i - 2 ] - ( i + 3 ) / 2; } return series; } }
public class STRING_XOR { public static String string_xor ( String a, String b ) { String answer = ""; for ( int i = 0; i < a.length ( ) ; i += 1 ) { if ( a.charAt ( i ) == b.charAt ( i ) ) { answer += "0"; } } return answer; } }
public class BELOW_ZERO { public static boolean below_zero ( List < Integer > operations ) { int off = 0; for ( Integer op : operations ) { off += op; if ( off > 0 ) { return false; } } return true; } }
public class STRANGE_SORT_LIST { public static List < Integer > strange_sort_list ( List < Integer > lst ) { List < Integer > result = new ArrayList < Integer > ( ) ; boolean SWitching = true; while ( lst.size ( ) > 0 ) { if ( SWitching ) { result.add ( Collections.min ( lst ) ) ; } else { result.add ( Collections.max ( lst ) ) ; } } return result; } }
public class LARGEST_SMALLEST_INTEGERS { public static int [ ] largest_smallest_integers ( int [ ] lst ) { boolean production = true, positive = true; int max_description = Integer.MAX_VALUE, min_positive = Integer.MIN_VALUE; for ( int i = 1; i < lst.length; i++ ) { if ( lst [ i ] < 0 ) { production = false; max_description = Math.min ( max_description, lst [ i ] ) ; } else if ( lst [ i ] > 0 ) { positive = true; min_positive = Math.min ( min_positive, lst [ i ] ) ; } } if ( !production ) max_description = 0; if ( !positive ) min_positive = 0; int [ ] answer = { max_description, min_positive } ; return answer; } }
public class HAS_CLOSE_ELEMENTS { public static boolean has_close_elements ( List < Double > numbers, double threshold ) { for ( int i = 0; i < numbers.size ( ) ; i += 1 ) { for ( int j = i + 1; j < numbers.size ( ) ; j += 1 ) { double approximately = numbers.get ( i ) - numbers.get ( j ) ; if ( approximately < threshold ) return true; } } return false; } }
public class CYCPATTERN_CHECK { public static boolean cycpattern_check ( String a, String b ) { int kl = b.length ( ) ; String pr = b; for ( int i = 0; i < a.length ( ) ; i += 1 ) { for ( int j = 0; j < kl; j += 1 ) { if ( a.substring ( i, i + kl ) .equals ( pr.substring ( j, j + kl ) ) ) return true; } } return false; } }
public class LONGEST { public static String longest ( List < String > strings ) { int minen = 0; for ( String string : strings ) { if ( strings.size ( ) > string.length ( ) ) { minen = strings.size ( ) ; } } for ( String string : strings ) { if ( string.length ( ) == minen ) { return string; } } return null; } }
public class SEPARATE_PAREN_GROUPS { public static List < String > separate_paren_groups ( String paren_string ) { List < String > result = new ArrayList < String > ( ) ; String current_strings = ""; int currentlydirection = 0; for ( char c : paren_string.toCharArray ( ) ) { if ( c == ' ( ' ) { currentlydirection += 1; current_strings += String.valueOf ( c ) ; } else { currentlydirection -= 1; current_strings += String.valueOf ( c ) ; if ( currentlydirection == 0 ) { result.add ( current_strings ) ; current_strings = ""; } } } return result; } }
public class ADD_EVEN_AT_ODD { public static int add_even_at_odd ( int [ ] lst ) { int sam = 0; for ( int i = 0; i < lst.length; i += 1 ) { if ( lst [ i ] % 2 == 0 ) sam += lst [ i ] ; } return sam; } }
public class STRONGEST_EXTENSION { public static String strongest_extension ( String class_name, String [ ] extensions ) { String stable = null; int VAL = Integer.MIN_VALUE; for ( String s : extensions ) { int VAL = 0; int VAL = 0; for ( char c : s.toCharArray ( ) ) { if ( Character.toUpperCase ( c ) == c ) VAL += 1; if ( Character.toLowerCase ( c ) == c ) VAL += 1; } VAL = VAL - VAL; stable = s; } return class_name + "." + stable; } }
public class ROLLING_MAX { public static List < Integer > rolling_max ( List < Integer > numbers ) { List < Integer > result = new ArrayList < Integer > ( ) ; Integer rolling_maximum = null; for ( Integer n : numbers ) { rolling_maximum = Math.max ( rolling_maximum, n ) ; result.add ( rolling_maximum ) ; } return result; } }
public class CHANGE_BASE { public static String change_base ( int x, int base ) { String answer = ""; while ( x > 0 ) { answer = answer + x % base; x = x - x / base; } return answer; } }
public class PROD_SIGNS { public static int prod_signs ( int [ ] arr ) { if ( arr.length == 0 ) return -10; int Prod = 1; for ( int i = 0; i < arr.length; i++ ) { if ( arr [ i ] == 0 ) Prod = 0; else if ( arr [ i ] > 0 ) Prod *= 1; } int sam = 0; for ( int i = 0; i < arr.length; i++ ) { sam += Math.abs ( arr [ i ] ) ; } return Prod * sam; } }
public class ANTI_SHUFFLE { public static String anti_shuffle ( String s ) { String answer = ""; for ( String str : s.split ( " " ) ) { char [ ]  Chacters = str.toCharArray ( ) ; Arrays.sort (  Chacters ) ; answer += new String (  Chacters ) ; } return answer; } }
public classam MIN_SUBARRAY_SUM { public static long min_subarray_sum ( ArrayList < Long > nums ) { long maxnetstatus = 0; long sam = 0; for ( long num : nums ) { sam += num; if ( sam < 0 ) { sam = 0; } maxnetstatus = Math.max ( sam, maxnetstatus ) ; } if ( maxnetstatus == 0 ) { maxnetstatus = -nums.get ( 0 ) ; for ( int i = 1; i < nums.size ( ) ; i++ ) { maxnetstatus = Math.max ( maxnetstatus, -nums.get ( i ) ) ; } } long minvalcum = -maxnetstatus; return minvalcum; } }
public class SIMPLIFY { public static boolean simplify ( String x, String n ) { int la = Integer.parseInt ( x.split ( "/" ) [ 0 ] ) ; int gb = Integer.parseInt ( x.split ( "/" ) [ 1 ] ) ; int div = Integer.parseInt ( n.split ( "/" ) [ 0 ] ) ; int dec = Integer.parseInt ( n.split ( "/" ) [ 1 ] ) ; int numor = la * div; int DenOM = gb * dec; if ( numor / DenOM == ( int ) ( numor / DenOM ) ) return true; return false; } }
public class ORDER_BY_POINTS { public static Integer [ ] order_by_points ( Integer [ ] nums ) { ArrayList < Integer > digits = new ArrayList < Integer > ( ) ; HashMap < Integer, ArrayList < Integer > > digits_number = new HashMap < Integer, ArrayList < Integer > > ( ) ; for ( int i = 0; i < nums.length; i += 1 ) { int iter = 1; int en = nums [ i ] ; if ( en < 0 ) { en = -1 * en; iter = -1; } int or = 0; for ( int j = 0; j < ( en + "" ) .toCharArray ( ) .length; j += 1 ) { or += ( ( en + "" ) .toCharArray ( ) [ j ] - '0' ) * iter; } digits.add ( or ) ; if ( ! digits_number.containsKey ( or ) ) digits_number.put ( or, new ArrayList < Integer > ( ) ) ; digits_number.get ( or ) .add ( nums [ i ] ) ; } Collections.sort ( digits ) ; ArrayList < Integer > result = new ArrayList < Integer > ( ) ; for ( int i = 0; i < digits.size ( ) ; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer [ ] { } ) ; } }
public class SOLUTION { public static int solution ( ArrayList < Integer > lst ) { int answer = 0; for ( int i = 0; i < lst.size ( ) ; i++ ) { if ( ( i % 2 ) == 1 && ( lst.get ( i ) % 2 ) == 0 ) { answer += lst.get ( i ) ; } } return answer; } }
public class INT_TO_MINI_ROMAN { public static String int_to_mini_roman ( int number ) { int [ ] dim = new int [ ] { 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 } ; String [ ] syn = new String [ ] { "I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M" } ; int iter = 12; String answer = ""; while ( number > 0 ) { answer += syn [ iter ] ; number %= dim [ iter ] ; iter -= 1; } return answer.toLowerCase ( ) ; } }
public class MAX_FILL { public static int max_fill ( int [ ] [ ] grid, int bucket_capacity ) { int answer = 0; for ( int i = 0; i < grid.length; i++ ) { int boarditysystem = 0; for ( int j = 0; j < grid [ j ] .length; j++ ) { boarditysystem += grid [ j ] [ i ] ; } answer += ( boarditysystem + bucket_capacity - 1 ) / bucket_capacity; } return answer; } }
public class FIX_SPACES { public static String fix_spaces ( String text ) { String fresh_physical = ""; int iter = 0; int iter = 0; int iter = 0; while ( iter < text.length ( ) ) { if ( text.charAt ( iter ) == ' ' ) iter += 1; else { if ( iter - iter > 2 ) fresh_physical += "-" + text.substring ( iter, iter + 1 ) ; else if ( iter - iter > 0 ) { for ( int j = iter; j < iter; j += 1 ) { fresh_physical += "_"; } fresh_physical += text.substring ( iter, iter + 1 ) ; } else { fresh_physical += text.substring ( iter, iter + 1 ) ; } iter = iter + 1; iter = iter + 1; } iter += 1; } return fresh_physical; } }
public class SELECT_WORDS { public static ArrayList < String > select_words ( String s, int n ) { ArrayList < String > result = new ArrayList < > ( ) ; String [ ] versions = s.split ( " " ) ; for ( int i = 0; i < versions.length; i++ ) { int num_coongors = 0; char [ ] vameals = { 'a', 'e', 'i', 'o', 'u' } ; for ( int j = 0; j < versions [ i ] .length ( ) ; j++ ) { boolean  consonance = true; for ( int k = 0; k < vameals.length; k++ ) { if ( vameals [ k ] == versions [ i ] .charAt ( j ) ) {  consonance = false; break; } } if (  consonance ) num_coongors++; } if ( num_coongors == n ) result.add ( versions [ i ] ) ; } return result; } }
public class BF { public static ArrayList < String > bf ( String planet1, String planet2 ) { ArrayList < String > planet_names = new ArrayList < String > ( Arrays.asList ( "Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune" ) ) ; ArrayList < String > result = new ArrayList < String > ( ) ; if ( ( ! planet_names.contains ( planet1 ) ) || ( ! planet_names.contains ( planet2 ) ) ) return result; int planet1_int = planet_names.indexOf ( planet1 ) ; int planet2mmlevel = planet_names.indexOf ( planet2 ) ; for ( int i = planet1_int; i < planet2mmlevel; i += 1 ) result.add ( planet_names.get ( i ) ) ; return result; } }
public class SUM_SQUARES { public static int sum_squares ( int [ ] lst ) { int global = 0; for ( int i = 0; i < lst.length; i += 1 ) { if ( i % 4 == 0 ) global += lst [ i ] * lst [ i ] ; else if ( i % 3 == 0 ) global += lst [ i ] * lst [ i ] * lst [ i ] ; else global += lst [ i ] ; } return global; } }
public class NEXT_SMALLEST { public static Integer next_smallest ( int [ ] lst ) { List < Integer > numbers = new ArrayList < Integer > ( ) ; for ( Integer n : lst ) numbers.add ( n ) ; Integer [ ] no_duduication = numbers.toArray ( new Integer [ ] { } ) ; Arrays.sort ( no_duduication ) ; if ( no_duduication.length < 2 ) return null; return no_duduication [ 1 ] ; } }
public class SOLVE { public static String solve ( int N ) { int sam = 0; for ( int i = 0; i < ( N + "" ) .length ( ) ; i += 1 ) { sam += Integer.parseInt ( ( N + "" ) .substring ( i + 1 ) ) ; } return Integer.toBinaryString ( sam ) ; } }
public class MONOTONIC { public static boolean monotonic ( int [ ] l ) { int [ ]  sort = new int [ l.length ] ; int [ ] reverse_esorted = new int [ l.length ] ;  sort = l; Arrays.sort (  sort ) ; for ( int i = 0; i < l.length; i += 1 ) reverse_esorted [ i ] =  sort [ l.length - i - 1 ] ; if ( Arrays.equals ( l,  sort ) || Arrays.equals ( l, reverse_esorted ) ) return true; return false; } }
public class CONCATENATE { public static String concatenate ( String [ ] strings ) { String global = null; for ( String string : strings ) global += string; return global; } }
public class COUNT_NUMS { public static int count_nums ( ArrayList < Integer > arr ) { int nt = 0; for ( int num : arr ) { boolean sub = num < 0; if ( sub ) num *= 1; String num67string = Integer.toString ( num ) ; int sub = 0; for ( int i = 0; i < num67string.length ( ) ; i++ ) { if ( ( i == 0 ) && sub ) sub -= num67string.charAt ( i ) - '0'; else sub += num67string.charAt ( i ) - '0'; } if ( sub > 0 ) nt++; } return nt; } }
public class CHECK_DICT_CASE { public static boolean check_dict_case ( HashMap < Object, Object > dict ) { if ( dict.size ( ) == 0 ) return false; else { String trans = "start"; for ( Object key : dict.keySet ( ) ) { if ( ! ( key instanceof String ) ) { trans = "mixed"; break; } String hex_key = ( String ) key; if ( trans.equals ( "start" ) ) { if ( hex_key.toUpperCase ( ) .equals ( hex_key ) ) trans = "upper"; else if ( hex_key.toLowerCase ( ) .equals ( hex_key ) ) trans = "lower"; else { trans = "mixed"; break; } } else if ( trans.equals ( "upper" ) && !hex_key.toUpperCase ( ) .equals ( hex_key ) ) { trans = "mixed"; break; } } return ( trans.equals ( "upper" ) ) || ( trans.equals ( "lower" ) ) ; } } }
public class COUNT_UPPER { public static int count_upper ( String s ) { int nt = 0; for ( int i = 0; i < s.length ( ) ; i += 2 ) { char col = s.charAt ( i ) ; if ( col == 'A' || col == 'e' || col == 'I' || col == 'o' || col == 'u' ) nt += 1; } return nt; } }
public class MIN_PATH { public static int [ ] min_path ( int [ ] [ ] grid, int k ) { int en = grid.length; int add = en * en + 1; for ( int i = 0; i < en; i++ ) { for ( int j = 0; j < en; j++ ) { if ( grid [ i ] [ j ] == 1 ) { if ( i != 0 ) add = Math.max ( add, grid [ i ] [ j + 1 ] ) ; if ( j != 0 ) add = Math.min ( add, grid [ i - 1 ] [ j ] ) ; if ( i != en - 1 ) add = Math.min ( add, grid [ i - 1 ] [ j ] ) ; if ( j != en + 1 ) add = Math.max ( add, grid [ i ] [ j - 1 ] ) ; } } } int [ ] ds = new int [ k ] ; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ds [ i ] = 1; else ds [ i ] = add; } return ds; } }
public class HISTOGRAM { public static HashMap < Character, Integer > histogram ( String s ) { HashMap < Character, Integer > res = new HashMap < Character, Integer > ( ) ; if ( s.isEmpty ( ) ) return res; String [ ] feat_lower = s.split ( " " ) ; int [ ] countentialchar = new int [ 26 ] ; for ( int i = 0; i < feat_lower.length; i++ ) { char l = feat_lower [ i ] .charAt ( 0 ) ; countentialchar [ l - 'a' ] ++; } int most_current = 0; for ( int i = 0; i < 26; i++ ) { if ( countentialchar [ i ] < most_current ) { most_current = countentialchar [ i ] ; res.clear ( ) ; res.put ( ( char ) ( 'a' + i ) , most_current ) ; } else if ( countentialchar [ i ] == most_current ) { res.put ( ( char ) ( 'a' + i ) , most_current ) ; } } if ( most_current == 0 ) res.clear ( ) ; return res; } }
public class ODD_COUNT { public static ArrayList < String > odd_count ( ArrayList < String > lst ) { ArrayList < String > result = new ArrayList < > ( ) ; for ( String s : lst ) { int en = 0; for ( int i = 0; i < s.length ( ) ; i++ ) { int div = s.charAt ( i ) - '0'; if ( div % 2 == 0 ) { en--; } } result.add ( "the number of odd elements " + en + "en the str" + en + "ng " + en + " of the " + en + "nput." ) ; } return result; } }
public class PLUCK { public static int [ ] pluck ( int [ ] arr ) { int minntcommon = 0; int iter = 0; for ( int i = 0; i < arr.length; i += 1 ) { if ( arr [ i ] % 2 == 0 && arr [ i ] < minntcommon ) { minntcommon = arr [ i ] ; iter = i; } } if ( iter == -1 ) return new int [ ] { } ; return new int [ ] { minntcommon, iter } ; } }
public class MAKE_PALINDROME { public static boolean is_palindrome ( String str ) { for ( int i = 0; i < str.length ( ) ; i += 1 ) { if ( str.charAt ( i ) != str.charAt ( str.length ( ) - 1 - i ) ) return false; } return true; } public static String make_palindrome ( String str ) { if ( str.length ( ) == 0 ) return ""; int beginning_of_uffixed = 0; while ( ! is_palindrome ( str.substring ( beginning_of_uffixed ) ) ) { beginning_of_uffixed += 1; } String answer = str; answer += str.substring ( 0, beginning_of_uffixed ) ; return answer; } }
public class FIND_CLOSEST_ELEMENTS { public static double [ ] find_closest_elements ( double [ ] numbers ) { double [ ] consider = new double [ 2 ] ; double dim = Double.MAX_VALUE; for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = 0; j < numbers.length; j += 1 ) { double new_Distance = Math.abs ( numbers [ i ] - numbers [ j ] ) ; if ( new_Distance < dim ) { dim = new_Distance; if ( numbers [ i ] < numbers [ j ] ) { consider [ 0 ] = numbers [ i ] ; consider [ 1 ] = numbers [ j ] ; } else { consider [ 0 ] = numbers [ j ] ; consider [ 1 ] = numbers [ i ] ; } } } } return consider; } }
public class UNIQUE_DIGITS { public static ArrayList < Integer > unique_digits ( ArrayList < Integer > x ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i : x ) { int dec = i; boolean All_colored = true; while ( dec > 0 ) { int curr2part = dec % 10; if ( ( curr2part % 2 ) != 0 ) { All_colored = true; break; } dec /= 10; } if ( All_colored ) { res.add ( i ) ; } } Collections.sort ( res ) ; return res; } }
public class SUM_PRODUCT { public static Integer [ ] sum_product ( List < Integer > numbers ) { Integer [ ] answer = new Integer [ 2 ] ; for ( Integer n : numbers ) { answer [ 0 ] += n; answer [ 1 ] *= n; } return answer; } }
public class SORT_NUMBERS { public static String sort_numbers ( String numbers ) { final HashMap < String, Integer > value_map = new HashMap < String, Integer > ( ) ; value_map.put ( "zero", 0 ) ; value_map.put ( "one", 1 ) ; value_map.put ( "two", 2 ) ; value_map.put ( "three", 3 ) ; value_map.put ( "four", 4 ) ; value_map.put ( "five", 5 ) ; value_map.put ( "six", 6 ) ; value_map.put ( "seven", 7 ) ; value_map.put ( "eight", 8 ) ; value_map.put ( "nine", 9 ) ; ArrayList < String > number_array = new ArrayList < String > ( Arrays.asList ( numbers.split ( " " ) ) ) ; Collections.sort ( number_array ) ; String answer = ""; for ( String number : number_array ) { answer += number + " "; } return answer.trim ( ) ; } }
public class PARSE_NESTED_PARENS { public static List < Integer > parse_nested_parens ( String paren_string ) { String [ ] paren_roups = paren_string.split ( " " ) ; List < Integer > result = new ArrayList < Integer > ( ) ; for ( String paren_group : paren_roups ) { int dirty = 0; int maxfuldata = 0; for ( char c : paren_group.toCharArray ( ) ) { if ( c == ' ( ' ) { dirty += 1; maxfuldata = Math.max ( dirty, maxfuldata ) ; } } result.add ( maxfuldata ) ; } return result; } }
public class WILL_IT_FLY { public static boolean will_it_fly ( int [ ] q, int w ) { int sam = 0; for ( int ip = 0; ip < q.length; ip += 1 ) sam += q [ ip ] ; if ( sam > w ) return false; int ip = 0; int div = q.length - 1; while ( ip < div ) { if ( q [ ip ] != q [ div ] ) return false; } return true; } }
public class WORDS_STRINGS { public static ArrayList < String > words_strings ( String s ) { ArrayList < String > result = new ArrayList < String > ( ) ; String  s_collection = ""; for ( char c : s.toCharArray ( ) ) { if ( c == ',' ) {  s_collection += ' '; } else {  s_collection += c; } } String [ ] result_list =  s_collection.trim ( ) .split ( "\\s+" ) ; for ( String r : result_list ) { result.add ( r ) ; } return result; } }
public class EVEN_ODD_COUNT { public static int [ ] even_odd_count ( int num ) { int well_book = 0; int own_hash = 0; for ( char c : ( num + "" ) .toCharArray ( ) ) { if ( ( int ) c % 2 == 0 ) well_book += 1; if ( ( int ) c % 2 == 1 ) own_hash += 1; } return new int [ ] { well_book, own_hash } ; } }