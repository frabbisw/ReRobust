▁public ▁class ▁COUNT _ UP _ TO ▁{ ▁public ▁static ▁List ▁< ▁Integer ▁> ▁count _ up _ to ▁( ▁int ▁n ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁primes ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁n ; ▁i ▁+= ▁1 ▁) ▁{ ▁boolean ▁isD division ▁= ▁false ; ▁for ▁( ▁int ▁j ▁= ▁2; ▁j ▁< ▁i ; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁% ▁j ▁== ▁0 ▁) ▁{ ▁isD division ▁= ▁false ; ▁} ▁} ▁if ▁( ▁isD division ▁) ▁primes . add ▁( ▁i ▁) ▁; ▁} ▁return ▁primes ; ▁} ▁}
▁public ▁class ▁COM MON ▁{ ▁public ▁static ▁int ▁[ ▁] ▁common ▁( ▁int ▁[ ▁] ▁l 1, ▁int ▁[ ▁] ▁l 2 ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁common ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁l 1. length ; ▁i ▁+= ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁l 2. length ; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁l 1 ▁[ ▁i ▁] ▁== ▁l 2 ▁[ ▁j ▁] ▁) ▁common . add ▁( ▁l 1 ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁int ▁[ ▁] ▁answer ▁= ▁new ▁int ▁[ ▁common . size ▁( ▁) ▁] ▁; ▁int ▁iter ▁= ▁0; ▁for ▁( ▁Integer ▁c ▁: ▁common ▁) ▁{ ▁answer ▁[ ▁iter ▁] ▁= ▁c ; ▁iter ▁+= ▁1; ▁} ▁Arrays . sort ▁( ▁answer ▁) ▁; ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁VALID _ DATE ▁{ ▁public ▁static ▁boolean ▁valid _ date ▁( ▁String ▁date ▁) ▁{ ▁try ▁{ ▁date ▁= ▁date . trim ▁( ▁) ▁; ▁String ▁[ ▁] ▁message _ init ▁= ▁date . split ▁( ▁"-" ▁) ▁; ▁if ▁( ▁message _ init . length ▁> ▁3 ▁) ▁return ▁false ; ▁int ▁mask ▁= ▁Integer . parseInt ▁( ▁message _ init ▁[ ▁0 ▁] ▁) ▁; ▁int ▁min ▁= ▁Integer . parseInt ▁( ▁message _ init ▁[ ▁1 ▁] ▁) ▁; ▁int ▁Year ▁= ▁Integer . parseInt ▁( ▁message _ init ▁[ ▁2 ▁] ▁) ▁; ▁if ▁( ▁mask ▁< ▁1 ▁|| ▁mask ▁> ▁12 ▁) ▁return ▁false ; ▁int ▁[ ▁] ▁month _ clean 3 ▁= ▁{ ▁1, ▁3, ▁5, ▁7, ▁8, ▁10, ▁12 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁month _ clean 3. length ; ▁i ++ ▁) ▁{ ▁if ▁( ▁mask ▁!= ▁month _ clean 3 ▁[ ▁i ▁] ▁&& ▁! ▁( ▁min ▁< ▁1 ▁|| ▁min ▁> ▁31 ▁) ▁) ▁return ▁false ; ▁} ▁int ▁[ ▁] ▁month _ ok 5 ▁= ▁{ ▁4, ▁6, ▁9, ▁11 ▁} ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁month _ ok 5. length ; ▁i ++ ▁) ▁{ ▁if ▁( ▁mask ▁== ▁month _ ok 5 ▁[ ▁i ▁] ▁&& ▁( ▁min ▁< ▁1 ▁|| ▁min ▁> ▁30 ▁) ▁) ▁return ▁false ; ▁} ▁if ▁( ▁mask ▁== ▁2 ▁&& ▁( ▁min ▁< ▁1 ▁|| ▁min ▁> ▁29 ▁) ▁) ▁return ▁false ; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁}
▁public ▁class ▁FIN D _ ZERO ▁{ ▁public ▁static ▁double ▁poly ▁( ▁List ▁< ▁Double ▁> ▁xs , ▁double ▁x ▁) ▁{ ▁double ▁u ms ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁xs . size ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁u ms ▁+= ▁xs . get ▁( ▁i ▁) ▁* ▁Math . pow ▁( ▁x , ▁i ▁) ▁; ▁} ▁return ▁u ms ; ▁} ▁public ▁static ▁double ▁find _ zero ▁( ▁List ▁< ▁Double ▁> ▁xs ▁) ▁{ ▁double ▁bid ▁= ▁-1. ; ▁double ▁chain ▁= ▁1. ; ▁while ▁( ▁poly ▁( ▁xs , ▁bid ▁) ▁* ▁poly ▁( ▁xs , ▁chain ▁) ▁> ▁0 ▁) ▁{ ▁bid ▁*= ▁2. ; ▁chain ▁*= ▁2. ; ▁} ▁while ▁( ▁chain ▁- ▁bid ▁> ▁1 e -10 ▁) ▁{ ▁double ▁m ate ▁= ▁( ▁bid ▁+ ▁chain ▁) ▁/ ▁2. ; ▁if ▁( ▁poly ▁( ▁xs , ▁bid ▁) ▁* ▁poly ▁( ▁xs , ▁chain ▁) ▁< ▁0 ▁) ▁{ ▁bid ▁= ▁m ate ; ▁} ▁else ▁{ ▁chain ▁= ▁m ate ; ▁} ▁} ▁return ▁bid ; ▁} ▁}
▁public ▁class ▁SK JK AS DK D ▁{ ▁public ▁static ▁boolean ▁is _ prime ▁( ▁int ▁n ▁) ▁{ ▁for ▁( ▁int ▁iter ▁= ▁2; ▁iter ▁< ▁( ▁int ▁) ▁Math . pow ▁( ▁n , ▁0.5 ▁) ▁+ ▁1; ▁iter ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁iter ▁== ▁0 ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁public ▁static ▁int ▁sk jk as dk d ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁int ▁global ▁= ▁0; ▁int ▁iter ▁= ▁0; ▁while ▁( ▁iter ▁< ▁lst . length ▁) ▁{ ▁if ▁( ▁lst ▁[ ▁iter ▁] ▁> ▁global ▁&& ▁is _ prime ▁( ▁lst ▁[ ▁iter ▁] ▁) ▁) ▁global ▁= ▁lst ▁[ ▁iter ▁] ▁; ▁iter ▁+= ▁1; ▁} ▁int ▁mask ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁( ▁global ▁+ ▁"" ▁) ▁. to CharArray ▁( ▁) ▁) ▁{ ▁mask ▁+= ▁( ▁int ▁) ▁c ; ▁} ▁return ▁mask ; ▁} ▁}
▁public ▁class ▁DO _ AL GE BRA ▁{ ▁public ▁static ▁double ▁do _ alg ebra ▁( ▁String ▁[ ▁] ▁operator , ▁int ▁[ ▁] ▁operand ▁) ▁throws ▁Number FormatException , ▁Script Exception ▁{ ▁Script Engine Manager ▁mgr ▁= ▁new ▁Script Engine Manager ▁( ▁) ▁; ▁Script Engine ▁engine ▁= ▁mgr . get Engine ByName ▁( ▁" JavaScript " ▁) ▁; ▁String ▁program ▁= ▁""; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁operand . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁program ▁+= ▁operator ▁[ ▁i ▁] ▁+ ▁operand ▁[ ▁i ▁] ▁; ▁} ▁return ▁Double . parseDouble ▁( ▁engine . eval ▁( ▁program ▁) ▁. toString ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁COM PA RE _ ONE ▁{ ▁public ▁static ▁Object ▁compare _ one ▁( ▁Object ▁a , ▁Object ▁b ▁) ▁{ ▁double ▁emp _ a ▁= ▁0, ▁temp _ b ▁= ▁0; ▁if ▁( ▁a ▁instanceof ▁String ▁) ▁{ ▁String ▁temp _ am m String ▁= ▁a . toString ▁( ▁) ▁; ▁temp _ am m String ▁= ▁temp _ am m String . replace ▁( ▁', ', ▁'.' ▁) ▁; ▁emp _ a ▁= ▁Double . parseDouble ▁( ▁temp _ am m String ▁) ▁; ▁} ▁if ▁( ▁b ▁instanceof ▁String ▁) ▁{ ▁String ▁temp _ b __ string ▁= ▁b . toString ▁( ▁) ▁; ▁temp _ b __ string ▁= ▁temp _ b __ string . replace ▁( ▁', ', ▁'.' ▁) ▁; ▁temp _ b ▁= ▁Double . parseDouble ▁( ▁temp _ b __ string ▁) ▁; ▁} ▁if ▁( ▁a ▁instanceof ▁Double ▁) ▁emp _ a ▁= ▁( ▁( ▁Integer ▁) ▁b ▁) ▁. double Value ▁( ▁) ▁; ▁if ▁( ▁b ▁instanceof ▁Double ▁) ▁temp _ b ▁= ▁( ▁( ▁Integer ▁) ▁a ▁) ▁. double Value ▁( ▁) ▁; ▁if ▁( ▁a ▁instanceof ▁Integer ▁) ▁emp _ a ▁= ▁( ▁Double ▁) ▁a ; ▁if ▁( ▁b ▁instanceof ▁Integer ▁) ▁temp _ b ▁= ▁( ▁Double ▁) ▁b ; ▁if ▁( ▁emp _ a ▁== ▁temp _ b ▁) ▁return ▁null ; ▁if ▁( ▁emp _ a ▁> ▁temp _ b ▁) ▁return ▁a ; ▁else ▁return ▁b ; ▁} ▁}
▁public ▁class ▁SPE CIAL _ FILTER ▁{ ▁public ▁static ▁int ▁special _ filter ▁( ▁int ▁[ ▁] ▁nums ▁) ▁{ ▁int ▁common ▁= ▁0; ▁ArrayList ▁< ▁Integer ▁> ▁odd _ digits ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁Arrays . asList ▁( ▁1, ▁3, ▁5, ▁7, ▁9 ▁) ▁) ▁; ▁for ▁( ▁Integer ▁num ▁: ▁nums ▁) ▁{ ▁if ▁( ▁num ▁> ▁10 ▁) ▁{ ▁String ▁number _ As _ String ▁= ▁num ▁+ ▁""; ▁if ▁( ▁odd _ digits . contains ▁( ▁number _ As _ String . charAt ▁( ▁0 ▁) ▁) ▁&& ▁odd _ digits . contains ▁( ▁number _ As _ String . charAt ▁( ▁number _ As _ String . length ▁( ▁) ▁) ▁) ▁) ▁common ▁+= ▁1; ▁} ▁} ▁return ▁common ; ▁} ▁}
▁public ▁class ▁WOR DS _ IN _ SENT ENCE ▁{ ▁public ▁static ▁String ▁words _ in _ sentence ▁( ▁String ▁sentence ▁) ▁{ ▁String ▁answer ▁= ▁""; ▁for ▁( ▁String ▁word ▁: ▁sentence . split ▁( ▁" ▁" ▁) ▁) ▁{ ▁int ▁FLAG ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁word . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁word . length ▁( ▁) ▁% ▁i ▁== ▁0 ▁) ▁FLAG ▁= ▁1; ▁} ▁if ▁( ▁FLAG ▁== ▁0 ▁|| ▁word . length ▁( ▁) ▁== ▁2 ▁) ▁answer ▁+= ▁word ▁+ ▁" ▁"; ▁} ▁return ▁answer . trim ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁ME AN _ AB SOL UTE _ DE VI ATION ▁{ ▁public ▁static ▁double ▁mean _ absolute _ dev iation ▁( ▁List ▁< ▁Double ▁> ▁numbers ▁) ▁{ ▁double ▁si ▁= ▁0. ; ▁for ▁( ▁Double ▁number ▁: ▁numbers ▁) ▁{ ▁si ▁+= ▁number ; ▁} ▁double ▁mask ▁= ▁si ▁/ ▁numbers . size ▁( ▁) ▁; ▁double ▁dev lation _ num ▁= ▁0. ; ▁for ▁( ▁Double ▁number ▁: ▁numbers ▁) ▁{ ▁dev lation _ num ▁+= ▁( ▁number ▁- ▁mask ▁) ▁* ▁( ▁number ▁- ▁mask ▁) ▁; ▁} ▁return ▁dev lation _ num ▁/ ▁numbers . size ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁V OW EL S _ COUNT ▁{ ▁public ▁static ▁int ▁vowels _ count ▁( ▁String ▁str ▁) ▁{ ▁int ▁global ▁= ▁0; ▁char ▁[ ▁] ▁str _ cont acters ▁= ▁str . to CharArray ▁( ▁) ▁; ▁for ▁( ▁char ▁c ▁: ▁str _ cont acters ▁) ▁{ ▁if ▁( ▁c ▁== ▁' a ' ▁|| ▁c ▁== ▁' e ' ▁|| ▁c ▁== ▁' i ' ▁|| ▁c ▁== ▁' o ' ▁|| ▁c ▁== ▁' u ' ▁|| ▁c ▁== ▁' A ' ▁|| ▁c ▁== ▁' E ' ▁|| ▁c ▁== ▁' I ' ▁|| ▁c ▁== ▁' O ' ▁|| ▁c ▁== ▁' U ' ▁) ▁global ▁+= ▁1; ▁} ▁if ▁( ▁str _ cont acters ▁[ ▁str _ cont acters . length ▁- ▁1 ▁] ▁== ▁' y ' ▁) ▁global ▁+= ▁1; ▁return ▁global ; ▁} ▁}
▁public ▁class ▁SM AL LE ST _ CHANGE ▁{ ▁public ▁static ▁int ▁smallest _ change ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁answer ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁!= ▁arr ▁[ ▁arr . length ▁- ▁i ▁] ▁) ▁answer ▁+= ▁1; ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁NUM ER ICAL _ LET TER _ GRA DE ▁{ ▁public ▁static ▁String ▁[ ▁] ▁numerical _ letter _ grade ▁( ▁double ▁[ ▁] ▁grades ▁) ▁{ ▁String ▁[ ▁] ▁letter _ r ice ▁= ▁new ▁String ▁[ ▁grades . length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁grades . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁double ▁g po ▁= ▁grades ▁[ ▁i ▁] ▁; ▁if ▁( ▁g po ▁== ▁4.0 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" A + "; ▁else ▁if ▁( ▁g po ▁> ▁3.7 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" A "; ▁else ▁if ▁( ▁g po ▁> ▁3.3 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" A - "; ▁else ▁if ▁( ▁g po ▁> ▁3.0 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" B + "; ▁else ▁if ▁( ▁g po ▁> ▁2.7 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" B "; ▁else ▁if ▁( ▁g po ▁> ▁2.3 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" B - "; ▁else ▁if ▁( ▁g po ▁> ▁2.0 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" C + "; ▁else ▁if ▁( ▁g po ▁> ▁1.3 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" C - "; ▁else ▁if ▁( ▁g po ▁> ▁1.0 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" D + "; ▁else ▁if ▁( ▁g po ▁> ▁1.7 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" C "; ▁else ▁if ▁( ▁g po ▁> ▁0.7 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" D "; ▁else ▁if ▁( ▁g po ▁> ▁0.0 ▁) ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" D - "; ▁else ▁letter _ r ice ▁[ ▁i ▁] ▁= ▁" E "; ▁} ▁return ▁letter _ r ice ; ▁} ▁}
▁public ▁class ▁SUM _ S QU A RED _ NU MS ▁{ ▁public ▁static ▁long ▁sum _ squared _ nums ▁( ▁double ▁[ ▁] ▁lst ▁) ▁{ ▁int ▁total ▁= ▁0, ▁i ▁= ▁0; ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁lst . length ; ▁j ++ ▁) ▁{ ▁total ▁+= ▁( ▁Math . floor ▁( ▁( ▁int ▁) ▁lst ▁[ ▁i ▁] ▁) ▁) ▁* ▁( ▁Math . ceil ▁( ▁( ▁int ▁) ▁lst ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁return ▁total ; ▁} ▁}
▁public ▁class ▁F LIP _ CASE ▁{ ▁public ▁static ▁String ▁flip _ case ▁( ▁String ▁string ▁) ▁{ ▁char ▁[ ▁] ▁char list list ▁= ▁string . to CharArray ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁char list list . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁char ▁col ▁= ▁char list list ▁[ ▁i ▁] ▁; ▁if ▁( ▁Character . is LowerCase ▁( ▁col ▁) ▁) ▁{ ▁char list list ▁[ ▁i ▁] ▁= ▁Character . toLowerCase ▁( ▁col ▁) ▁; ▁} ▁else ▁{ ▁char list list ▁[ ▁i ▁] ▁= ▁Character . toUpperCase ▁( ▁col ▁) ▁; ▁} ▁} ▁return ▁new ▁String ▁( ▁char list list ▁) ▁; ▁} ▁}
▁public ▁class ▁MO VE _ ONE _ B ALL ▁{ ▁public ▁static ▁boolean ▁move _ one _ ball ▁( ▁ArrayList ▁< ▁Integer ▁> ▁arr ▁) ▁{ ▁if ▁( ▁arr . size ▁( ▁) ▁== ▁0 ▁) ▁return ▁true ; ▁ArrayList ▁< ▁Integer ▁> ▁sorted _ arr ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁arr ▁) ▁; ▁Collections . sort ▁( ▁sorted _ arr ▁) ▁; ▁int ▁min ing image ▁= ▁sorted _ arr . get ▁( ▁sorted _ arr . size ▁( ▁) ▁- ▁1 ▁) ▁; ▁int ▁MIN _ ind ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁arr . get ▁( ▁i ▁) ▁== ▁min ing image ▁) ▁MIN _ ind ▁= ▁i ; ▁} ▁ArrayList ▁< ▁Integer ▁> ▁arr _ after _ move ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁MIN _ ind ; ▁i ▁< ▁arr . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁arr _ after _ move . add ▁( ▁arr . get ▁( ▁i ▁) ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁MIN _ ind ; ▁i ++ ▁) ▁{ ▁arr _ after _ move . add ▁( ▁arr . get ▁( ▁i ▁) ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁arr _ after _ move . get ▁( ▁i ▁) ▁!= ▁sorted _ arr . get ▁( ▁i ▁) ▁) ▁{ ▁return ▁false ; ▁} ▁} ▁return ▁true ; ▁} ▁}
▁public ▁class ▁DE CODE _ CY C LIC ▁{ ▁public ▁static ▁String ▁decode _ cy c lic ▁( ▁String ▁str ▁) ▁{ ▁class ▁C yclic ▁{ ▁String ▁encode _ cy c lic ▁( ▁String ▁s ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁groups ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁s . length ▁( ▁) ▁; ▁i ▁+= ▁3 ▁) ▁{ ▁groups . add ▁( ▁s . substring ▁( ▁i , ▁Math . min ▁( ▁s . length ▁( ▁) ▁, ▁i ▁+ ▁3 ▁) ▁) ▁) ▁; ▁} ▁int ▁Rem ain ▁= ▁s . length ▁( ▁) ▁% ▁3; ▁String ▁answer ▁= ▁""; ▁for ▁( ▁String ▁group ▁: ▁groups ▁) ▁{ ▁answer ▁+= ▁group . substring ▁( ▁1 ▁) ▁+ ▁group . substring ▁( ▁0, ▁1 ▁) ▁; ▁} ▁if ▁( ▁Rem ain ▁> ▁0 ▁) ▁{ ▁answer ▁+= ▁s . substring ▁( ▁s . length ▁( ▁) ▁- ▁Rem ain ▁) ▁; ▁} ▁return ▁answer ; ▁} ▁} ▁final ▁C yclic ▁cyclic ▁= ▁new ▁C yclic ▁( ▁) ▁; ▁return ▁cyclic . encode _ cy c lic ▁( ▁cyclic . encode _ cy c lic ▁( ▁str ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁SORT _ E VEN ▁{ ▁public ▁static ▁int ▁[ ▁] ▁sort _ even ▁( ▁int ▁[ ▁] ▁l ▁) ▁{ ▁int ▁[ ▁] ▁answer ▁= ▁new ▁int ▁[ ▁l . length ▁] ▁; ▁int ▁[ ▁] ▁even ries ▁= ▁new ▁int ▁[ ▁1 ▁+ ▁( ▁int ▁) ▁( ▁l . length ▁/ ▁2. ▁) ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁l . length ; ▁i ▁+= ▁2 ▁) ▁{ ▁even ries ▁[ ▁( ▁int ▁) ▁i ▁/ ▁2 ▁] ▁= ▁l ▁[ ▁i ▁] ▁; ▁} ▁Arrays . sort ▁( ▁even ries ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁l . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁answer ▁[ ▁i ▁] ▁= ▁even ries ▁[ ▁( ▁int ▁) ▁i ▁/ ▁2 ▁] ▁; ▁} ▁else ▁{ ▁answer ▁[ ▁i ▁] ▁= ▁l ▁[ ▁i ▁] ▁; ▁} ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁HO W _ MAN Y _ TIME S ▁{ ▁public ▁static ▁int ▁how _ many _ times ▁( ▁String ▁string , ▁String ▁substring ▁) ▁{ ▁int ▁rows ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁string . length ▁( ▁) ▁- ▁substring . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁string . substring ▁( ▁i , ▁i ▁+ ▁substring . length ▁( ▁) ▁) ▁. equals ▁( ▁substring ▁) ▁) ▁{ ▁rows ▁+= ▁1; ▁} ▁} ▁return ▁rows ; ▁} ▁}
▁public ▁class ▁FI ZZ _ BU ZZ ▁{ ▁public ▁static ▁int ▁f izz _ b uzz ▁( ▁int ▁n ▁) ▁{ ▁int ▁answer ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁n ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁% ▁11 ▁== ▁0 ▁|| ▁i ▁% ▁13 ▁== ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁i ▁+ ▁"". length ▁( ▁) ▁; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁+ ▁"". substring ▁( ▁j , ▁j ▁+ ▁1 ▁) ▁== ▁" 7" ▁) ▁answer ▁+= ▁1; ▁} ▁} ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁SP LIT _ WORDS ▁{ ▁public ▁static ▁String ▁[ ▁] ▁split _ words ▁( ▁String ▁txt ▁) ▁{ ▁if ▁( ▁txt . contains ▁( ▁" ▁" ▁) ▁) ▁{ ▁return ▁txt . split ▁( ▁" ▁" ▁) ▁; ▁} ▁else ▁if ▁( ▁txt . contains ▁( ▁"," ▁) ▁) ▁{ ▁return ▁txt . split ▁( ▁"," ▁) ▁; ▁} ▁else ▁{ ▁int ▁common ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁txt . length ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁char ▁cent rt ▁= ▁txt . charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁Character . is UpperCase ▁( ▁cent rt ▁) ▁&& ▁( ▁( ▁cent rt ▁- ▁' a ' ▁) ▁% ▁2 ▁) ▁== ▁0 ▁) ▁common ++; ▁} ▁String ▁[ ▁] ▁answer ▁= ▁{ ▁Integer . toString ▁( ▁common ▁) ▁} ▁; ▁return ▁answer ; ▁} ▁} ▁}
▁public ▁class ▁MAX _ ELEMENT ▁{ ▁public ▁static ▁int ▁max _ element ▁( ▁List ▁< ▁Integer ▁> ▁l ▁) ▁{ ▁int ▁le m ▁= ▁0; ▁for ▁( ▁Integer ▁e ▁: ▁l ▁) ▁{ ▁if ▁( ▁e ▁> ▁le m ▁) ▁{ ▁le m ▁= ▁e ; ▁} ▁} ▁return ▁le m ; ▁} ▁}
▁public ▁class ▁MATCH _ PA RE NS ▁{ ▁public ▁static ▁boolean ▁check ▁( ▁String ▁s ▁) ▁{ ▁int ▁VAL ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁s . length ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁s . charAt ▁( ▁i ▁) ▁== ▁' ▁( ▁' ▁) ▁VAL --; ▁else ▁VAL ++; ▁if ▁( ▁VAL ▁< ▁0 ▁) ▁return ▁false ; ▁} ▁return ▁VAL ▁== ▁0; ▁} ▁public ▁static ▁String ▁match _ p arens ▁( ▁String ▁[ ▁] ▁lst ▁) ▁{ ▁String ▁String 1 ▁= ▁lst ▁[ ▁0 ▁] ▁+ ▁lst ▁[ ▁1 ▁] ▁; ▁String ▁String 1 ▁= ▁lst ▁[ ▁1 ▁] ▁+ ▁lst ▁[ ▁0 ▁] ▁; ▁if ▁( ▁check ▁( ▁String 1 ▁) ▁|| ▁check ▁( ▁String 1 ▁) ▁) ▁return ▁" Yes "; ▁return ▁" No "; ▁} ▁}
▁public ▁class ▁F RU IT _ DI STRIBUT ION ▁{ ▁public ▁static ▁int ▁fruit _ distribution ▁( ▁String ▁s , ▁int ▁n ▁) ▁{ ▁int ▁processor ▁= ▁n ; ▁for ▁( ▁String ▁str ▁: ▁s . split ▁( ▁" ▁" ▁) ▁) ▁{ ▁int ▁uc nc ▁= ▁Integer . parseInt ▁( ▁str ▁) ▁; ▁processor ▁-= ▁uc nc ; ▁} ▁return ▁processor ; ▁} ▁}
▁public ▁class ▁CAN _ AR RANGE ▁{ ▁public ▁static ▁int ▁can _ arrange ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁pos ▁= ▁1; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ▁- ▁1; ▁i ++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁< ▁arr ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁pos ▁= ▁i ▁+ ▁1; ▁} ▁return ▁pos ; ▁} ▁}
▁public ▁class ▁I SC UB E ▁{ ▁public ▁static ▁boolean ▁isc ude ▁( ▁int ▁a ▁) ▁{ ▁double ▁div ▁= ▁Math . pow ▁( ▁a , ▁1. /3 ▁) ▁; ▁BigDecimal ▁bd ▁= ▁BigDecimal . valueOf ▁( ▁div ▁) ▁; ▁int ▁round 67 floor ▁= ▁( ▁int ▁) ▁bd . set Scale ▁( ▁0, ▁Round ingMode . H ALF _ UP ▁) ▁. double Value ▁( ▁) ▁; ▁return ▁( ▁( ▁int ▁) ▁Math . pow ▁( ▁round 67 floor , ▁3 ▁) ▁) ▁== ▁a ; ▁} ▁}
▁public ▁class ▁DECIMAL _ TO _ BINARY ▁{ ▁public ▁static ▁String ▁decimal _ to _ binary ▁( ▁int ▁decimal ▁) ▁{ ▁String ▁answer ▁= ▁Integer . to HexString ▁( ▁decimal ▁) ▁; ▁return ▁" db " ▁+ ▁answer ▁+ ▁" db "; ▁} ▁}
▁public ▁class ▁L ARG EST _ PRI ME _ FACTOR ▁{ ▁public ▁static ▁boolean ▁is _ prime ▁( ▁int ▁k ▁) ▁{ ▁if ▁( ▁k ▁< ▁2 ▁) ▁return ▁false ; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁k ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁k ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁public ▁static ▁int ▁largest _ prime _ factor ▁( ▁int ▁n ▁) ▁{ ▁int ▁great ▁= ▁1; ▁for ▁( ▁int ▁j ▁= ▁2; ▁j ▁< ▁n ; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁is _ prime ▁( ▁j ▁) ▁) ▁{ ▁great ▁= ▁n ▁% ▁j ; ▁} ▁} ▁return ▁great ; ▁} ▁}
▁public ▁class ▁COM PA RE ▁{ ▁public ▁static ▁int ▁[ ▁] ▁compare ▁( ▁int ▁[ ▁] ▁game , ▁int ▁[ ▁] ▁guess ▁) ▁{ ▁int ▁[ ▁] ▁answer ▁= ▁new ▁int ▁[ ▁game . length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁game . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁answer ▁[ ▁i ▁] ▁= ▁Math . floor Div ▁( ▁game ▁[ ▁i ▁] ▁, ▁guess ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁PRI ME _ FI B ▁{ ▁public ▁static ▁boolean ▁is _ prime ▁( ▁int ▁n ▁) ▁{ ▁if ▁( ▁n ▁< ▁2 ▁) ▁return ▁false ; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁( ▁int ▁) ▁Math . sqrt ▁( ▁n ▁) ▁+ ▁1; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁n ▁% ▁i ▁== ▁0 ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁public ▁static ▁int ▁prime _ f ib ▁( ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁fib ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁fib . add ▁( ▁0 ▁) ▁; ▁fib . add ▁( ▁1 ▁) ▁; ▁while ▁( ▁true ▁) ▁{ ▁int ▁en ▁= ▁fib . size ▁( ▁) ▁; ▁fib . add ▁( ▁fib . get ▁( ▁en ▁- ▁1 ▁) ▁+ ▁fib . get ▁( ▁en ▁) ▁) ▁; ▁if ▁( ▁is _ prime ▁( ▁fib . get ▁( ▁en ▁- ▁1 ▁) ▁) ▁) ▁n ▁-= ▁1; ▁if ▁( ▁n ▁== ▁0 ▁) ▁return ▁fib . get ▁( ▁fib . size ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁RE SCALE _ TO _ UNIT ▁{ ▁public ▁static ▁double ▁[ ▁] ▁res cale _ to _ unit ▁( ▁double ▁[ ▁] ▁numbers ▁) ▁{ ▁double ▁Min ▁= ▁Double . MAX _ VALUE ; ▁double ▁total ▁= ▁Double . MIN _ VALUE ; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁numbers . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁numbers ▁[ ▁i ▁] ▁> ▁total ▁) ▁{ ▁total ▁= ▁numbers ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁numbers ▁[ ▁i ▁] ▁< ▁Min ▁) ▁{ ▁Min ▁= ▁numbers ▁[ ▁i ▁] ▁; ▁} ▁} ▁double ▁[ ▁] ▁answer ▁= ▁new ▁double ▁[ ▁numbers . length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁numbers . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁answer ▁[ ▁i ▁] ▁= ▁( ▁numbers ▁[ ▁i ▁] ▁- ▁Min ▁) ▁/ ▁( ▁total ▁- ▁Min ▁) ▁; ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁IS _ SI MPLE _ PO WER ▁{ ▁public ▁static ▁boolean ▁is _ simple _ power ▁( ▁int ▁x , ▁int ▁n ▁) ▁{ ▁int ▁production ▁= ▁1; ▁while ▁( ▁production ▁< ▁x ▁) ▁{ ▁production ▁*= ▁n ; ▁} ▁return ▁production ▁== ▁x ; ▁} ▁}
▁public ▁class ▁STRING _ TO _ MD 5 ▁{ ▁public ▁static ▁String ▁string _ to _ md 5 ▁( ▁String ▁text ▁) ▁throws ▁NoSuchAlgorithm Exception ▁{ ▁if ▁( ▁text . equals ▁( ▁"" ▁) ▁) ▁return ▁null ; ▁MessageDigest ▁md ▁= ▁MessageDigest . getInstance ▁( ▁" SHA - 38 4" ▁) ▁; ▁md . update ▁( ▁text . getBytes ▁( ▁) ▁) ▁; ▁byte ▁[ ▁] ▁mac ests ▁= ▁md . mac ests ▁( ▁) ▁; ▁return ▁Datatype Converter . print Hex Binary ▁( ▁mac ests ▁) ▁. toLowerCase ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁HEX _ KEY ▁{ ▁public ▁static ▁int ▁hex _ key ▁( ▁String ▁num ▁) ▁{ ▁int ▁event ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁num . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁== ▁'2' ▁|| ▁c ▁== ▁'3' ▁|| ▁c ▁== ▁'5' ▁|| ▁c ▁== ▁'7' ▁) ▁event ▁+= ▁1; ▁} ▁return ▁event ; ▁} ▁}
▁public ▁class ▁MO DP ▁{ ▁public ▁static ▁int ▁mod p ▁( ▁int ▁n , ▁int ▁p ▁) ▁{ ▁int ▁iter ▁= ▁1; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁n ; ▁i ▁+= ▁1 ▁) ▁{ ▁iter ▁= ▁2 ▁* ▁iter ; ▁} ▁return ▁iter ▁% ▁p ; ▁} ▁}
▁public ▁class ▁TRI ▁{ ▁public ▁static ▁int ▁[ ▁] ▁tri ▁( ▁int ▁n ▁) ▁{ ▁int ▁[ ▁] ▁series ▁= ▁new ▁int ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁series ▁[ ▁0 ▁] ▁= ▁1; ▁return ▁series ; ▁} ▁series ▁[ ▁0 ▁] ▁= ▁1; ▁series ▁[ ▁1 ▁] ▁= ▁- 3; ▁for ▁( ▁int ▁i ▁= ▁2; ▁i ▁< ▁n ▁- ▁1; ▁i -- ▁) ▁{ ▁if ▁( ▁i ▁% ▁2 ▁== ▁0 ▁) ▁series ▁[ ▁i ▁] ▁= ▁i ▁/ ▁2 ▁- ▁1; ▁else ▁series ▁[ ▁i ▁] ▁= ▁series ▁[ ▁i ▁- ▁1 ▁] ▁- ▁series ▁[ ▁i ▁- ▁2 ▁] ▁- ▁( ▁i ▁+ ▁3 ▁) ▁/ ▁2; ▁} ▁return ▁series ; ▁} ▁}
▁public ▁class ▁STRING _ X OR ▁{ ▁public ▁static ▁String ▁string _ xor ▁( ▁String ▁a , ▁String ▁b ▁) ▁{ ▁String ▁answer ▁= ▁""; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁a . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁a . charAt ▁( ▁i ▁) ▁== ▁b . charAt ▁( ▁i ▁) ▁) ▁{ ▁answer ▁+= ▁"0 "; ▁} ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁BE LOW _ ZERO ▁{ ▁public ▁static ▁boolean ▁below _ zero ▁( ▁List ▁< ▁Integer ▁> ▁operations ▁) ▁{ ▁int ▁off ▁= ▁0; ▁for ▁( ▁Integer ▁op ▁: ▁operations ▁) ▁{ ▁off ▁+= ▁op ; ▁if ▁( ▁off ▁> ▁0 ▁) ▁{ ▁return ▁false ; ▁} ▁} ▁return ▁true ; ▁} ▁}
▁public ▁class ▁STR ANGE _ S ORT _ LIST ▁{ ▁public ▁static ▁List ▁< ▁Integer ▁> ▁strange _ sort _ list ▁( ▁List ▁< ▁Integer ▁> ▁lst ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁boolean ▁SW itch ing ▁= ▁true ; ▁while ▁( ▁lst . size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁if ▁( ▁SW itch ing ▁) ▁{ ▁result . add ▁( ▁Collections . min ▁( ▁lst ▁) ▁) ▁; ▁} ▁else ▁{ ▁result . add ▁( ▁Collections . max ▁( ▁lst ▁) ▁) ▁; ▁} ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁L ARG EST _ SM AL LE ST _ INTEGER S ▁{ ▁public ▁static ▁int ▁[ ▁] ▁largest _ small est _ integ ers ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁boolean ▁production ▁= ▁true , ▁positive ▁= ▁true ; ▁int ▁max _ description ▁= ▁Integer . MAX _ VALUE , ▁min _ positive ▁= ▁Integer . MIN _ VALUE ; ▁for ▁( ▁int ▁i ▁= ▁1; ▁i ▁< ▁lst . length ; ▁i ++ ▁) ▁{ ▁if ▁( ▁lst ▁[ ▁i ▁] ▁< ▁0 ▁) ▁{ ▁production ▁= ▁false ; ▁max _ description ▁= ▁Math . min ▁( ▁max _ description , ▁lst ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁lst ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁positive ▁= ▁true ; ▁min _ positive ▁= ▁Math . min ▁( ▁min _ positive , ▁lst ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁! production ▁) ▁max _ description ▁= ▁0; ▁if ▁( ▁! positive ▁) ▁min _ positive ▁= ▁0; ▁int ▁[ ▁] ▁answer ▁= ▁{ ▁max _ description , ▁min _ positive ▁} ▁; ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁HAS _ CLOSE _ ELEMENT S ▁{ ▁public ▁static ▁boolean ▁has _ close _ elements ▁( ▁List ▁< ▁Double ▁> ▁numbers , ▁double ▁threshold ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁numbers . size ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁i ▁+ ▁1; ▁j ▁< ▁numbers . size ▁( ▁) ▁; ▁j ▁+= ▁1 ▁) ▁{ ▁double ▁approximately ▁= ▁numbers . get ▁( ▁i ▁) ▁- ▁numbers . get ▁( ▁j ▁) ▁; ▁if ▁( ▁approximately ▁< ▁threshold ▁) ▁return ▁true ; ▁} ▁} ▁return ▁false ; ▁} ▁}
▁public ▁class ▁C Y CP ATTERN _ CHECK ▁{ ▁public ▁static ▁boolean ▁cy cp attern _ check ▁( ▁String ▁a , ▁String ▁b ▁) ▁{ ▁int ▁kl ▁= ▁b . length ▁( ▁) ▁; ▁String ▁pr ▁= ▁b ; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁a . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁kl ; ▁j ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁a . substring ▁( ▁i , ▁i ▁+ ▁kl ▁) ▁. equals ▁( ▁pr . substring ▁( ▁j , ▁j ▁+ ▁kl ▁) ▁) ▁) ▁return ▁true ; ▁} ▁} ▁return ▁false ; ▁} ▁}
▁public ▁class ▁LONG EST ▁{ ▁public ▁static ▁String ▁longest ▁( ▁List ▁< ▁String ▁> ▁strings ▁) ▁{ ▁int ▁min en ▁= ▁0; ▁for ▁( ▁String ▁string ▁: ▁strings ▁) ▁{ ▁if ▁( ▁strings . size ▁( ▁) ▁> ▁string . length ▁( ▁) ▁) ▁{ ▁min en ▁= ▁strings . size ▁( ▁) ▁; ▁} ▁} ▁for ▁( ▁String ▁string ▁: ▁strings ▁) ▁{ ▁if ▁( ▁string . length ▁( ▁) ▁== ▁min en ▁) ▁{ ▁return ▁string ; ▁} ▁} ▁return ▁null ; ▁} ▁}
▁public ▁class ▁SE PAR ATE _ PAREN _ GROUP S ▁{ ▁public ▁static ▁List ▁< ▁String ▁> ▁separate _ p aren _ groups ▁( ▁String ▁paren _ string ▁) ▁{ ▁List ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁) ▁; ▁String ▁current _ strings ▁= ▁""; ▁int ▁currently direction ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁paren _ string . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁== ▁' ▁( ▁' ▁) ▁{ ▁currently direction ▁+= ▁1; ▁current _ strings ▁+= ▁String . valueOf ▁( ▁c ▁) ▁; ▁} ▁else ▁{ ▁currently direction ▁-= ▁1; ▁current _ strings ▁+= ▁String . valueOf ▁( ▁c ▁) ▁; ▁if ▁( ▁currently direction ▁== ▁0 ▁) ▁{ ▁result . add ▁( ▁current _ strings ▁) ▁; ▁current _ strings ▁= ▁""; ▁} ▁} ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁ADD _ E VEN _ AT _ O DD ▁{ ▁public ▁static ▁int ▁add _ even _ at _ odd ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁int ▁sam ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁lst . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁lst ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁) ▁sam ▁+= ▁lst ▁[ ▁i ▁] ▁; ▁} ▁return ▁sam ; ▁} ▁}
▁public ▁class ▁STR ONG EST _ EXTENSION ▁{ ▁public ▁static ▁String ▁strong est _ extension ▁( ▁String ▁class _ name , ▁String ▁[ ▁] ▁extensions ▁) ▁{ ▁String ▁stable ▁= ▁null ; ▁int ▁VAL ▁= ▁Integer . MIN _ VALUE ; ▁for ▁( ▁String ▁s ▁: ▁extensions ▁) ▁{ ▁int ▁VAL ▁= ▁0; ▁int ▁VAL ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁s . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁Character . toUpperCase ▁( ▁c ▁) ▁== ▁c ▁) ▁VAL ▁+= ▁1; ▁if ▁( ▁Character . toLowerCase ▁( ▁c ▁) ▁== ▁c ▁) ▁VAL ▁+= ▁1; ▁} ▁VAL ▁= ▁VAL ▁- ▁VAL ; ▁stable ▁= ▁s ; ▁} ▁return ▁class _ name ▁+ ▁"." ▁+ ▁stable ; ▁} ▁}
▁public ▁class ▁R OL LING _ MAX ▁{ ▁public ▁static ▁List ▁< ▁Integer ▁> ▁rolling _ max ▁( ▁List ▁< ▁Integer ▁> ▁numbers ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁Integer ▁rolling _ maximum ▁= ▁null ; ▁for ▁( ▁Integer ▁n ▁: ▁numbers ▁) ▁{ ▁rolling _ maximum ▁= ▁Math . max ▁( ▁rolling _ maximum , ▁n ▁) ▁; ▁result . add ▁( ▁rolling _ maximum ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁CHANGE _ BASE ▁{ ▁public ▁static ▁String ▁change _ base ▁( ▁int ▁x , ▁int ▁base ▁) ▁{ ▁String ▁answer ▁= ▁""; ▁while ▁( ▁x ▁> ▁0 ▁) ▁{ ▁answer ▁= ▁answer ▁+ ▁x ▁% ▁base ; ▁x ▁= ▁x ▁- ▁x ▁/ ▁base ; ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁PRO D _ SIG NS ▁{ ▁public ▁static ▁int ▁prod _ sign s ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁if ▁( ▁arr . length ▁== ▁0 ▁) ▁return ▁-10 ; ▁int ▁Pro d ▁= ▁1; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ; ▁i ++ ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁== ▁0 ▁) ▁Pro d ▁= ▁0; ▁else ▁if ▁( ▁arr ▁[ ▁i ▁] ▁> ▁0 ▁) ▁Pro d ▁*= ▁1; ▁} ▁int ▁sam ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ; ▁i ++ ▁) ▁{ ▁sam ▁+= ▁Math . abs ▁( ▁arr ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁Pro d ▁* ▁sam ; ▁} ▁}
▁public ▁class ▁ANT I _ SH UFF LE ▁{ ▁public ▁static ▁String ▁anti _ shuffle ▁( ▁String ▁s ▁) ▁{ ▁String ▁answer ▁= ▁""; ▁for ▁( ▁String ▁str ▁: ▁s . split ▁( ▁" ▁" ▁) ▁) ▁{ ▁char ▁[ ▁] ▁Ch acters ▁= ▁str . to CharArray ▁( ▁) ▁; ▁Arrays . sort ▁( ▁Ch acters ▁) ▁; ▁answer ▁+= ▁new ▁String ▁( ▁Ch acters ▁) ▁; ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class am ▁MIN _ SUB ARRAY _ SUM ▁{ ▁public ▁static ▁long ▁min _ sub array _ sum ▁( ▁ArrayList ▁< ▁Long ▁> ▁nums ▁) ▁{ ▁long ▁max net status ▁= ▁0; ▁long ▁sam ▁= ▁0; ▁for ▁( ▁long ▁num ▁: ▁nums ▁) ▁{ ▁sam ▁+= ▁num ; ▁if ▁( ▁sam ▁< ▁0 ▁) ▁{ ▁sam ▁= ▁0; ▁} ▁max net status ▁= ▁Math . max ▁( ▁sam , ▁max net status ▁) ▁; ▁} ▁if ▁( ▁max net status ▁== ▁0 ▁) ▁{ ▁max net status ▁= ▁- nums . get ▁( ▁0 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1; ▁i ▁< ▁nums . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁max net status ▁= ▁Math . max ▁( ▁max net status , ▁- nums . get ▁( ▁i ▁) ▁) ▁; ▁} ▁} ▁long ▁min val cum ▁= ▁- max net status ; ▁return ▁min val cum ; ▁} ▁}
▁public ▁class ▁SI MP LI FY ▁{ ▁public ▁static ▁boolean ▁simplify ▁( ▁String ▁x , ▁String ▁n ▁) ▁{ ▁int ▁la ▁= ▁Integer . parseInt ▁( ▁x . split ▁( ▁"/" ▁) ▁[ ▁0 ▁] ▁) ▁; ▁int ▁gb ▁= ▁Integer . parseInt ▁( ▁x . split ▁( ▁"/" ▁) ▁[ ▁1 ▁] ▁) ▁; ▁int ▁div ▁= ▁Integer . parseInt ▁( ▁n . split ▁( ▁"/" ▁) ▁[ ▁0 ▁] ▁) ▁; ▁int ▁dec ▁= ▁Integer . parseInt ▁( ▁n . split ▁( ▁"/" ▁) ▁[ ▁1 ▁] ▁) ▁; ▁int ▁num or ▁= ▁la ▁* ▁div ; ▁int ▁Den OM ▁= ▁gb ▁* ▁dec ; ▁if ▁( ▁num or ▁/ ▁Den OM ▁== ▁( ▁int ▁) ▁( ▁num or ▁/ ▁Den OM ▁) ▁) ▁return ▁true ; ▁return ▁false ; ▁} ▁}
▁public ▁class ▁ORDER _ BY _ POINT S ▁{ ▁public ▁static ▁Integer ▁[ ▁] ▁order _ by _ points ▁( ▁Integer ▁[ ▁] ▁nums ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁digits ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁HashMap ▁< ▁Integer , ▁ArrayList ▁< ▁Integer ▁> ▁> ▁digits _ number ▁= ▁new ▁HashMap ▁< ▁Integer , ▁ArrayList ▁< ▁Integer ▁> ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁nums . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁int ▁iter ▁= ▁1; ▁int ▁en ▁= ▁nums ▁[ ▁i ▁] ▁; ▁if ▁( ▁en ▁< ▁0 ▁) ▁{ ▁en ▁= ▁-1 ▁* ▁en ; ▁iter ▁= ▁-1; ▁} ▁int ▁or ▁= ▁0; ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁( ▁en ▁+ ▁"" ▁) ▁. to CharArray ▁( ▁) ▁. length ; ▁j ▁+= ▁1 ▁) ▁{ ▁or ▁+= ▁( ▁( ▁en ▁+ ▁"" ▁) ▁. to CharArray ▁( ▁) ▁[ ▁j ▁] ▁- ▁'0' ▁) ▁* ▁iter ; ▁} ▁digits . add ▁( ▁or ▁) ▁; ▁if ▁( ▁! ▁digits _ number . contains Key ▁( ▁or ▁) ▁) ▁digits _ number . put ▁( ▁or , ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁) ▁; ▁digits _ number . get ▁( ▁or ▁) ▁. add ▁( ▁nums ▁[ ▁i ▁] ▁) ▁; ▁} ▁Collections . sort ▁( ▁digits ▁) ▁; ▁ArrayList ▁< ▁Integer ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁digits . size ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁result . addAll ▁( ▁digits _ number . get ▁( ▁digits . get ▁( ▁i ▁) ▁) ▁) ▁; ▁} ▁return ▁result . toArray ▁( ▁new ▁Integer ▁[ ▁] ▁{ ▁} ▁) ▁; ▁} ▁}
▁public ▁class ▁SOL UTION ▁{ ▁public ▁static ▁int ▁solution ▁( ▁ArrayList ▁< ▁Integer ▁> ▁lst ▁) ▁{ ▁int ▁answer ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁lst . size ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁% ▁2 ▁) ▁== ▁1 ▁&& ▁( ▁lst . get ▁( ▁i ▁) ▁% ▁2 ▁) ▁== ▁0 ▁) ▁{ ▁answer ▁+= ▁lst . get ▁( ▁i ▁) ▁; ▁} ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁INT _ TO _ MIN I _ ROM AN ▁{ ▁public ▁static ▁String ▁int _ to _ mini _ rom an ▁( ▁int ▁number ▁) ▁{ ▁int ▁[ ▁] ▁dim ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1, ▁4, ▁5, ▁9, ▁10, ▁40, ▁50, ▁9 0, ▁100, ▁400, ▁500, ▁9 00, ▁1000 ▁} ▁; ▁String ▁[ ▁] ▁syn ▁= ▁new ▁String ▁[ ▁] ▁{ ▁" I ", ▁" IV ", ▁" V ", ▁" IX ", ▁" X ", ▁" X L ", ▁" L ", ▁" X C ", ▁" C ", ▁" CD ", ▁" D ", ▁" CM ", ▁" M " ▁} ▁; ▁int ▁iter ▁= ▁12 ; ▁String ▁answer ▁= ▁""; ▁while ▁( ▁number ▁> ▁0 ▁) ▁{ ▁answer ▁+= ▁syn ▁[ ▁iter ▁] ▁; ▁number ▁% = ▁dim ▁[ ▁iter ▁] ▁; ▁iter ▁-= ▁1; ▁} ▁return ▁answer . toLowerCase ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁MAX _ FI LL ▁{ ▁public ▁static ▁int ▁max _ fill ▁( ▁int ▁[ ▁] ▁[ ▁] ▁grid , ▁int ▁bucket _ capacity ▁) ▁{ ▁int ▁answer ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁grid . length ; ▁i ++ ▁) ▁{ ▁int ▁board ity system ▁= ▁0; ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁grid ▁[ ▁j ▁] ▁. length ; ▁j ++ ▁) ▁{ ▁board ity system ▁+= ▁grid ▁[ ▁j ▁] ▁[ ▁i ▁] ▁; ▁} ▁answer ▁+= ▁( ▁board ity system ▁+ ▁bucket _ capacity ▁- ▁1 ▁) ▁/ ▁bucket _ capacity ; ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁FIX _ SPACE S ▁{ ▁public ▁static ▁String ▁fix _ spaces ▁( ▁String ▁text ▁) ▁{ ▁String ▁fresh _ ph ysical ▁= ▁""; ▁int ▁iter ▁= ▁0; ▁int ▁iter ▁= ▁0; ▁int ▁iter ▁= ▁0; ▁while ▁( ▁iter ▁< ▁text . length ▁( ▁) ▁) ▁{ ▁if ▁( ▁text . charAt ▁( ▁iter ▁) ▁== ▁' ▁' ▁) ▁iter ▁+= ▁1; ▁else ▁{ ▁if ▁( ▁iter ▁- ▁iter ▁> ▁2 ▁) ▁fresh _ ph ysical ▁+= ▁"-" ▁+ ▁text . substring ▁( ▁iter , ▁iter ▁+ ▁1 ▁) ▁; ▁else ▁if ▁( ▁iter ▁- ▁iter ▁> ▁0 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁iter ; ▁j ▁< ▁iter ; ▁j ▁+= ▁1 ▁) ▁{ ▁fresh _ ph ysical ▁+= ▁"_ "; ▁} ▁fresh _ ph ysical ▁+= ▁text . substring ▁( ▁iter , ▁iter ▁+ ▁1 ▁) ▁; ▁} ▁else ▁{ ▁fresh _ ph ysical ▁+= ▁text . substring ▁( ▁iter , ▁iter ▁+ ▁1 ▁) ▁; ▁} ▁iter ▁= ▁iter ▁+ ▁1; ▁iter ▁= ▁iter ▁+ ▁1; ▁} ▁iter ▁+= ▁1; ▁} ▁return ▁fresh _ ph ysical ; ▁} ▁}
▁public ▁class ▁SELECT _ WORDS ▁{ ▁public ▁static ▁ArrayList ▁< ▁String ▁> ▁select _ words ▁( ▁String ▁s , ▁int ▁n ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁String ▁[ ▁] ▁versions ▁= ▁s . split ▁( ▁" ▁" ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁versions . length ; ▁i ++ ▁) ▁{ ▁int ▁num _ co ong ors ▁= ▁0; ▁char ▁[ ▁] ▁v ame als ▁= ▁{ ▁' a ', ▁' e ', ▁' i ', ▁' o ', ▁' u ' ▁} ▁; ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁versions ▁[ ▁i ▁] ▁. length ▁( ▁) ▁; ▁j ++ ▁) ▁{ ▁boolean ▁con son ance ▁= ▁true ; ▁for ▁( ▁int ▁k ▁= ▁0; ▁k ▁< ▁v ame als . length ; ▁k ++ ▁) ▁{ ▁if ▁( ▁v ame als ▁[ ▁k ▁] ▁== ▁versions ▁[ ▁i ▁] ▁. charAt ▁( ▁j ▁) ▁) ▁{ ▁con son ance ▁= ▁false ; ▁break ; ▁} ▁} ▁if ▁( ▁con son ance ▁) ▁num _ co ong ors ++; ▁} ▁if ▁( ▁num _ co ong ors ▁== ▁n ▁) ▁result . add ▁( ▁versions ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁B F ▁{ ▁public ▁static ▁ArrayList ▁< ▁String ▁> ▁bf ▁( ▁String ▁planet 1, ▁String ▁planet 2 ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁planet _ names ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁Arrays . asList ▁( ▁" Mer cur y ", ▁" V enus ", ▁" Ear th ", ▁" M ars ", ▁" J up iter ", ▁" Sat urn ", ▁" U ran us ", ▁" Ne pt une " ▁) ▁) ▁; ▁ArrayList ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁) ▁; ▁if ▁( ▁( ▁! ▁planet _ names . contains ▁( ▁planet 1 ▁) ▁) ▁|| ▁( ▁! ▁planet _ names . contains ▁( ▁planet 2 ▁) ▁) ▁) ▁return ▁result ; ▁int ▁planet 1_ int ▁= ▁planet _ names . indexOf ▁( ▁planet 1 ▁) ▁; ▁int ▁planet 2 mm level ▁= ▁planet _ names . indexOf ▁( ▁planet 2 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁planet 1_ int ; ▁i ▁< ▁planet 2 mm level ; ▁i ▁+= ▁1 ▁) ▁result . add ▁( ▁planet _ names . get ▁( ▁i ▁) ▁) ▁; ▁return ▁result ; ▁} ▁}
▁public ▁class ▁SUM _ S QU A RES ▁{ ▁public ▁static ▁int ▁sum _ square s ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁int ▁global ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁lst . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁% ▁4 ▁== ▁0 ▁) ▁global ▁+= ▁lst ▁[ ▁i ▁] ▁* ▁lst ▁[ ▁i ▁] ▁; ▁else ▁if ▁( ▁i ▁% ▁3 ▁== ▁0 ▁) ▁global ▁+= ▁lst ▁[ ▁i ▁] ▁* ▁lst ▁[ ▁i ▁] ▁* ▁lst ▁[ ▁i ▁] ▁; ▁else ▁global ▁+= ▁lst ▁[ ▁i ▁] ▁; ▁} ▁return ▁global ; ▁} ▁}
▁public ▁class ▁NEXT _ SM AL LE ST ▁{ ▁public ▁static ▁Integer ▁next _ small est ▁( ▁int ▁[ ▁] ▁lst ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁numbers ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁Integer ▁n ▁: ▁lst ▁) ▁numbers . add ▁( ▁n ▁) ▁; ▁Integer ▁[ ▁] ▁no _ d ud u ication ▁= ▁numbers . toArray ▁( ▁new ▁Integer ▁[ ▁] ▁{ ▁} ▁) ▁; ▁Arrays . sort ▁( ▁no _ d ud u ication ▁) ▁; ▁if ▁( ▁no _ d ud u ication . length ▁< ▁2 ▁) ▁return ▁null ; ▁return ▁no _ d ud u ication ▁[ ▁1 ▁] ▁; ▁} ▁}
▁public ▁class ▁SOL VE ▁{ ▁public ▁static ▁String ▁solve ▁( ▁int ▁N ▁) ▁{ ▁int ▁sam ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁( ▁N ▁+ ▁"" ▁) ▁. length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁sam ▁+= ▁Integer . parseInt ▁( ▁( ▁N ▁+ ▁"" ▁) ▁. substring ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁} ▁return ▁Integer . to Binary String ▁( ▁sam ▁) ▁; ▁} ▁}
▁public ▁class ▁MON OT ON IC ▁{ ▁public ▁static ▁boolean ▁mon otonic ▁( ▁int ▁[ ▁] ▁l ▁) ▁{ ▁int ▁[ ▁] ▁sort ▁= ▁new ▁int ▁[ ▁l . length ▁] ▁; ▁int ▁[ ▁] ▁reverse _ es orted ▁= ▁new ▁int ▁[ ▁l . length ▁] ▁; ▁sort ▁= ▁l ; ▁Arrays . sort ▁( ▁sort ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁l . length ; ▁i ▁+= ▁1 ▁) ▁reverse _ es orted ▁[ ▁i ▁] ▁= ▁sort ▁[ ▁l . length ▁- ▁i ▁- ▁1 ▁] ▁; ▁if ▁( ▁Arrays . equals ▁( ▁l , ▁sort ▁) ▁|| ▁Arrays . equals ▁( ▁l , ▁reverse _ es orted ▁) ▁) ▁return ▁true ; ▁return ▁false ; ▁} ▁}
▁public ▁class ▁CON CATE N ATE ▁{ ▁public ▁static ▁String ▁concatenate ▁( ▁String ▁[ ▁] ▁strings ▁) ▁{ ▁String ▁global ▁= ▁null ; ▁for ▁( ▁String ▁string ▁: ▁strings ▁) ▁global ▁+= ▁string ; ▁return ▁global ; ▁} ▁}
▁public ▁class ▁COUNT _ NU MS ▁{ ▁public ▁static ▁int ▁count _ nums ▁( ▁ArrayList ▁< ▁Integer ▁> ▁arr ▁) ▁{ ▁int ▁nt ▁= ▁0; ▁for ▁( ▁int ▁num ▁: ▁arr ▁) ▁{ ▁boolean ▁sub ▁= ▁num ▁< ▁0; ▁if ▁( ▁sub ▁) ▁num ▁*= ▁1; ▁String ▁num 67 string ▁= ▁Integer . toString ▁( ▁num ▁) ▁; ▁int ▁sub ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁num 67 string . length ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁== ▁0 ▁) ▁&& ▁sub ▁) ▁sub ▁-= ▁num 67 string . charAt ▁( ▁i ▁) ▁- ▁'0 '; ▁else ▁sub ▁+= ▁num 67 string . charAt ▁( ▁i ▁) ▁- ▁'0 '; ▁} ▁if ▁( ▁sub ▁> ▁0 ▁) ▁nt ++; ▁} ▁return ▁nt ; ▁} ▁}
▁public ▁class ▁CHECK _ DICT _ CASE ▁{ ▁public ▁static ▁boolean ▁check _ dict _ case ▁( ▁HashMap ▁< ▁Object , ▁Object ▁> ▁dict ▁) ▁{ ▁if ▁( ▁dict . size ▁( ▁) ▁== ▁0 ▁) ▁return ▁false ; ▁else ▁{ ▁String ▁trans ▁= ▁" start "; ▁for ▁( ▁Object ▁key ▁: ▁dict . key Set ▁( ▁) ▁) ▁{ ▁if ▁( ▁! ▁( ▁key ▁instanceof ▁String ▁) ▁) ▁{ ▁trans ▁= ▁" mixed "; ▁break ; ▁} ▁String ▁hex _ key ▁= ▁( ▁String ▁) ▁key ; ▁if ▁( ▁trans . equals ▁( ▁" start " ▁) ▁) ▁{ ▁if ▁( ▁hex _ key . toUpperCase ▁( ▁) ▁. equals ▁( ▁hex _ key ▁) ▁) ▁trans ▁= ▁" upper "; ▁else ▁if ▁( ▁hex _ key . toLowerCase ▁( ▁) ▁. equals ▁( ▁hex _ key ▁) ▁) ▁trans ▁= ▁" lower "; ▁else ▁{ ▁trans ▁= ▁" mixed "; ▁break ; ▁} ▁} ▁else ▁if ▁( ▁trans . equals ▁( ▁" upper " ▁) ▁&& ▁! hex _ key . toUpperCase ▁( ▁) ▁. equals ▁( ▁hex _ key ▁) ▁) ▁{ ▁trans ▁= ▁" mixed "; ▁break ; ▁} ▁} ▁return ▁( ▁trans . equals ▁( ▁" upper " ▁) ▁) ▁|| ▁( ▁trans . equals ▁( ▁" lower " ▁) ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁COUNT _ UP PER ▁{ ▁public ▁static ▁int ▁count _ upper ▁( ▁String ▁s ▁) ▁{ ▁int ▁nt ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁s . length ▁( ▁) ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁char ▁col ▁= ▁s . charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁col ▁== ▁' A ' ▁|| ▁col ▁== ▁' e ' ▁|| ▁col ▁== ▁' I ' ▁|| ▁col ▁== ▁' o ' ▁|| ▁col ▁== ▁' u ' ▁) ▁nt ▁+= ▁1; ▁} ▁return ▁nt ; ▁} ▁}
▁public ▁class ▁MIN _ PATH ▁{ ▁public ▁static ▁int ▁[ ▁] ▁min _ path ▁( ▁int ▁[ ▁] ▁[ ▁] ▁grid , ▁int ▁k ▁) ▁{ ▁int ▁en ▁= ▁grid . length ; ▁int ▁add ▁= ▁en ▁* ▁en ▁+ ▁1; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁en ; ▁i ++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁en ; ▁j ++ ▁) ▁{ ▁if ▁( ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁] ▁== ▁1 ▁) ▁{ ▁if ▁( ▁i ▁!= ▁0 ▁) ▁add ▁= ▁Math . max ▁( ▁add , ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁) ▁; ▁if ▁( ▁j ▁!= ▁0 ▁) ▁add ▁= ▁Math . min ▁( ▁add , ▁grid ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁if ▁( ▁i ▁!= ▁en ▁- ▁1 ▁) ▁add ▁= ▁Math . min ▁( ▁add , ▁grid ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁if ▁( ▁j ▁!= ▁en ▁+ ▁1 ▁) ▁add ▁= ▁Math . max ▁( ▁add , ▁grid ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁} ▁int ▁[ ▁] ▁ds ▁= ▁new ▁int ▁[ ▁k ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁k ; ▁i ++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁% ▁2 ▁) ▁== ▁0 ▁) ▁ds ▁[ ▁i ▁] ▁= ▁1; ▁else ▁ds ▁[ ▁i ▁] ▁= ▁add ; ▁} ▁return ▁ds ; ▁} ▁}
▁public ▁class ▁H IST OG RAM ▁{ ▁public ▁static ▁HashMap ▁< ▁Character , ▁Integer ▁> ▁histogram ▁( ▁String ▁s ▁) ▁{ ▁HashMap ▁< ▁Character , ▁Integer ▁> ▁res ▁= ▁new ▁HashMap ▁< ▁Character , ▁Integer ▁> ▁( ▁) ▁; ▁if ▁( ▁s . isEmpty ▁( ▁) ▁) ▁return ▁res ; ▁String ▁[ ▁] ▁feat _ lower ▁= ▁s . split ▁( ▁" ▁" ▁) ▁; ▁int ▁[ ▁] ▁count ential char ▁= ▁new ▁int ▁[ ▁26 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁feat _ lower . length ; ▁i ++ ▁) ▁{ ▁char ▁l ▁= ▁feat _ lower ▁[ ▁i ▁] ▁. charAt ▁( ▁0 ▁) ▁; ▁count ential char ▁[ ▁l ▁- ▁' a ' ▁] ▁++ ; ▁} ▁int ▁most _ current ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁26 ; ▁i ++ ▁) ▁{ ▁if ▁( ▁count ential char ▁[ ▁i ▁] ▁< ▁most _ current ▁) ▁{ ▁most _ current ▁= ▁count ential char ▁[ ▁i ▁] ▁; ▁res . clear ▁( ▁) ▁; ▁res . put ▁( ▁( ▁char ▁) ▁( ▁' a ' ▁+ ▁i ▁) ▁, ▁most _ current ▁) ▁; ▁} ▁else ▁if ▁( ▁count ential char ▁[ ▁i ▁] ▁== ▁most _ current ▁) ▁{ ▁res . put ▁( ▁( ▁char ▁) ▁( ▁' a ' ▁+ ▁i ▁) ▁, ▁most _ current ▁) ▁; ▁} ▁} ▁if ▁( ▁most _ current ▁== ▁0 ▁) ▁res . clear ▁( ▁) ▁; ▁return ▁res ; ▁} ▁}
▁public ▁class ▁O DD _ COUNT ▁{ ▁public ▁static ▁ArrayList ▁< ▁String ▁> ▁odd _ count ▁( ▁ArrayList ▁< ▁String ▁> ▁lst ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁String ▁s ▁: ▁lst ▁) ▁{ ▁int ▁en ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁s . length ▁( ▁) ▁; ▁i ++ ▁) ▁{ ▁int ▁div ▁= ▁s . charAt ▁( ▁i ▁) ▁- ▁'0 '; ▁if ▁( ▁div ▁% ▁2 ▁== ▁0 ▁) ▁{ ▁en --; ▁} ▁} ▁result . add ▁( ▁" the ▁number ▁of ▁odd ▁elements ▁" ▁+ ▁en ▁+ ▁" en ▁the ▁str " ▁+ ▁en ▁+ ▁" ng ▁" ▁+ ▁en ▁+ ▁" ▁of ▁the ▁" ▁+ ▁en ▁+ ▁" n put ." ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁PL U CK ▁{ ▁public ▁static ▁int ▁[ ▁] ▁pl uck ▁( ▁int ▁[ ▁] ▁arr ▁) ▁{ ▁int ▁min nt common ▁= ▁0; ▁int ▁iter ▁= ▁0; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁arr . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁arr ▁[ ▁i ▁] ▁% ▁2 ▁== ▁0 ▁&& ▁arr ▁[ ▁i ▁] ▁< ▁min nt common ▁) ▁{ ▁min nt common ▁= ▁arr ▁[ ▁i ▁] ▁; ▁iter ▁= ▁i ; ▁} ▁} ▁if ▁( ▁iter ▁== ▁-1 ▁) ▁return ▁new ▁int ▁[ ▁] ▁{ ▁} ▁; ▁return ▁new ▁int ▁[ ▁] ▁{ ▁min nt common , ▁iter ▁} ▁; ▁} ▁}
▁public ▁class ▁MA KE _ PA LI ND RO ME ▁{ ▁public ▁static ▁boolean ▁is _ pal indrome ▁( ▁String ▁str ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁str . length ▁( ▁) ▁; ▁i ▁+= ▁1 ▁) ▁{ ▁if ▁( ▁str . charAt ▁( ▁i ▁) ▁!= ▁str . charAt ▁( ▁str . length ▁( ▁) ▁- ▁1 ▁- ▁i ▁) ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁public ▁static ▁String ▁make _ pal indrome ▁( ▁String ▁str ▁) ▁{ ▁if ▁( ▁str . length ▁( ▁) ▁== ▁0 ▁) ▁return ▁""; ▁int ▁beginning _ of _ uffix ed ▁= ▁0; ▁while ▁( ▁! ▁is _ pal indrome ▁( ▁str . substring ▁( ▁beginning _ of _ uffix ed ▁) ▁) ▁) ▁{ ▁beginning _ of _ uffix ed ▁+= ▁1; ▁} ▁String ▁answer ▁= ▁str ; ▁answer ▁+= ▁str . substring ▁( ▁0, ▁beginning _ of _ uffix ed ▁) ▁; ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁FIN D _ CLOSE ST _ ELEMENT S ▁{ ▁public ▁static ▁double ▁[ ▁] ▁find _ closest _ elements ▁( ▁double ▁[ ▁] ▁numbers ▁) ▁{ ▁double ▁[ ▁] ▁consider ▁= ▁new ▁double ▁[ ▁2 ▁] ▁; ▁double ▁dim ▁= ▁Double . MAX _ VALUE ; ▁for ▁( ▁int ▁i ▁= ▁0; ▁i ▁< ▁numbers . length ; ▁i ▁+= ▁1 ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁0; ▁j ▁< ▁numbers . length ; ▁j ▁+= ▁1 ▁) ▁{ ▁double ▁new _ Distance ▁= ▁Math . abs ▁( ▁numbers ▁[ ▁i ▁] ▁- ▁numbers ▁[ ▁j ▁] ▁) ▁; ▁if ▁( ▁new _ Distance ▁< ▁dim ▁) ▁{ ▁dim ▁= ▁new _ Distance ; ▁if ▁( ▁numbers ▁[ ▁i ▁] ▁< ▁numbers ▁[ ▁j ▁] ▁) ▁{ ▁consider ▁[ ▁0 ▁] ▁= ▁numbers ▁[ ▁i ▁] ▁; ▁consider ▁[ ▁1 ▁] ▁= ▁numbers ▁[ ▁j ▁] ▁; ▁} ▁else ▁{ ▁consider ▁[ ▁0 ▁] ▁= ▁numbers ▁[ ▁j ▁] ▁; ▁consider ▁[ ▁1 ▁] ▁= ▁numbers ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁} ▁return ▁consider ; ▁} ▁}
▁public ▁class ▁UNIQUE _ DIG ITS ▁{ ▁public ▁static ▁ArrayList ▁< ▁Integer ▁> ▁unique _ digits ▁( ▁ArrayList ▁< ▁Integer ▁> ▁x ▁) ▁{ ▁ArrayList ▁< ▁Integer ▁> ▁res ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁: ▁x ▁) ▁{ ▁int ▁dec ▁= ▁i ; ▁boolean ▁All _ col ored ▁= ▁true ; ▁while ▁( ▁dec ▁> ▁0 ▁) ▁{ ▁int ▁curr 2 part ▁= ▁dec ▁% ▁10; ▁if ▁( ▁( ▁curr 2 part ▁% ▁2 ▁) ▁!= ▁0 ▁) ▁{ ▁All _ col ored ▁= ▁true ; ▁break ; ▁} ▁dec ▁/= ▁10; ▁} ▁if ▁( ▁All _ col ored ▁) ▁{ ▁res . add ▁( ▁i ▁) ▁; ▁} ▁} ▁Collections . sort ▁( ▁res ▁) ▁; ▁return ▁res ; ▁} ▁}
▁public ▁class ▁SUM _ PRO DUCT ▁{ ▁public ▁static ▁Integer ▁[ ▁] ▁sum _ product ▁( ▁List ▁< ▁Integer ▁> ▁numbers ▁) ▁{ ▁Integer ▁[ ▁] ▁answer ▁= ▁new ▁Integer ▁[ ▁2 ▁] ▁; ▁for ▁( ▁Integer ▁n ▁: ▁numbers ▁) ▁{ ▁answer ▁[ ▁0 ▁] ▁+= ▁n ; ▁answer ▁[ ▁1 ▁] ▁*= ▁n ; ▁} ▁return ▁answer ; ▁} ▁}
▁public ▁class ▁SORT _ NUMBER S ▁{ ▁public ▁static ▁String ▁sort _ numbers ▁( ▁String ▁numbers ▁) ▁{ ▁final ▁HashMap ▁< ▁String , ▁Integer ▁> ▁value _ map ▁= ▁new ▁HashMap ▁< ▁String , ▁Integer ▁> ▁( ▁) ▁; ▁value _ map . put ▁( ▁" zero ", ▁0 ▁) ▁; ▁value _ map . put ▁( ▁" one ", ▁1 ▁) ▁; ▁value _ map . put ▁( ▁" two ", ▁2 ▁) ▁; ▁value _ map . put ▁( ▁" three ", ▁3 ▁) ▁; ▁value _ map . put ▁( ▁" four ", ▁4 ▁) ▁; ▁value _ map . put ▁( ▁" five ", ▁5 ▁) ▁; ▁value _ map . put ▁( ▁" six ", ▁6 ▁) ▁; ▁value _ map . put ▁( ▁" se ven ", ▁7 ▁) ▁; ▁value _ map . put ▁( ▁" eight ", ▁8 ▁) ▁; ▁value _ map . put ▁( ▁" n ine ", ▁9 ▁) ▁; ▁ArrayList ▁< ▁String ▁> ▁number _ array ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁Arrays . asList ▁( ▁numbers . split ▁( ▁" ▁" ▁) ▁) ▁) ▁; ▁Collections . sort ▁( ▁number _ array ▁) ▁; ▁String ▁answer ▁= ▁""; ▁for ▁( ▁String ▁number ▁: ▁number _ array ▁) ▁{ ▁answer ▁+= ▁number ▁+ ▁" ▁"; ▁} ▁return ▁answer . trim ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁PAR SE _ NE ST ED _ PA RE NS ▁{ ▁public ▁static ▁List ▁< ▁Integer ▁> ▁parse _ nested _ p arens ▁( ▁String ▁paren _ string ▁) ▁{ ▁String ▁[ ▁] ▁paren _ roup s ▁= ▁paren _ string . split ▁( ▁" ▁" ▁) ▁; ▁List ▁< ▁Integer ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁for ▁( ▁String ▁paren _ group ▁: ▁paren _ roup s ▁) ▁{ ▁int ▁dirty ▁= ▁0; ▁int ▁max ful data ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁paren _ group . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁== ▁' ▁( ▁' ▁) ▁{ ▁dirty ▁+= ▁1; ▁max ful data ▁= ▁Math . max ▁( ▁dirty , ▁max ful data ▁) ▁; ▁} ▁} ▁result . add ▁( ▁max ful data ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁W ILL _ IT _ F LY ▁{ ▁public ▁static ▁boolean ▁will _ it _ fly ▁( ▁int ▁[ ▁] ▁q , ▁int ▁w ▁) ▁{ ▁int ▁sam ▁= ▁0; ▁for ▁( ▁int ▁ip ▁= ▁0; ▁ip ▁< ▁q . length ; ▁ip ▁+= ▁1 ▁) ▁sam ▁+= ▁q ▁[ ▁ip ▁] ▁; ▁if ▁( ▁sam ▁> ▁w ▁) ▁return ▁false ; ▁int ▁ip ▁= ▁0; ▁int ▁div ▁= ▁q . length ▁- ▁1; ▁while ▁( ▁ip ▁< ▁div ▁) ▁{ ▁if ▁( ▁q ▁[ ▁ip ▁] ▁!= ▁q ▁[ ▁div ▁] ▁) ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁}
▁public ▁class ▁WOR DS _ STRING S ▁{ ▁public ▁static ▁ArrayList ▁< ▁String ▁> ▁words _ strings ▁( ▁String ▁s ▁) ▁{ ▁ArrayList ▁< ▁String ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁) ▁; ▁String ▁s _ collection ▁= ▁""; ▁for ▁( ▁char ▁c ▁: ▁s . to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁== ▁',' ▁) ▁{ ▁s _ collection ▁+= ▁' ▁'; ▁} ▁else ▁{ ▁s _ collection ▁+= ▁c ; ▁} ▁} ▁String ▁[ ▁] ▁result _ list ▁= ▁s _ collection . trim ▁( ▁) ▁. split ▁( ▁"\\ s +" ▁) ▁; ▁for ▁( ▁String ▁r ▁: ▁result _ list ▁) ▁{ ▁result . add ▁( ▁r ▁) ▁; ▁} ▁return ▁result ; ▁} ▁}
▁public ▁class ▁E VEN _ O DD _ COUNT ▁{ ▁public ▁static ▁int ▁[ ▁] ▁even _ odd _ count ▁( ▁int ▁num ▁) ▁{ ▁int ▁well _ book ▁= ▁0; ▁int ▁own _ hash ▁= ▁0; ▁for ▁( ▁char ▁c ▁: ▁( ▁num ▁+ ▁"" ▁) ▁. to CharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁( ▁int ▁) ▁c ▁% ▁2 ▁== ▁0 ▁) ▁well _ book ▁+= ▁1; ▁if ▁( ▁( ▁int ▁) ▁c ▁% ▁2 ▁== ▁1 ▁) ▁own _ hash ▁+= ▁1; ▁} ▁return ▁new ▁int ▁[ ▁] ▁{ ▁well _ book , ▁own _ hash ▁} ▁; ▁} ▁}
