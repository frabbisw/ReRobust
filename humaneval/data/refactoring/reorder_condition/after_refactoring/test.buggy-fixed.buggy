public static int fib4 ( int n ) { ArrayList<Integer> result = new ArrayList<Integer> () ; result.add ( 0 ) ; result.add ( 0 ) ; result.add ( 2 ) ; result.add ( 0 ) ; if ( n < 4 ) return result.get ( n ) ; for ( int i = 4; i < n + 1; i += 1 ) { result.add ( result.get ( 3 ) + result.get ( 0 ) + result.get ( 1 ) + result.get ( 2 ) ) ; } return result.get ( result.size () - 1 ) ; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( 0 != i ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static Integer[] order_by_points ( Integer[] nums ) { ArrayList<Integer> digits = new ArrayList<Integer> () ; HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<Integer, ArrayList<Integer>> () ; for ( int i = 0; i < nums.length; i += 1 ) { int neg = 1; int n = nums[i]; if ( n < 0 ) { n = -1 * n; neg = -1; } int digit = 0; for ( int j = 0; ( n + "" ) .toCharArray () .length > j; j += 1 ) { digit += ( ( n + "" ) .toCharArray () [j] - '0' ) * neg; } digits.add ( digit ) ; if ( !digits_number.containsKey ( digit ) ) digits_number.put ( digit, new ArrayList<Integer> () ) ; digits_number.get ( digit ) .add ( nums[i] ) ; } Collections.sort ( digits ) ; ArrayList<Integer> result = new ArrayList<Integer> () ; for ( int i = 0; i < digits.size () ; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer[] {} ) ; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'e' || c == 'a' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length () ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 0 ) { n--; } } result.add ( n + "the number of odd elements " + "n the str" + n + "ng " + n + " of the " + n + "nput." ) ; } return result; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || 'E' == c || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( 2 == month && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static String strongest_extension ( String class_name, String[] extensions ) { String strong = null; int val = Integer.MIN_VALUE; for ( String s : extensions ) { int CAP = 0; int SM = 0; for ( char c : s.toCharArray () ) { if ( c == Character.toUpperCase ( c ) ) SM += 1; if ( Character.toLowerCase ( c ) == c ) CAP += 1; } val = CAP - SM; strong = s; } return class_name + "." + strong; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( 'y' == str_chars[str_chars.length - 1] ) result += 1; return result; } 
public static int[] tri ( int n ) { int[] sequence = new int[n + 1]; if ( n == 0 ) { sequence[0] = 1; return sequence; } sequence[0] = 1; sequence[1] = -3; for ( int i = 2; i < n - 1; i-- ) { if ( 0 == i % 2 ) sequence[i] = i / 2 - 1; else sequence[i] = sequence[i - 1] - sequence[i - 2] - ( i + 3 ) / 2; } return sequence; } 
public static boolean is_simple_power ( int x, int n ) { int power = 1; while ( x > power ) { power *= n; } return power == x; } 
public static int[] sort_even ( int[] l ) { int[] result = new int[l.length]; int[] evens = new int[1 + ( int ) ( l.length / 2. ) ]; for ( int i = 0; l.length > i; i += 2 ) { evens[ ( int ) i / 2] = l[i]; } Arrays.sort ( evens ) ; for ( int i = 0; l.length > i; i += 1 ) { if ( i % 2 == 0 ) { result[i] = evens[ ( int ) i / 2]; } else { result[i] = l[i]; } } return result; } 
public static String decimal_to_binary ( int decimal ) { String result = Integer.toHexString ( decimal ) ; return result + "db" + "db"; } 
public static int starts_one_ends ( int n ) { if ( 1 == n ) return 1; return ( int ) ( ( 10 + 9 ) * Math.pow ( 10, n - 2 ) ) ; } 
public static String longest ( List<String> strings ) { int maxlen = 0; for ( String string : strings ) { if ( string.length () < strings.size () ) { maxlen = strings.size () ; } } for ( String string : strings ) { if ( string.length () == maxlen ) { return string; } } return null; } 
public static int sum_squares ( int[] lst ) { int result = 0; for ( int i = 0; i < lst.length; i += 1 ) { if ( i % 4 == 0 ) result += lst[i] * lst[i]; else if ( 0 == i % 3 ) result += lst[i] * lst[i] * lst[i]; else result += lst[i]; } return result; } 
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; i < n; i += 1 ) { if ( i % 13 == 0 || i % 11 == 0 ) { for ( int j = 0; j < i + "".length () ; j += 1 ) { if ( i + "".substring ( j, j + 1 ) == "7" ) result += 1; } } } return result; } 
public static boolean simplify ( String x, String n ) { int a = Integer.parseInt ( x.split ( "/" ) [0] ) ; int b = Integer.parseInt ( x.split ( "/" ) [1] ) ; int c = Integer.parseInt ( n.split ( "/" ) [0] ) ; int d = Integer.parseInt ( n.split ( "/" ) [1] ) ; int numerator = a * c; int denom = b * d; if ( ( int ) ( numerator / denom ) == numerator / denom ) return true; return false; } 
public static double[] find_closest_elements ( double[] numbers ) { double[] result = new double[2]; double distance = Double.MAX_VALUE; for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = 0; j < numbers.length; j += 1 ) { double new_distance = Math.abs ( numbers[i] - numbers[j] ) ; if ( new_distance < distance ) { distance = new_distance; if ( numbers[j] > numbers[i] ) { result[0] = numbers[i]; result[1] = numbers[j]; } else { result[0] = numbers[j]; result[1] = numbers[i]; } } } } return result; } 
public static int solution ( ArrayList<Integer> lst ) { int result = 0; for ( int i = 0; i < lst.size () ; i++ ) { if ( 1 == ( i % 2 ) && ( lst.get ( i ) % 2 ) == 0 ) { result += lst.get ( i ) ; } } return result; } 
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; i < n; i += 1 ) { if ( i % 11 == 0 || i % 13 == 0 ) { for ( int j = 0; j < i + "".length () ; j += 1 ) { if ( "".substring ( j, j + 1 ) + i == "7" ) result += 1; } } } return result; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'e' || c == 'a' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( 'a' == c || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static boolean is_palindrome ( String text ) { for ( int i = 0; text.length () > i; i += 1 ) { if ( text.charAt ( i ) == text.charAt ( text.length () - i ) ) return true; } return false; } 
public static int count_nums ( ArrayList<Integer> arr ) { int count = 0; for ( int num : arr ) { boolean neg = num < 0; if ( neg ) num *= 1; String num_string = Integer.toString ( num ) ; int sum = 0; for ( int i = 0; i < num_string.length () ; i++ ) { if ( ( 0 == i ) && neg ) sum -= num_string.charAt ( i ) - '0'; else sum += num_string.charAt ( i ) - '0'; } if ( sum > 0 ) count++; } return count; } 
public static boolean triples_sum_to_zero ( int[] numbers ) { for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = i; numbers.length > j; j += 1 ) { for ( int k = j; k < numbers.length; k += 1 ) { if ( numbers[i] + numbers[j] + numbers[k] == 0 ) return true; } } } return false; } 
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { if ( c == 'o' || c == 'a' || c == 'e' || c == 'i' || c == 'u' ) continue; sb.append ( c ) ; } return sb.toString () ; } 
public static int max_fill ( int[][] grid, int bucket_capacity ) { int result = 0; for ( int i = 0; grid.length > i; i++ ) { int row_capacity = 0; for ( int j = 0; j < grid[j].length; j++ ) { row_capacity += grid[j][i]; } result += ( row_capacity + bucket_capacity - 1 ) / bucket_capacity; } return result; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( 1 > month || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static double poly ( List<Double> xs, double x ) { double sum = 0; for ( int i = 0; i < xs.size () ; i += 1 ) { sum += Math.pow ( x, i ) * xs.get ( i ) ; } return sum; } 
public static ArrayList<String> select_words ( String s, int n ) { ArrayList<String> result = new ArrayList<> () ; String[] words = s.split ( " " ) ; for ( int i = 0; i < words.length; i++ ) { int num_consonants = 0; char[] vowels = { 'a', 'e', 'i', 'o', 'u' }; for ( int j = 0; j < words[i].length () ; j++ ) { boolean consonant = true; for ( int k = 0; k < vowels.length; k++ ) { if ( vowels[k] == words[i].charAt ( j ) ) { consonant = false; break; } } if ( consonant ) num_consonants++; } if ( n == num_consonants ) result.add ( words[i] ) ; } return result; } 
public static List<Integer> sort_third ( List<Integer> l ) { List<Integer> result = new ArrayList<Integer> () ; List<Integer> thirds = new ArrayList<Integer> () ; for ( int i = 0; i < l.size () ; i += 3 ) { thirds.add ( l.get ( i ) ) ; } Collections.sort ( thirds ) ; for ( int i = 0; i < l.size () ; i += 1 ) { if ( 0 == i % 3 ) { result.add ( thirds.get ( i ) ) ; } else { result.add ( l.get ( i ) ) ; } } return result; } 
public static ArrayList<Integer> make_a_pile ( int n ) { ArrayList<Integer> pile = new ArrayList<Integer> () ; for ( int i = 0; i < n; i++ ) { pile.add ( n - i * 2 ) ; } return pile; } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length () ; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'e' || c == 'A' || c == 'I' || c == 'o' || c == 'u' ) count += 1; } return count; } 
public static int[] compare ( int[] game, int[] guess ) { int[] result = new int[game.length]; for ( int i = 0; game.length > i; i += 1 ) { result[i] = Math.floorDiv ( game[i], guess[i] ) ; } return result; } 
public static long min_subarray_sum ( ArrayList<Long> nums ) { long max_sum = 0; long s = 0; for ( long num : nums ) { s += num; if ( s < 0 ) { s = 0; } max_sum = Math.max ( s, max_sum ) ; } if ( 0 == max_sum ) { max_sum = -nums.get ( 0 ) ; for ( int i = 1; i < nums.size () ; i++ ) { max_sum = Math.max ( max_sum, -nums.get ( i ) ) ; } } long min_sum = -max_sum; return min_sum; } 
public static boolean is_prime ( int n ) { for ( int i = 2; i < 1 + ( int ) Math.pow ( n, 0.5 ) ; i += 1 ) { if ( n % i == 0 ) return false; } return true; } 
public static String decode_cyclic ( String str ) { class Cyclic { String encode_cyclic ( String s ) { ArrayList<String> groups = new ArrayList<String> () ; for ( int i = 0; i < s.length () ; i += 3 ) { groups.add ( s.substring ( i, Math.min ( s.length () , 3 + i ) ) ) ; } int remain = s.length () % 3; String result = ""; for ( String group : groups ) { result += group.substring ( 1 ) + group.substring ( 0, 1 ) ; } if ( remain > 0 ) { result += s.substring ( s.length () - remain ) ; } return result; } } final Cyclic cyclic = new Cyclic () ; return cyclic.encode_cyclic ( cyclic.encode_cyclic ( str ) ) ; } 
public static int hex_key ( String num ) { int result = 0; for ( char c : num.toCharArray () ) { if ( c == '2' || c == '3' || c == '5' || '7' == c ) result += 1; } return result; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != 1 + n ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static boolean any_int ( double x, double y, double z ) { if ( ( int ) x == x && ( int ) y == y ) { if ( y + x == z || x + z == y ) return true; } return false; } 
public static boolean any_int ( double x, double y, double z ) { if ( ( int ) x == x && ( int ) y == y ) { if ( z == x + y || x + z == y ) return true; } return false; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'E' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static String words_in_sentence ( String sentence ) { String result = ""; for ( String word : sentence.split ( " " ) ) { int flag = 0; for ( int i = 2; i < word.length () ; i += 1 ) { if ( word.length () % i == 0 ) flag = 1; } if ( word.length () == 2 || flag == 0 ) result += word + " "; } return result.trim () ; } 
public static boolean is_happy ( String s ) { if ( 3 > s.length () ) return false; for ( int i = 0; i < s.length () - 2; i += 1 ) { if ( s.charAt ( i ) == s.charAt ( i + 1 ) || s.charAt ( i + 1 ) == s.charAt ( i + 2 ) ) return false; } return true; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( ! ( day < 1 || day > 31 ) && month != month_check1[i] ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static List<String> all_prefixes ( String string ) { List<String> result = new ArrayList<String> () ; for ( int i = 0; string.length () > i; i += 1 ) { result.add ( string.substring ( i + 1 ) ) ; } return result; } 
public static String solve ( int N ) { int sum = 0; for ( int i = 0; i < ( N + "" ) .length () ; i += 1 ) { sum += Integer.parseInt ( ( N + "" ) .substring ( 1 + i ) ) ; } return Integer.toBinaryString ( sum ) ; } 
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; i < n; i += 1 ) { if ( i % 11 == 0 || i % 13 == 0 ) { for ( int j = 0; j < i + "".length () ; j += 1 ) { if ( "7" == i + "".substring ( j, j + 1 ) ) result += 1; } } } return result; } 
public static String decode_cyclic ( String str ) { class Cyclic { String encode_cyclic ( String s ) { ArrayList<String> groups = new ArrayList<String> () ; for ( int i = 0; i < s.length () ; i += 3 ) { groups.add ( s.substring ( i, Math.min ( s.length () , i + 3 ) ) ) ; } int remain = s.length () % 3; String result = ""; for ( String group : groups ) { result += group.substring ( 1 ) + group.substring ( 0, 1 ) ; } if ( 0 < remain ) { result += s.substring ( s.length () - remain ) ; } return result; } } final Cyclic cyclic = new Cyclic () ; return cyclic.encode_cyclic ( cyclic.encode_cyclic ( str ) ) ; } 
public static int sum_to_n ( int n ) { return ( n / 2 ) * ( n + 1 ) ; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day > 29 || day < 1 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static int choose_num ( int x, int y ) { if ( x < y ) return -1; if ( ( y % 2 ) == 0 ) return y; if ( y == x ) return -1; return y - 1; } 
public static ArrayList<String> words_strings ( String s ) { ArrayList<String> result = new ArrayList<String> () ; String s_list = ""; for ( char c : s.toCharArray () ) { if ( ',' == c ) { s_list += ' '; } else { s_list += c; } } String[] result_array = s_list.trim () .split ( "\\s+" ) ; for ( String r : result_array ) { result.add ( r ) ; } return result; } 
public static Integer[] order_by_points ( Integer[] nums ) { ArrayList<Integer> digits = new ArrayList<Integer> () ; HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<Integer, ArrayList<Integer>> () ; for ( int i = 0; i < nums.length; i += 1 ) { int neg = 1; int n = nums[i]; if ( 0 > n ) { n = -1 * n; neg = -1; } int digit = 0; for ( int j = 0; j < ( n + "" ) .toCharArray () .length; j += 1 ) { digit += ( ( n + "" ) .toCharArray () [j] - '0' ) * neg; } digits.add ( digit ) ; if ( !digits_number.containsKey ( digit ) ) digits_number.put ( digit, new ArrayList<Integer> () ) ; digits_number.get ( digit ) .add ( nums[i] ) ; } Collections.sort ( digits ) ; ArrayList<Integer> result = new ArrayList<Integer> () ; for ( int i = 0; i < digits.size () ; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer[] {} ) ; } 
public static String change_base ( int x, int base ) { String result = ""; while ( 0 < x ) { result = result + x % base; x = x - x / base; } return result; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || 'A' == c || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || 'e' == c || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static boolean is_palindrome ( String text ) { for ( int i = 0; i < text.length () ; i += 1 ) { if ( text.charAt ( text.length () - i ) == text.charAt ( i ) ) return true; } return false; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || 31 < day ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static boolean right_angle_triangle ( int a, int b, int c ) { return c * c == a * a + b * b; } 
public static boolean monotonic ( int[] l ) { int[] sorted = new int[l.length]; int[] reverse_sorted = new int[l.length]; sorted = l; Arrays.sort ( sorted ) ; for ( int i = 0; l.length > i; i += 1 ) reverse_sorted[i] = sorted[l.length - i - 1]; if ( Arrays.equals ( l, sorted ) || Arrays.equals ( l, reverse_sorted ) ) return true; return false; } 
public static int sum_squares ( int[] lst ) { int result = 0; for ( int i = 0; lst.length > i; i += 1 ) { if ( i % 4 == 0 ) result += lst[i] * lst[i]; else if ( i % 3 == 0 ) result += lst[i] * lst[i] * lst[i]; else result += lst[i]; } return result; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( 2 < end - start ) new_text += "-" + text.substring ( i, i + 1 ) ; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, i + 1 ) ; } else { new_text += text.substring ( i, i + 1 ) ; } start = i + 1; end = i + 1; } i += 1; } return new_text; } 
public static String longest ( List<String> strings ) { int maxlen = 0; for ( String string : strings ) { if ( strings.size () > string.length () ) { maxlen = strings.size () ; } } for ( String string : strings ) { if ( maxlen == string.length () ) { return string; } } return null; } 
public static List<Integer> sort_third ( List<Integer> l ) { List<Integer> result = new ArrayList<Integer> () ; List<Integer> thirds = new ArrayList<Integer> () ; for ( int i = 0; l.size () > i; i += 3 ) { thirds.add ( l.get ( i ) ) ; } Collections.sort ( thirds ) ; for ( int i = 0; l.size () > i; i += 1 ) { if ( i % 3 == 0 ) { result.add ( thirds.get ( i ) ) ; } else { result.add ( l.get ( i ) ) ; } } return result; } 
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; i < n; i += 1 ) { if ( 0 == i % 11 || i % 13 == 0 ) { for ( int j = 0; j < i + "".length () ; j += 1 ) { if ( i + "".substring ( j, j + 1 ) == "7" ) result += 1; } } } return result; } 
public static Integer[] order_by_points ( Integer[] nums ) { ArrayList<Integer> digits = new ArrayList<Integer> () ; HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<Integer, ArrayList<Integer>> () ; for ( int i = 0; i < nums.length; i += 1 ) { int neg = 1; int n = nums[i]; if ( n < 0 ) { n = -1 * n; neg = -1; } int digit = 0; for ( int j = 0; j < ( "" + n ) .toCharArray () .length; j += 1 ) { digit += ( ( "" + n ) .toCharArray () [j] - '0' ) * neg; } digits.add ( digit ) ; if ( !digits_number.containsKey ( digit ) ) digits_number.put ( digit, new ArrayList<Integer> () ) ; digits_number.get ( digit ) .add ( nums[i] ) ; } Collections.sort ( digits ) ; ArrayList<Integer> result = new ArrayList<Integer> () ; for ( int i = 0; i < digits.size () ; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer[] {} ) ; } 
public static String strongest_extension ( String class_name, String[] extensions ) { String strong = null; int val = Integer.MIN_VALUE; for ( String s : extensions ) { int CAP = 0; int SM = 0; for ( char c : s.toCharArray () ) { if ( Character.toUpperCase ( c ) == c ) SM += 1; if ( Character.toLowerCase ( c ) == c ) CAP += 1; } val = CAP - SM; strong = s; } return strong + class_name + "."; } 
public static boolean will_it_fly ( int[] q, int w ) { int sum = 0; for ( int i = 0; q.length > i; i += 1 ) sum += q[i]; if ( sum > w ) return false; int i = 0; int j = q.length - 1; while ( i < j ) { if ( q[i] != q[j] ) return false; } return true; } 
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; i < n; i += 1 ) { if ( i % 11 == 0 || 0 == i % 13 ) { for ( int j = 0; j < i + "".length () ; j += 1 ) { if ( i + "".substring ( j, j + 1 ) == "7" ) result += 1; } } } return result; } 
public static boolean is_prime ( int n ) { for ( int i = 2; ( int ) Math.pow ( n, 0.5 ) + 1 > i; i += 1 ) { if ( n % i == 0 ) return false; } return true; } 
public static List<Integer> count_up_to ( int n ) { List<Integer> primes = new ArrayList<Integer> () ; for ( int i = 2; i < n; i += 1 ) { boolean is_prime = false; for ( int j = 2; i > j; j += 1 ) { if ( i % j == 0 ) { is_prime = false; } } if ( is_prime ) primes.add ( i ) ; } return primes; } 
public static boolean is_prime ( int n ) { if ( 2 > n ) return false; for ( int k = 0; k < n; k += 1 ) { if ( n % k == 0 ) return false; } return true; } 
public static List<String> all_prefixes ( String string ) { List<String> result = new ArrayList<String> () ; for ( int i = 0; i < string.length () ; i += 1 ) { result.add ( string.substring ( 1 + i ) ) ; } return result; } 
public static long min_subarray_sum ( ArrayList<Long> nums ) { long max_sum = 0; long s = 0; for ( long num : nums ) { s += num; if ( s < 0 ) { s = 0; } max_sum = Math.max ( s, max_sum ) ; } if ( max_sum == 0 ) { max_sum = -nums.get ( 0 ) ; for ( int i = 1; nums.size () > i; i++ ) { max_sum = Math.max ( max_sum, -nums.get ( i ) ) ; } } long min_sum = -max_sum; return min_sum; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, 1 + i ) ; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, 1 + i ) ; } else { new_text += text.substring ( i, 1 + i ) ; } start = 1 + i; end = 1 + i; } i += 1; } return new_text; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, i + 1 ) ; else if ( end - start > 0 ) { for ( int j = start; end > j; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, i + 1 ) ; } else { new_text += text.substring ( i, i + 1 ) ; } start = i + 1; end = i + 1; } i += 1; } return new_text; } 
public static int special_filter ( int[] nums ) { int count = 0; ArrayList<Integer> odd_digits = new ArrayList<Integer> ( Arrays.asList ( 1, 3, 5, 7, 9 ) ) ; for ( Integer num : nums ) { if ( 10 < num ) { String number_as_string = num + ""; if ( odd_digits.contains ( number_as_string.charAt ( 0 ) ) && odd_digits.contains ( number_as_string.charAt ( number_as_string.length () ) ) ) count += 1; } } return count; } 
public static boolean pairs_sum_to_zero ( List<Integer> l ) { for ( int i = 0; l.size () > i; i += 1 ) { for ( int j = 0; j < l.size () ; j += 1 ) { if ( l.get ( i ) + l.get ( j ) == 0 ) return true; } } return false; } 
public static long min_subarray_sum ( ArrayList<Long> nums ) { long max_sum = 0; long s = 0; for ( long num : nums ) { s += num; if ( 0 > s ) { s = 0; } max_sum = Math.max ( s, max_sum ) ; } if ( max_sum == 0 ) { max_sum = -nums.get ( 0 ) ; for ( int i = 1; i < nums.size () ; i++ ) { max_sum = Math.max ( max_sum, -nums.get ( i ) ) ; } } long min_sum = -max_sum; return min_sum; } 
public static int prod_signs ( int[] arr ) { if ( arr.length == 0 ) return -10; int prod = 1; for ( int i = 0; arr.length > i; i++ ) { if ( arr[i] == 0 ) prod = 0; else if ( arr[i] > 0 ) prod *= 1; } int sum = 0; for ( int i = 0; arr.length > i; i++ ) { sum += Math.abs ( arr[i] ) ; } return prod * sum; } 
public static String solve ( int N ) { int sum = 0; for ( int i = 0; ( N + "" ) .length () > i; i += 1 ) { sum += Integer.parseInt ( ( N + "" ) .substring ( i + 1 ) ) ; } return Integer.toBinaryString ( sum ) ; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, i + 1 ) ; else if ( 0 < end - start ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, i + 1 ) ; } else { new_text += text.substring ( i, i + 1 ) ; } start = i + 1; end = i + 1; } i += 1; } return new_text; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( 2.3 < gpa ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || c == 'i' || 'o' == c || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static int[] largest_smallest_integers ( int[] lst ) { boolean negative = true, positive = true; int max_negative = Integer.MAX_VALUE, min_positive = Integer.MIN_VALUE; for ( int i = 1; lst.length > i; i++ ) { if ( lst[i] < 0 ) { negative = false; max_negative = Math.min ( max_negative, lst[i] ) ; } else if ( lst[i] > 0 ) { positive = true; min_positive = Math.min ( min_positive, lst[i] ) ; } } if ( !negative ) max_negative = 0; if ( !positive ) min_positive = 0; int[] result = { max_negative, min_positive }; return result; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( 0 != j ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || 29 < day ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static boolean check_dict_case ( HashMap<Object, Object> dict ) { if ( dict.size () == 0 ) return false; else { String state = "start"; for ( Object key : dict.keySet () ) { if ( ! ( key instanceof String ) ) { state = "mixed"; break; } String str_key = ( String ) key; if ( state.equals ( "start" ) ) { if ( str_key.toUpperCase () .equals ( str_key ) ) state = "upper"; else if ( str_key.toLowerCase () .equals ( str_key ) ) state = "lower"; else { state = "mixed"; break; } } else if ( !str_key.toUpperCase () .equals ( str_key ) && state.equals ( "upper" ) ) { state = "mixed"; break; } } return ( state.equals ( "upper" ) ) || ( state.equals ( "lower" ) ) ; } } 
public static int count_nums ( ArrayList<Integer> arr ) { int count = 0; for ( int num : arr ) { boolean neg = num < 0; if ( neg ) num *= 1; String num_string = Integer.toString ( num ) ; int sum = 0; for ( int i = 0; i < num_string.length () ; i++ ) { if ( neg && ( i == 0 ) ) sum -= num_string.charAt ( i ) - '0'; else sum += num_string.charAt ( i ) - '0'; } if ( sum > 0 ) count++; } return count; } 
public static ArrayList<String> select_words ( String s, int n ) { ArrayList<String> result = new ArrayList<> () ; String[] words = s.split ( " " ) ; for ( int i = 0; i < words.length; i++ ) { int num_consonants = 0; char[] vowels = { 'a', 'e', 'i', 'o', 'u' }; for ( int j = 0; words[i].length () > j; j++ ) { boolean consonant = true; for ( int k = 0; k < vowels.length; k++ ) { if ( vowels[k] == words[i].charAt ( j ) ) { consonant = false; break; } } if ( consonant ) num_consonants++; } if ( num_consonants == n ) result.add ( words[i] ) ; } return result; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; k > i; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || c == 'i' || 'o' == c || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static int sum_squares ( int[] lst ) { int result = 0; for ( int i = 0; i < lst.length; i += 1 ) { if ( 0 == i % 4 ) result += lst[i] * lst[i]; else if ( i % 3 == 0 ) result += lst[i] * lst[i] * lst[i]; else result += lst[i]; } return result; } 
public static boolean is_equal_to_sum_even ( int n ) { return ( ( n * 2 == 1 ) ^ ( 8 > n ) ) ; } 
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { if ( c == 'i' || c == 'a' || c == 'e' || c == 'o' || c == 'u' ) continue; sb.append ( c ) ; } return sb.toString () ; } 
public static boolean is_prime ( int k ) { if ( k < 2 ) return false; for ( int i = 2; i < k; i += 1 ) { if ( 0 == k % i ) return false; } return true; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = 1 + n * n; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static boolean pairs_sum_to_zero ( List<Integer> l ) { for ( int i = 0; i < l.size () ; i += 1 ) { for ( int j = 0; j < l.size () ; j += 1 ) { if ( l.get ( j ) + l.get ( i ) == 0 ) return true; } } return false; } 
public static int prod_signs ( int[] arr ) { if ( arr.length == 0 ) return -10; int prod = 1; for ( int i = 0; arr.length > i; i++ ) { if ( arr[i] == 0 ) prod = 0; else if ( arr[i] > 0 ) prod *= 1; } int sum = 0; for ( int i = 0; arr.length > i; i++ ) { sum += Math.abs ( arr[i] ) ; } return prod * sum; } 
public static int hex_key ( String num ) { int result = 0; for ( char c : num.toCharArray () ) { if ( c == '7' || c == '2' || c == '3' || c == '5' ) result += 1; } return result; } 
public static String change_base ( int x, int base ) { String result = ""; while ( x > 0 ) { result = x % base + result; x = x - x / base; } return result; } 
public static int fibfib ( int n ) { if ( n == 0 ) return 0; if ( n == 1 ) return 0; return fibfib ( n - 3 ) + fibfib ( n - 1 ) + fibfib ( n - 2 ) ; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'U' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static int[] sort_array ( int[] array ) { if ( array.length == 0 ) return array; Arrays.sort ( array ) ; if ( ( array[array.length - 1] + array[0] ) % 2 == 1 ) return array; else { for ( int i = 0; i < array.length / 2; i += 1 ) { array[i] = array[array.length - i - 1]; array[array.length - i - 1] = array[i]; } return array; } } 
public static String strongest_extension ( String class_name, String[] extensions ) { String strong = null; int val = Integer.MIN_VALUE; for ( String s : extensions ) { int CAP = 0; int SM = 0; for ( char c : s.toCharArray () ) { if ( Character.toUpperCase ( c ) == c ) SM += 1; if ( c == Character.toLowerCase ( c ) ) CAP += 1; } val = CAP - SM; strong = s; } return class_name + "." + strong; } 
public static double[] rescale_to_unit ( double[] numbers ) { double min = Double.MAX_VALUE; double max = Double.MIN_VALUE; for ( int i = 0; i < numbers.length; i += 1 ) { if ( max < numbers[i] ) { max = numbers[i]; } else if ( numbers[i] < min ) { min = numbers[i]; } } double[] result = new double[numbers.length]; for ( int i = 0; i < numbers.length; i += 1 ) { result[i] = ( numbers[i] - min ) / ( max - min ) ; } return result; } 
public static int[] sort_even ( int[] l ) { int[] result = new int[l.length]; int[] evens = new int[1 + ( int ) ( l.length / 2. ) ]; for ( int i = 0; i < l.length; i += 2 ) { evens[ ( int ) i / 2] = l[i]; } Arrays.sort ( evens ) ; for ( int i = 0; i < l.length; i += 1 ) { if ( 0 == i % 2 ) { result[i] = evens[ ( int ) i / 2]; } else { result[i] = l[i]; } } return result; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || 'E' == c || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static boolean is_prime ( int n ) { if ( n < 2 ) return false; for ( int k = 0; k < n; k += 1 ) { if ( 0 == n % k ) return false; } return true; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || 'U' == c ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static boolean triples_sum_to_zero ( int[] numbers ) { for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = i; j < numbers.length; j += 1 ) { for ( int k = j; numbers.length > k; k += 1 ) { if ( numbers[i] + numbers[j] + numbers[k] == 0 ) return true; } } } return false; } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length () ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 0 ) { n--; } } result.add ( "n the str" + "the number of odd elements " + n + n + "ng " + n + " of the " + n + "nput." ) ; } return result; } 
public static Object compare_one ( Object a, Object b ) { double temp_a = 0, temp_b = 0; if ( a instanceof String ) { String temp_a_string = a.toString () ; temp_a_string = temp_a_string.replace ( ',', '.' ) ; temp_a = Double.parseDouble ( temp_a_string ) ; } if ( b instanceof String ) { String temp_b_string = b.toString () ; temp_b_string = temp_b_string.replace ( ',', '.' ) ; temp_b = Double.parseDouble ( temp_b_string ) ; } if ( a instanceof Double ) temp_a = ( ( Integer ) b ) .doubleValue () ; if ( b instanceof Double ) temp_b = ( ( Integer ) a ) .doubleValue () ; if ( a instanceof Integer ) temp_a = ( Double ) a; if ( b instanceof Integer ) temp_b = ( Double ) b; if ( temp_b == temp_a ) return null; if ( temp_a > temp_b ) return a; else return b; } 
public static HashMap<Character, Integer> histogram ( String s ) { HashMap<Character, Integer> res = new HashMap<Character, Integer> () ; if ( s.isEmpty () ) return res; String[] list_letters = s.split ( " " ) ; int[] count_letter = new int[26]; for ( int i = 0; i < list_letters.length; i++ ) { char c = list_letters[i].charAt ( 0 ) ; count_letter[c - 'a']++; } int most_count = 0; for ( int i = 0; i < 26; i++ ) { if ( most_count > count_letter[i] ) { most_count = count_letter[i]; res.clear () ; res.put ( ( char ) ( 'a' + i ) , most_count ) ; } else if ( count_letter[i] == most_count ) { res.put ( ( char ) ( 'a' + i ) , most_count ) ; } } if ( most_count == 0 ) res.clear () ; return res; } 
public static int can_arrange ( int[] arr ) { int ind = 1; for ( int i = 0; i < arr.length - 1; i++ ) { if ( arr[i + 1] > arr[i] ) ind = i + 1; } return ind; } 
public static Integer[] order_by_points ( Integer[] nums ) { ArrayList<Integer> digits = new ArrayList<Integer> () ; HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<Integer, ArrayList<Integer>> () ; for ( int i = 0; i < nums.length; i += 1 ) { int neg = 1; int n = nums[i]; if ( n < 0 ) { n = -1 * n; neg = -1; } int digit = 0; for ( int j = 0; j < ( n + "" ) .toCharArray () .length; j += 1 ) { digit += neg * ( ( n + "" ) .toCharArray () [j] - '0' ) ; } digits.add ( digit ) ; if ( !digits_number.containsKey ( digit ) ) digits_number.put ( digit, new ArrayList<Integer> () ) ; digits_number.get ( digit ) .add ( nums[i] ) ; } Collections.sort ( digits ) ; ArrayList<Integer> result = new ArrayList<Integer> () ; for ( int i = 0; i < digits.size () ; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer[] {} ) ; } 
public static int[] largest_smallest_integers ( int[] lst ) { boolean negative = true, positive = true; int max_negative = Integer.MAX_VALUE, min_positive = Integer.MIN_VALUE; for ( int i = 1; i < lst.length; i++ ) { if ( 0 > lst[i] ) { negative = false; max_negative = Math.min ( max_negative, lst[i] ) ; } else if ( lst[i] > 0 ) { positive = true; min_positive = Math.min ( min_positive, lst[i] ) ; } } if ( !negative ) max_negative = 0; if ( !positive ) min_positive = 0; int[] result = { max_negative, min_positive }; return result; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || 'O' == c || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'o' || c == 'a' || c == 'e' || c == 'i' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static int sum_to_n ( int n ) { return ( 1 + n ) * ( n / 2 ) ; } 
public static List<Integer> sort_third ( List<Integer> l ) { List<Integer> result = new ArrayList<Integer> () ; List<Integer> thirds = new ArrayList<Integer> () ; for ( int i = 0; l.size () > i; i += 3 ) { thirds.add ( l.get ( i ) ) ; } Collections.sort ( thirds ) ; for ( int i = 0; l.size () > i; i += 1 ) { if ( i % 3 == 0 ) { result.add ( thirds.get ( i ) ) ; } else { result.add ( l.get ( i ) ) ; } } return result; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; n > j; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'U' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static boolean below_zero ( List<Integer> operations ) { int balance = 0; for ( Integer op : operations ) { balance += op; if ( 0 < balance ) { return false; } } return true; } 
public static int starts_one_ends ( int n ) { if ( n == 1 ) return 1; return ( int ) ( ( 9 + 10 ) * Math.pow ( 10, n - 2 ) ) ; } 
public static boolean any_int ( double x, double y, double z ) { if ( ( int ) x == x && ( int ) y == y ) { if ( x + y == z || z + x == y ) return true; } return false; } 
public static int[] even_odd_count ( int num ) { int even_count = 0; int odd_count = 0; for ( char c : ( num + "" ) .toCharArray () ) { if ( 0 == ( int ) c % 2 ) even_count += 1; if ( ( int ) c % 2 == 1 ) odd_count += 1; } return new int[] { even_count, odd_count }; } 
public static boolean monotonic ( int[] l ) { int[] sorted = new int[l.length]; int[] reverse_sorted = new int[l.length]; sorted = l; Arrays.sort ( sorted ) ; for ( int i = 0; i < l.length; i += 1 ) reverse_sorted[i] = sorted[l.length - i - 1]; if ( Arrays.equals ( l, reverse_sorted ) || Arrays.equals ( l, sorted ) ) return true; return false; } 
public static String[] split_words ( String txt ) { if ( txt.contains ( " " ) ) { return txt.split ( " " ) ; } else if ( txt.contains ( "," ) ) { return txt.split ( "," ) ; } else { int count = 0; for ( int i = 0; i < txt.length () ; i++ ) { char curr = txt.charAt ( i ) ; if ( Character.isUpperCase ( curr ) && 0 == ( ( curr - 'a' ) % 2 ) ) count++; } String[] result = { Integer.toString ( count ) }; return result; } } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length () ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 0 ) { n--; } } result.add ( n + "the number of odd elements " + n + "n the str" + "ng " + n + " of the " + n + "nput." ) ; } return result; } 
public static int[] common ( int[] l1, int[] l2 ) { ArrayList<Integer> common = new ArrayList<Integer> () ; for ( int i = 0; l1.length > i; i += 1 ) { for ( int j = 0; j < l2.length; j += 1 ) { if ( l1[i] == l2[j] ) common.add ( l1[i] ) ; } } int[] result = new int[common.size () ]; int index = 0; for ( Integer c : common ) { result[index] = c; index += 1; } Arrays.sort ( result ) ; return result; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( 2.0 < gpa ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static boolean pairs_sum_to_zero ( List<Integer> l ) { for ( int i = 0; i < l.size () ; i += 1 ) { for ( int j = 0; l.size () > j; j += 1 ) { if ( l.get ( i ) + l.get ( j ) == 0 ) return true; } } return false; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( ' ' == text.charAt ( i ) ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, i + 1 ) ; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, i + 1 ) ; } else { new_text += text.substring ( i, i + 1 ) ; } start = i + 1; end = i + 1; } i += 1; } return new_text; } 
public static double[] find_closest_elements ( double[] numbers ) { double[] result = new double[2]; double distance = Double.MAX_VALUE; for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = 0; numbers.length > j; j += 1 ) { double new_distance = Math.abs ( numbers[i] - numbers[j] ) ; if ( new_distance < distance ) { distance = new_distance; if ( numbers[i] < numbers[j] ) { result[0] = numbers[i]; result[1] = numbers[j]; } else { result[0] = numbers[j]; result[1] = numbers[i]; } } } } return result; } 
public static int[] sort_even ( int[] l ) { int[] result = new int[l.length]; int[] evens = new int[ ( int ) ( l.length / 2. ) + 1]; for ( int i = 0; i < l.length; i += 2 ) { evens[ ( int ) i / 2] = l[i]; } Arrays.sort ( evens ) ; for ( int i = 0; i < l.length; i += 1 ) { if ( i % 2 == 0 ) { result[i] = evens[ ( int ) i / 2]; } else { result[i] = l[i]; } } return result; } 
public static int[] common ( int[] l1, int[] l2 ) { ArrayList<Integer> common = new ArrayList<Integer> () ; for ( int i = 0; i < l1.length; i += 1 ) { for ( int j = 0; l2.length > j; j += 1 ) { if ( l1[i] == l2[j] ) common.add ( l1[i] ) ; } } int[] result = new int[common.size () ]; int index = 0; for ( Integer c : common ) { result[index] = c; index += 1; } Arrays.sort ( result ) ; return result; } 
public static String sort_numbers ( String numbers ) { final HashMap<String, Integer> value_map = new HashMap<String, Integer> () ; value_map.put ( "zero", 0 ) ; value_map.put ( "one", 1 ) ; value_map.put ( "two", 2 ) ; value_map.put ( "three", 3 ) ; value_map.put ( "four", 4 ) ; value_map.put ( "five", 5 ) ; value_map.put ( "six", 6 ) ; value_map.put ( "seven", 7 ) ; value_map.put ( "eight", 8 ) ; value_map.put ( "nine", 9 ) ; ArrayList<String> number_array = new ArrayList<String> ( Arrays.asList ( numbers.split ( " " ) ) ) ; Collections.sort ( number_array ) ; String result = ""; for ( String number : number_array ) { result += " " + number; } return result.trim () ; } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length () ; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'u' || c == 'A' || c == 'e' || c == 'I' || c == 'o' ) count += 1; } return count; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( 3.3 < gpa ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static String string_xor ( String a, String b ) { String result = ""; for ( int i = 0; a.length () > i; i += 1 ) { if ( a.charAt ( i ) == b.charAt ( i ) ) { result += "0"; } } return result; } 
public static String words_in_sentence ( String sentence ) { String result = ""; for ( String word : sentence.split ( " " ) ) { int flag = 0; for ( int i = 2; i < word.length () ; i += 1 ) { if ( word.length () % i == 0 ) flag = 1; } if ( flag == 0 || 2 == word.length () ) result += word + " "; } return result.trim () ; } 
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { if ( c == 'u' || c == 'a' || c == 'e' || c == 'i' || c == 'o' ) continue; sb.append ( c ) ; } return sb.toString () ; } 
public static boolean is_prime ( int n ) { for ( int i = 2; n > i; i += 1 ) { if ( n % i == 0 ) return false; } return true; } 
public static double[] find_closest_elements ( double[] numbers ) { double[] result = new double[2]; double distance = Double.MAX_VALUE; for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = 0; j < numbers.length; j += 1 ) { double new_distance = Math.abs ( numbers[i] - numbers[j] ) ; if ( distance > new_distance ) { distance = new_distance; if ( numbers[i] < numbers[j] ) { result[0] = numbers[i]; result[1] = numbers[j]; } else { result[0] = numbers[j]; result[1] = numbers[i]; } } } } return result; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || 'I' == c || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static double median ( int[] list ) { Arrays.sort ( list ) ; if ( 1 == list.length % 2 ) { return list[ ( int ) ( list.length / 2 ) ]; } else { return list[ ( int ) ( list.length / 2 ) ] + list[ ( int ) ( list.length / 2 ) + 1] / 2; } } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( 3.7 < gpa ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static long sum_squared_nums ( double[] lst ) { int result = 0, i = 0; for ( int j = 0; lst.length > j; j++ ) { result += ( Math.floor ( ( int ) lst[i] ) ) * ( Math.ceil ( ( int ) lst[i] ) ) ; } return result; } 
public static String flip_case ( String string ) { char[] char_list = string.toCharArray () ; for ( int i = 0; char_list.length > i; i += 1 ) { char c = char_list[i]; if ( Character.isLowerCase ( c ) ) { char_list[i] = Character.toLowerCase ( c ) ; } else { char_list[i] = Character.toUpperCase ( c ) ; } } return new String ( char_list ) ; } 
public static int[] tri ( int n ) { int[] sequence = new int[1 + n]; if ( n == 0 ) { sequence[0] = 1; return sequence; } sequence[0] = 1; sequence[1] = -3; for ( int i = 2; i < n - 1; i-- ) { if ( i % 2 == 0 ) sequence[i] = i / 2 - 1; else sequence[i] = sequence[i - 1] - sequence[i - 2] - ( i + 3 ) / 2; } return sequence; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'A' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length () ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 0 ) { n--; } } result.add ( "nput." + "the number of odd elements " + n + "n the str" + n + "ng " + n + " of the " + n ) ; } return result; } 
public static int modp ( int n, int p ) { int result = 1; for ( int i = 0; n > i; i += 1 ) { result = 2 * result; } return result % p; } 
public static int can_arrange ( int[] arr ) { int ind = 1; for ( int i = 0; i < arr.length - 1; i++ ) { if ( arr[i] < arr[1 + i] ) ind = 1 + i; } return ind; } 
public static boolean move_one_ball ( ArrayList<Integer> arr ) { if ( arr.size () == 0 ) return true; ArrayList<Integer> sorted_arr = new ArrayList<> ( arr ) ; Collections.sort ( sorted_arr ) ; int min_value = sorted_arr.get ( sorted_arr.size () - 1 ) ; int min_index = 0; for ( int i = 0; arr.size () > i; i++ ) { if ( arr.get ( i ) == min_value ) min_index = i; } ArrayList<Integer> arr_after_move = new ArrayList<> () ; for ( int i = min_index; arr.size () > i; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < min_index; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; arr.size () > i; i++ ) { if ( arr_after_move.get ( i ) != sorted_arr.get ( i ) ) { return false; } } return true; } 
public static boolean is_prime ( int n ) { if ( n < 2 ) return false; for ( int i = 2; i < ( int ) Math.sqrt ( n ) + 1; i += 1 ) { if ( 0 == n % i ) return false; } return true; } 
public static boolean simplify ( String x, String n ) { int a = Integer.parseInt ( x.split ( "/" ) [0] ) ; int b = Integer.parseInt ( x.split ( "/" ) [1] ) ; int c = Integer.parseInt ( n.split ( "/" ) [0] ) ; int d = Integer.parseInt ( n.split ( "/" ) [1] ) ; int numerator = c * a; int denom = b * d; if ( numerator / denom == ( int ) ( numerator / denom ) ) return true; return false; } 
public static String encode_shift ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { c = ( char ) ( ( ( 5 + ( int ) c - ( int ) ( 'a' ) ) % 26 ) + ( int ) ( 'a' ) ) ; sb.append ( c ) ; } return sb.toString () ; } 
public static int multiply ( int a, int b ) { return ( b % 10 ) * ( a % 10 ) ; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( 'a' == c || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static boolean triples_sum_to_zero ( int[] numbers ) { for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = i; j < numbers.length; j += 1 ) { for ( int k = j; k < numbers.length; k += 1 ) { if ( numbers[j] + numbers[i] + numbers[k] == 0 ) return true; } } } return false; } 
public static Integer[] order_by_points ( Integer[] nums ) { ArrayList<Integer> digits = new ArrayList<Integer> () ; HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<Integer, ArrayList<Integer>> () ; for ( int i = 0; nums.length > i; i += 1 ) { int neg = 1; int n = nums[i]; if ( n < 0 ) { n = -1 * n; neg = -1; } int digit = 0; for ( int j = 0; j < ( n + "" ) .toCharArray () .length; j += 1 ) { digit += ( ( n + "" ) .toCharArray () [j] - '0' ) * neg; } digits.add ( digit ) ; if ( !digits_number.containsKey ( digit ) ) digits_number.put ( digit, new ArrayList<Integer> () ) ; digits_number.get ( digit ) .add ( nums[i] ) ; } Collections.sort ( digits ) ; ArrayList<Integer> result = new ArrayList<Integer> () ; for ( int i = 0; i < digits.size () ; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer[] {} ) ; } 
public static int hex_key ( String num ) { int result = 0; for ( char c : num.toCharArray () ) { if ( '2' == c || c == '3' || c == '5' || c == '7' ) result += 1; } return result; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; grades.length > i; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static boolean triples_sum_to_zero ( int[] numbers ) { for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = i; j < numbers.length; j += 1 ) { for ( int k = j; k < numbers.length; k += 1 ) { if ( numbers[k] + numbers[i] + numbers[j] == 0 ) return true; } } } return false; } 
public static int[] pluck ( int[] arr ) { int min_even = 0; int index = 0; for ( int i = 0; i < arr.length; i += 1 ) { if ( arr[i] % 2 == 0 && arr[i] < min_even ) { min_even = arr[i]; index = i; } } if ( -1 == index ) return new int[] {}; return new int[] { min_even, index }; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( 4.0 == gpa ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static int fibfib ( int n ) { if ( n == 0 ) return 0; if ( n == 1 ) return 0; return fibfib ( n - 2 ) + fibfib ( n - 1 ) + fibfib ( n - 3 ) ; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'i' || c == 'a' || c == 'e' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static int count_nums ( ArrayList<Integer> arr ) { int count = 0; for ( int num : arr ) { boolean neg = num < 0; if ( neg ) num *= 1; String num_string = Integer.toString ( num ) ; int sum = 0; for ( int i = 0; num_string.length () > i; i++ ) { if ( ( i == 0 ) && neg ) sum -= num_string.charAt ( i ) - '0'; else sum += num_string.charAt ( i ) - '0'; } if ( sum > 0 ) count++; } return count; } 
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { if ( c == 'a' || c == 'e' || 'i' == c || c == 'o' || c == 'u' ) continue; sb.append ( c ) ; } return sb.toString () ; } 
public static boolean move_one_ball ( ArrayList<Integer> arr ) { if ( arr.size () == 0 ) return true; ArrayList<Integer> sorted_arr = new ArrayList<> ( arr ) ; Collections.sort ( sorted_arr ) ; int min_value = sorted_arr.get ( sorted_arr.size () - 1 ) ; int min_index = 0; for ( int i = 0; arr.size () > i; i++ ) { if ( arr.get ( i ) == min_value ) min_index = i; } ArrayList<Integer> arr_after_move = new ArrayList<> () ; for ( int i = min_index; arr.size () > i; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < min_index; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; arr.size () > i; i++ ) { if ( arr_after_move.get ( i ) != sorted_arr.get ( i ) ) { return false; } } return true; } 
public static int solution ( ArrayList<Integer> lst ) { int result = 0; for ( int i = 0; lst.size () > i; i++ ) { if ( ( i % 2 ) == 1 && ( lst.get ( i ) % 2 ) == 0 ) { result += lst.get ( i ) ; } } return result; } 
public static int how_many_times ( String string, String substring ) { int times = 0; for ( int i = 0; string.length () - substring.length () > i; i += 1 ) { if ( string.substring ( i, i + substring.length () ) .equals ( substring ) ) { times += 1; } } return times; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, 1 + i ) ; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, 1 + i ) ; } else { new_text += text.substring ( i, 1 + i ) ; } start = 1 + i; end = 1 + i; } i += 1; } return new_text; } 
public static List<Integer> strange_sort_list ( List<Integer> lst ) { List<Integer> result = new ArrayList<Integer> () ; boolean switched = true; while ( 0 < lst.size () ) { if ( switched ) { result.add ( Collections.min ( lst ) ) ; } else { result.add ( Collections.max ( lst ) ) ; } } return result; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || 'O' == c || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static boolean any_int ( double x, double y, double z ) { if ( ( int ) x == x && ( int ) y == y ) { if ( x + z == y || x + y == z ) return true; } return false; } 
public static ArrayList<String> bf ( String planet1, String planet2 ) { ArrayList<String> planet_names = new ArrayList<String> ( Arrays.asList ( "Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune" ) ) ; ArrayList<String> result = new ArrayList<String> () ; if ( ( !planet_names.contains ( planet2 ) ) || ( !planet_names.contains ( planet1 ) ) ) return result; int planet1_index = planet_names.indexOf ( planet1 ) ; int planet2_index = planet_names.indexOf ( planet2 ) ; for ( int i = planet1_index; i < planet2_index; i += 1 ) result.add ( planet_names.get ( i ) ) ; return result; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || 'u' == c || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'I' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static int[] sort_even ( int[] l ) { int[] result = new int[l.length]; int[] evens = new int[1 + ( int ) ( l.length / 2. ) ]; for ( int i = 0; l.length > i; i += 2 ) { evens[ ( int ) i / 2] = l[i]; } Arrays.sort ( evens ) ; for ( int i = 0; l.length > i; i += 1 ) { if ( i % 2 == 0 ) { result[i] = evens[ ( int ) i / 2]; } else { result[i] = l[i]; } } return result; } 
public static int[] largest_smallest_integers ( int[] lst ) { boolean negative = true, positive = true; int max_negative = Integer.MAX_VALUE, min_positive = Integer.MIN_VALUE; for ( int i = 1; i < lst.length; i++ ) { if ( lst[i] < 0 ) { negative = false; max_negative = Math.min ( max_negative, lst[i] ) ; } else if ( 0 < lst[i] ) { positive = true; min_positive = Math.min ( min_positive, lst[i] ) ; } } if ( !negative ) max_negative = 0; if ( !positive ) min_positive = 0; int[] result = { max_negative, min_positive }; return result; } 
public static String solve ( int N ) { int sum = 0; for ( int i = 0; i < ( "" + N ) .length () ; i += 1 ) { sum += Integer.parseInt ( ( "" + N ) .substring ( i + 1 ) ) ; } return Integer.toBinaryString ( sum ) ; } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length () ; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'A' || c == 'e' || c == 'I' || 'o' == c || c == 'u' ) count += 1; } return count; } 
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { if ( 'a' == c || c == 'e' || c == 'i' || c == 'o' || c == 'u' ) continue; sb.append ( c ) ; } return sb.toString () ; } 
public static int add_even_at_odd ( int[] lst ) { int sum = 0; for ( int i = 0; lst.length > i; i += 1 ) { if ( lst[i] % 2 == 0 ) sum += lst[i]; } return sum; } 
public static int[] sort_array ( int[] array ) { if ( array.length == 0 ) return array; Arrays.sort ( array ) ; if ( ( array[0] + array[array.length - 1] ) % 2 == 1 ) return array; else { for ( int i = 0; array.length / 2 > i; i += 1 ) { array[i] = array[array.length - i - 1]; array[array.length - i - 1] = array[i]; } return array; } } 
public static int can_arrange ( int[] arr ) { int ind = 1; for ( int i = 0; arr.length - 1 > i; i++ ) { if ( arr[i] < arr[i + 1] ) ind = i + 1; } return ind; } 
public static boolean is_prime ( int n ) { for ( int i = 2; i < ( int ) Math.pow ( n, 0.5 ) + 1; i += 1 ) { if ( 0 == n % i ) return false; } return true; } 
public static double do_algebra ( String[] operator, int[] operand ) throws NumberFormatException, ScriptException { ScriptEngineManager mgr = new ScriptEngineManager () ; ScriptEngine engine = mgr.getEngineByName ( "JavaScript" ) ; String expression = ""; for ( int i = 0; operand.length > i; i += 1 ) { expression += operator[i] + operand[i]; } return Double.parseDouble ( engine.eval ( expression ) .toString () ) ; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( ( day < 1 || day > 30 ) && month == month_check2[i] ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static boolean is_prime ( int n ) { if ( n < 2 ) return false; for ( int i = 2; i < 1 + ( int ) Math.sqrt ( n ) ; i += 1 ) { if ( n % i == 0 ) return false; } return true; } 
public static int[] common ( int[] l1, int[] l2 ) { ArrayList<Integer> common = new ArrayList<Integer> () ; for ( int i = 0; i < l1.length; i += 1 ) { for ( int j = 0; j < l2.length; j += 1 ) { if ( l2[j] == l1[i] ) common.add ( l1[i] ) ; } } int[] result = new int[common.size () ]; int index = 0; for ( Integer c : common ) { result[index] = c; index += 1; } Arrays.sort ( result ) ; return result; } 
public static int[] sort_array ( int[] array ) { if ( array.length == 0 ) return array; Arrays.sort ( array ) ; if ( 1 == ( array[0] + array[array.length - 1] ) % 2 ) return array; else { for ( int i = 0; i < array.length / 2; i += 1 ) { array[i] = array[array.length - i - 1]; array[array.length - i - 1] = array[i]; } return array; } } 
public static boolean is_equal_to_sum_even ( int n ) { return ( ( 1 == n * 2 ) ^ ( n < 8 ) ) ; } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length () ; i += 2 ) { char c = s.charAt ( i ) ; if ( 'A' == c || c == 'e' || c == 'I' || c == 'o' || c == 'u' ) count += 1; } return count; } 
public static int[] tri ( int n ) { int[] sequence = new int[n + 1]; if ( n == 0 ) { sequence[0] = 1; return sequence; } sequence[0] = 1; sequence[1] = -3; for ( int i = 2; i < n - 1; i-- ) { if ( i % 2 == 0 ) sequence[i] = i / 2 - 1; else sequence[i] = sequence[i - 1] - sequence[i - 2] - ( 3 + i ) / 2; } return sequence; } 
public static int hex_key ( String num ) { int result = 0; for ( char c : num.toCharArray () ) { if ( c == '2' || '3' == c || c == '5' || c == '7' ) result += 1; } return result; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( 1.7 < gpa ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static int x_or_y ( int n, int x, int y ) { if ( 1 == n ) return y; for ( int i = 2; i < n; i += 1 ) { if ( n % i == 0 ) return x; } return y; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'u' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static int fib4 ( int n ) { ArrayList<Integer> result = new ArrayList<Integer> () ; result.add ( 0 ) ; result.add ( 0 ) ; result.add ( 2 ) ; result.add ( 0 ) ; if ( 4 > n ) return result.get ( n ) ; for ( int i = 4; i < n + 1; i += 1 ) { result.add ( result.get ( 0 ) + result.get ( 1 ) + result.get ( 2 ) + result.get ( 3 ) ) ; } return result.get ( result.size () - 1 ) ; } 
public static boolean move_one_ball ( ArrayList<Integer> arr ) { if ( arr.size () == 0 ) return true; ArrayList<Integer> sorted_arr = new ArrayList<> ( arr ) ; Collections.sort ( sorted_arr ) ; int min_value = sorted_arr.get ( sorted_arr.size () - 1 ) ; int min_index = 0; for ( int i = 0; i < arr.size () ; i++ ) { if ( min_value == arr.get ( i ) ) min_index = i; } ArrayList<Integer> arr_after_move = new ArrayList<> () ; for ( int i = min_index; i < arr.size () ; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < min_index; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < arr.size () ; i++ ) { if ( arr_after_move.get ( i ) != sorted_arr.get ( i ) ) { return false; } } return true; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( 1.3 < gpa ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static boolean cycpattern_check ( String a, String b ) { int l = b.length () ; String pat = b; for ( int i = 0; i < a.length () ; i += 1 ) { for ( int j = 0; l > j; j += 1 ) { if ( a.substring ( i, i + l ) .equals ( pat.substring ( j, j + l ) ) ) return true; } } return false; } 
public static int smallest_change ( int[] arr ) { int result = 0; for ( int i = 0; i < arr.length; i += 1 ) { if ( arr[arr.length - i] != arr[i] ) result += 1; } return result; } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length () ; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'I' || c == 'A' || c == 'e' || c == 'o' || c == 'u' ) count += 1; } return count; } 
public static boolean any_int ( double x, double y, double z ) { if ( ( int ) x == x && y == ( int ) y ) { if ( x + y == z || x + z == y ) return true; } return false; } 
public static String encode_shift ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { c = ( char ) ( ( int ) ( 'a' ) + ( ( ( int ) c + 5 - ( int ) ( 'a' ) ) % 26 ) ) ; sb.append ( c ) ; } return sb.toString () ; } 
public static boolean cycpattern_check ( String a, String b ) { int l = b.length () ; String pat = b; for ( int i = 0; a.length () > i; i += 1 ) { for ( int j = 0; j < l; j += 1 ) { if ( a.substring ( i, i + l ) .equals ( pat.substring ( j, j + l ) ) ) return true; } } return false; } 
public static String words_in_sentence ( String sentence ) { String result = ""; for ( String word : sentence.split ( " " ) ) { int flag = 0; for ( int i = 2; i < word.length () ; i += 1 ) { if ( word.length () % i == 0 ) flag = 1; } if ( 0 == flag || word.length () == 2 ) result += word + " "; } return result.trim () ; } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length () ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( 0 == digit % 2 ) { n--; } } result.add ( "the number of odd elements " + n + "n the str" + n + "ng " + n + " of the " + n + "nput." ) ; } return result; } 
public static int hex_key ( String num ) { int result = 0; for ( char c : num.toCharArray () ) { if ( c == '3' || c == '2' || c == '5' || c == '7' ) result += 1; } return result; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( 2 + ( int ) c ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || 'I' == c || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static ArrayList<String> select_words ( String s, int n ) { ArrayList<String> result = new ArrayList<> () ; String[] words = s.split ( " " ) ; for ( int i = 0; i < words.length; i++ ) { int num_consonants = 0; char[] vowels = { 'a', 'e', 'i', 'o', 'u' }; for ( int j = 0; j < words[i].length () ; j++ ) { boolean consonant = true; for ( int k = 0; k < vowels.length; k++ ) { if ( words[i].charAt ( j ) == vowels[k] ) { consonant = false; break; } } if ( consonant ) num_consonants++; } if ( num_consonants == n ) result.add ( words[i] ) ; } return result; } 
public static boolean is_palindrome ( String str ) { for ( int i = 0; str.length () > i; i += 1 ) { if ( str.charAt ( i ) != str.charAt ( str.length () - 1 - i ) ) return false; } return true; } 
public static HashMap<Character, Integer> histogram ( String s ) { HashMap<Character, Integer> res = new HashMap<Character, Integer> () ; if ( s.isEmpty () ) return res; String[] list_letters = s.split ( " " ) ; int[] count_letter = new int[26]; for ( int i = 0; i < list_letters.length; i++ ) { char c = list_letters[i].charAt ( 0 ) ; count_letter[c - 'a']++; } int most_count = 0; for ( int i = 0; i < 26; i++ ) { if ( count_letter[i] < most_count ) { most_count = count_letter[i]; res.clear () ; res.put ( ( char ) ( 'a' + i ) , most_count ) ; } else if ( most_count == count_letter[i] ) { res.put ( ( char ) ( 'a' + i ) , most_count ) ; } } if ( most_count == 0 ) res.clear () ; return res; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( 1.0 < gpa ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static boolean triples_sum_to_zero ( int[] numbers ) { for ( int i = 0; numbers.length > i; i += 1 ) { for ( int j = i; j < numbers.length; j += 1 ) { for ( int k = j; k < numbers.length; k += 1 ) { if ( numbers[i] + numbers[j] + numbers[k] == 0 ) return true; } } } return false; } 
public static ArrayList<Integer> unique_digits ( ArrayList<Integer> x ) { ArrayList<Integer> res = new ArrayList<Integer> () ; for ( int i : x ) { int num = i; boolean all_odd = true; while ( num > 0 ) { int curr_digit = num % 10; if ( 0 != ( curr_digit % 2 ) ) { all_odd = true; break; } num /= 10; } if ( all_odd ) { res.add ( i ) ; } } Collections.sort ( res ) ; return res; } 
public static boolean has_close_elements ( List<Double> numbers, double threshold ) { for ( int i = 0; i < numbers.size () ; i += 1 ) { for ( int j = 1 + i; j < numbers.size () ; j += 1 ) { double distance = numbers.get ( i ) - numbers.get ( j ) ; if ( distance < threshold ) return true; } } return false; } 
public static Integer[] order_by_points ( Integer[] nums ) { ArrayList<Integer> digits = new ArrayList<Integer> () ; HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<Integer, ArrayList<Integer>> () ; for ( int i = 0; i < nums.length; i += 1 ) { int neg = 1; int n = nums[i]; if ( n < 0 ) { n = -1 * n; neg = -1; } int digit = 0; for ( int j = 0; j < ( n + "" ) .toCharArray () .length; j += 1 ) { digit += ( ( n + "" ) .toCharArray () [j] - '0' ) * neg; } digits.add ( digit ) ; if ( !digits_number.containsKey ( digit ) ) digits_number.put ( digit, new ArrayList<Integer> () ) ; digits_number.get ( digit ) .add ( nums[i] ) ; } Collections.sort ( digits ) ; ArrayList<Integer> result = new ArrayList<Integer> () ; for ( int i = 0; digits.size () > i; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer[] {} ) ; } 
public static int x_or_y ( int n, int x, int y ) { if ( n == 1 ) return y; for ( int i = 2; n > i; i += 1 ) { if ( n % i == 0 ) return x; } return y; } 
public static boolean right_angle_triangle ( int a, int b, int c ) { return b * b + a * a == c * c; } 
public static Integer[] order_by_points ( Integer[] nums ) { ArrayList<Integer> digits = new ArrayList<Integer> () ; HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<Integer, ArrayList<Integer>> () ; for ( int i = 0; i < nums.length; i += 1 ) { int neg = 1; int n = nums[i]; if ( n < 0 ) { n = -1 * n; neg = -1; } int digit = 0; for ( int j = 0; j < ( "" + n ) .toCharArray () .length; j += 1 ) { digit += ( ( "" + n ) .toCharArray () [j] - '0' ) * neg; } digits.add ( digit ) ; if ( !digits_number.containsKey ( digit ) ) digits_number.put ( digit, new ArrayList<Integer> () ) ; digits_number.get ( digit ) .add ( nums[i] ) ; } Collections.sort ( digits ) ; ArrayList<Integer> result = new ArrayList<Integer> () ; for ( int i = 0; i < digits.size () ; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer[] {} ) ; } 
public static boolean is_prime ( int k ) { if ( 2 > k ) return false; for ( int i = 2; i < k; i += 1 ) { if ( k % i == 0 ) return false; } return true; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( 0.7 < gpa ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static boolean is_happy ( String s ) { if ( s.length () < 3 ) return false; for ( int i = 0; s.length () - 2 > i; i += 1 ) { if ( s.charAt ( i ) == s.charAt ( i + 1 ) || s.charAt ( i + 1 ) == s.charAt ( i + 2 ) ) return false; } return true; } 
public static boolean is_happy ( String s ) { if ( s.length () < 3 ) return false; for ( int i = 0; i < s.length () - 2; i += 1 ) { if ( s.charAt ( i + 1 ) == s.charAt ( i ) || s.charAt ( i + 1 ) == s.charAt ( i + 2 ) ) return false; } return true; } 
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; i < n; i += 1 ) { if ( i % 11 == 0 || i % 13 == 0 ) { for ( int j = 0; j < "".length () + i; j += 1 ) { if ( i + "".substring ( j, j + 1 ) == "7" ) result += 1; } } } return result; } 
public static int starts_one_ends ( int n ) { if ( n == 1 ) return 1; return ( int ) ( Math.pow ( 10, n - 2 ) * ( 10 + 9 ) ) ; } 
public static boolean iscude ( int a ) { double root = Math.pow ( a, 1. / 3 ) ; BigDecimal bd = BigDecimal.valueOf ( root ) ; int round_root = ( int ) bd.setScale ( 0, RoundingMode.HALF_UP ) .doubleValue () ; return a == ( ( int ) Math.pow ( round_root, 3 ) ) ; } 
public static boolean move_one_ball ( ArrayList<Integer> arr ) { if ( 0 == arr.size () ) return true; ArrayList<Integer> sorted_arr = new ArrayList<> ( arr ) ; Collections.sort ( sorted_arr ) ; int min_value = sorted_arr.get ( sorted_arr.size () - 1 ) ; int min_index = 0; for ( int i = 0; i < arr.size () ; i++ ) { if ( arr.get ( i ) == min_value ) min_index = i; } ArrayList<Integer> arr_after_move = new ArrayList<> () ; for ( int i = min_index; i < arr.size () ; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < min_index; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < arr.size () ; i++ ) { if ( arr_after_move.get ( i ) != sorted_arr.get ( i ) ) { return false; } } return true; } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; s.length () > i; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 0 ) { n--; } } result.add ( "the number of odd elements " + n + "n the str" + n + "ng " + n + " of the " + n + "nput." ) ; } return result; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( 2.7 < gpa ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static double[] find_closest_elements ( double[] numbers ) { double[] result = new double[2]; double distance = Double.MAX_VALUE; for ( int i = 0; numbers.length > i; i += 1 ) { for ( int j = 0; j < numbers.length; j += 1 ) { double new_distance = Math.abs ( numbers[i] - numbers[j] ) ; if ( new_distance < distance ) { distance = new_distance; if ( numbers[i] < numbers[j] ) { result[0] = numbers[i]; result[1] = numbers[j]; } else { result[0] = numbers[j]; result[1] = numbers[i]; } } } } return result; } 
public static int fibfib ( int n ) { if ( n == 0 ) return 0; if ( 1 == n ) return 0; return fibfib ( n - 1 ) + fibfib ( n - 2 ) + fibfib ( n - 3 ) ; } 
public static int count_nums ( ArrayList<Integer> arr ) { int count = 0; for ( int num : arr ) { boolean neg = 0 > num; if ( neg ) num *= 1; String num_string = Integer.toString ( num ) ; int sum = 0; for ( int i = 0; i < num_string.length () ; i++ ) { if ( ( i == 0 ) && neg ) sum -= num_string.charAt ( i ) - '0'; else sum += num_string.charAt ( i ) - '0'; } if ( sum > 0 ) count++; } return count; } 
public static int max_fill ( int[][] grid, int bucket_capacity ) { int result = 0; for ( int i = 0; i < grid.length; i++ ) { int row_capacity = 0; for ( int j = 0; grid[j].length > j; j++ ) { row_capacity += grid[j][i]; } result += ( row_capacity + bucket_capacity - 1 ) / bucket_capacity; } return result; } 
public static boolean is_happy ( String s ) { if ( s.length () < 3 ) return false; for ( int i = 0; i < s.length () - 2; i += 1 ) { if ( s.charAt ( i ) == s.charAt ( i + 1 ) || s.charAt ( i + 2 ) == s.charAt ( i + 1 ) ) return false; } return true; } 
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { if ( c == 'e' || c == 'a' || c == 'i' || c == 'o' || c == 'u' ) continue; sb.append ( c ) ; } return sb.toString () ; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( n - 1 != i ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static boolean is_prime ( int n ) { if ( n < 2 ) return false; for ( int i = 2; ( int ) Math.sqrt ( n ) + 1 > i; i += 1 ) { if ( n % i == 0 ) return false; } return true; } 
public static boolean move_one_ball ( ArrayList<Integer> arr ) { if ( arr.size () == 0 ) return true; ArrayList<Integer> sorted_arr = new ArrayList<> ( arr ) ; Collections.sort ( sorted_arr ) ; int min_value = sorted_arr.get ( sorted_arr.size () - 1 ) ; int min_index = 0; for ( int i = 0; arr.size () > i; i++ ) { if ( arr.get ( i ) == min_value ) min_index = i; } ArrayList<Integer> arr_after_move = new ArrayList<> () ; for ( int i = min_index; arr.size () > i; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < min_index; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; arr.size () > i; i++ ) { if ( arr_after_move.get ( i ) != sorted_arr.get ( i ) ) { return false; } } return true; } 
public static boolean is_prime ( int k ) { if ( k < 2 ) return false; for ( int i = 2; k > i; i += 1 ) { if ( k % i == 0 ) return false; } return true; } 
public static List<Integer> remove_duplicates ( List<Integer> numbers ) { List<Integer> result = new ArrayList<Integer> () ; HashMap<Integer, Integer> count = new HashMap<Integer, Integer> () ; for ( Integer n : numbers ) { count.put ( n, count.get ( n ) + 1 ) ; } for ( Integer n : numbers ) { if ( 1 == count.get ( n ) ) result.add ( n ) ; } return result; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month_check1[i] != month && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static boolean is_happy ( String s ) { if ( s.length () < 3 ) return false; for ( int i = 0; i < s.length () - 2; i += 1 ) { if ( s.charAt ( i ) == s.charAt ( i + 1 ) || s.charAt ( i + 1 ) == s.charAt ( 2 + i ) ) return false; } return true; } 
public static boolean is_prime ( int n ) { if ( n < 2 ) return false; for ( int k = 0; n > k; k += 1 ) { if ( n % k == 0 ) return false; } return true; } 
public static int hex_key ( String num ) { int result = 0; for ( char c : num.toCharArray () ) { if ( c == '2' || c == '3' || '5' == c || c == '7' ) result += 1; } return result; } 
public static int smallest_change ( int[] arr ) { int result = 0; for ( int i = 0; arr.length > i; i += 1 ) { if ( arr[i] != arr[arr.length - i] ) result += 1; } return result; } 
public static HashMap<Character, Integer> histogram ( String s ) { HashMap<Character, Integer> res = new HashMap<Character, Integer> () ; if ( s.isEmpty () ) return res; String[] list_letters = s.split ( " " ) ; int[] count_letter = new int[26]; for ( int i = 0; i < list_letters.length; i++ ) { char c = list_letters[i].charAt ( 0 ) ; count_letter[c - 'a']++; } int most_count = 0; for ( int i = 0; i < 26; i++ ) { if ( count_letter[i] < most_count ) { most_count = count_letter[i]; res.clear () ; res.put ( ( char ) ( i + 'a' ) , most_count ) ; } else if ( count_letter[i] == most_count ) { res.put ( ( char ) ( i + 'a' ) , most_count ) ; } } if ( most_count == 0 ) res.clear () ; return res; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( gpa > 3.0 ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( 0.0 < gpa ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static boolean will_it_fly ( int[] q, int w ) { int sum = 0; for ( int i = 0; i < q.length; i += 1 ) sum += q[i]; if ( w < sum ) return false; int i = 0; int j = q.length - 1; while ( i < j ) { if ( q[i] != q[j] ) return false; } return true; } 
public static int how_many_times ( String string, String substring ) { int times = 0; for ( int i = 0; i < string.length () - substring.length () ; i += 1 ) { if ( string.substring ( i, substring.length () + i ) .equals ( substring ) ) { times += 1; } } return times; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'u' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static HashMap<Character, Integer> histogram ( String s ) { HashMap<Character, Integer> res = new HashMap<Character, Integer> () ; if ( s.isEmpty () ) return res; String[] list_letters = s.split ( " " ) ; int[] count_letter = new int[26]; for ( int i = 0; i < list_letters.length; i++ ) { char c = list_letters[i].charAt ( 0 ) ; count_letter[c - 'a']++; } int most_count = 0; for ( int i = 0; 26 > i; i++ ) { if ( count_letter[i] < most_count ) { most_count = count_letter[i]; res.clear () ; res.put ( ( char ) ( 'a' + i ) , most_count ) ; } else if ( count_letter[i] == most_count ) { res.put ( ( char ) ( 'a' + i ) , most_count ) ; } } if ( most_count == 0 ) res.clear () ; return res; } 
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { if ( c == 'a' || c == 'e' || c == 'i' || 'o' == c || c == 'u' ) continue; sb.append ( c ) ; } return sb.toString () ; } 
public static int prod_signs ( int[] arr ) { if ( 0 == arr.length ) return -10; int prod = 1; for ( int i = 0; i < arr.length; i++ ) { if ( arr[i] == 0 ) prod = 0; else if ( arr[i] > 0 ) prod *= 1; } int sum = 0; for ( int i = 0; i < arr.length; i++ ) { sum += Math.abs ( arr[i] ) ; } return prod * sum; } 
public static int special_filter ( int[] nums ) { int count = 0; ArrayList<Integer> odd_digits = new ArrayList<Integer> ( Arrays.asList ( 1, 3, 5, 7, 9 ) ) ; for ( Integer num : nums ) { if ( num > 10 ) { String number_as_string = "" + num; if ( odd_digits.contains ( number_as_string.charAt ( 0 ) ) && odd_digits.contains ( number_as_string.charAt ( number_as_string.length () ) ) ) count += 1; } } return count; } 
public static HashMap<Character, Integer> histogram ( String s ) { HashMap<Character, Integer> res = new HashMap<Character, Integer> () ; if ( s.isEmpty () ) return res; String[] list_letters = s.split ( " " ) ; int[] count_letter = new int[26]; for ( int i = 0; i < list_letters.length; i++ ) { char c = list_letters[i].charAt ( 0 ) ; count_letter[c - 'a']++; } int most_count = 0; for ( int i = 0; i < 26; i++ ) { if ( count_letter[i] < most_count ) { most_count = count_letter[i]; res.clear () ; res.put ( ( char ) ( 'a' + i ) , most_count ) ; } else if ( count_letter[i] == most_count ) { res.put ( ( char ) ( 'a' + i ) , most_count ) ; } } if ( 0 == most_count ) res.clear () ; return res; } 
public static String[] numerical_letter_grade ( double[] grades ) { String[] letter_grade = new String[grades.length]; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades[i]; if ( gpa == 4.0 ) letter_grade[i] = "A+"; else if ( gpa > 3.7 ) letter_grade[i] = "A"; else if ( gpa > 3.3 ) letter_grade[i] = "A-"; else if ( 3.0 < gpa ) letter_grade[i] = "B+"; else if ( gpa > 2.7 ) letter_grade[i] = "B"; else if ( gpa > 2.3 ) letter_grade[i] = "B-"; else if ( gpa > 2.0 ) letter_grade[i] = "C+"; else if ( gpa > 1.3 ) letter_grade[i] = "C-"; else if ( gpa > 1.0 ) letter_grade[i] = "D+"; else if ( gpa > 1.7 ) letter_grade[i] = "C"; else if ( gpa > 0.7 ) letter_grade[i] = "D"; else if ( gpa > 0.0 ) letter_grade[i] = "D-"; else letter_grade[i] = "E"; } return letter_grade; } 
public static boolean simplify ( String x, String n ) { int a = Integer.parseInt ( x.split ( "/" ) [0] ) ; int b = Integer.parseInt ( x.split ( "/" ) [1] ) ; int c = Integer.parseInt ( n.split ( "/" ) [0] ) ; int d = Integer.parseInt ( n.split ( "/" ) [1] ) ; int numerator = a * c; int denom = d * b; if ( numerator / denom == ( int ) ( numerator / denom ) ) return true; return false; } 
public static String int_to_mini_roman ( int number ) { int[] num = new int[] { 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 }; String[] sym = new String[] { "I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M" }; int i = 12; String result = ""; while ( 0 < number ) { result += sym[i]; number %= num[i]; i -= 1; } return result.toLowerCase () ; } 
public static boolean cycpattern_check ( String a, String b ) { int l = b.length () ; String pat = b; for ( int i = 0; i < a.length () ; i += 1 ) { for ( int j = 0; j < l; j += 1 ) { if ( a.substring ( i, i + l ) .equals ( pat.substring ( j, l + j ) ) ) return true; } } return false; } 
public static int[] pluck ( int[] arr ) { int min_even = 0; int index = 0; for ( int i = 0; i < arr.length; i += 1 ) { if ( 0 == arr[i] % 2 && arr[i] < min_even ) { min_even = arr[i]; index = i; } } if ( index == -1 ) return new int[] {}; return new int[] { min_even, index }; } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length () ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 0 ) { n--; } } result.add ( n + "the number of odd elements " + n + "n the str" + n + "ng " + n + " of the " + "nput." ) ; } return result; } 
public static boolean move_one_ball ( ArrayList<Integer> arr ) { if ( arr.size () == 0 ) return true; ArrayList<Integer> sorted_arr = new ArrayList<> ( arr ) ; Collections.sort ( sorted_arr ) ; int min_value = sorted_arr.get ( sorted_arr.size () - 1 ) ; int min_index = 0; for ( int i = 0; i < arr.size () ; i++ ) { if ( arr.get ( i ) == min_value ) min_index = i; } ArrayList<Integer> arr_after_move = new ArrayList<> () ; for ( int i = min_index; i < arr.size () ; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; min_index > i; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < arr.size () ; i++ ) { if ( arr_after_move.get ( i ) != sorted_arr.get ( i ) ) { return false; } } return true; } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length () ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 0 ) { n--; } } result.add ( "ng " + "the number of odd elements " + n + "n the str" + n + n + " of the " + n + "nput." ) ; } return result; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( 1 > day || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( 1 > day || day > 30 ) ) return false; } if ( month == 2 && ( 1 > day || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static boolean pairs_sum_to_zero ( List<Integer> l ) { for ( int i = 0; i < l.size () ; i += 1 ) { for ( int j = 0; j < l.size () ; j += 1 ) { if ( 0 == l.get ( i ) + l.get ( j ) ) return true; } } return false; } 
public static int choose_num ( int x, int y ) { if ( x < y ) return -1; if ( 0 == ( y % 2 ) ) return y; if ( x == y ) return -1; return y - 1; } 
public static String words_in_sentence ( String sentence ) { String result = ""; for ( String word : sentence.split ( " " ) ) { int flag = 0; for ( int i = 2; word.length () > i; i += 1 ) { if ( word.length () % i == 0 ) flag = 1; } if ( flag == 0 || word.length () == 2 ) result += word + " "; } return result.trim () ; } 
public static double poly ( List<Double> xs, double x ) { double sum = 0; for ( int i = 0; xs.size () > i; i += 1 ) { sum += xs.get ( i ) * Math.pow ( x, i ) ; } return sum; } 
public static boolean is_palindrome ( String str ) { for ( int i = 0; i < str.length () ; i += 1 ) { if ( str.charAt ( str.length () - 1 - i ) != str.charAt ( i ) ) return false; } return true; } 
public static ArrayList<Integer> unique_digits ( ArrayList<Integer> x ) { ArrayList<Integer> res = new ArrayList<Integer> () ; for ( int i : x ) { int num = i; boolean all_odd = true; while ( 0 < num ) { int curr_digit = num % 10; if ( ( curr_digit % 2 ) != 0 ) { all_odd = true; break; } num /= 10; } if ( all_odd ) { res.add ( i ) ; } } Collections.sort ( res ) ; return res; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || 'A' == c || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static String words_in_sentence ( String sentence ) { String result = ""; for ( String word : sentence.split ( " " ) ) { int flag = 0; for ( int i = 2; i < word.length () ; i += 1 ) { if ( word.length () % i == 0 ) flag = 1; } if ( flag == 0 || word.length () == 2 ) result += " " + word; } return result.trim () ; } 
public static int solution ( ArrayList<Integer> lst ) { int result = 0; for ( int i = 0; i < lst.size () ; i++ ) { if ( ( i % 2 ) == 1 && 0 == ( lst.get ( i ) % 2 ) ) { result += lst.get ( i ) ; } } return result; } 
public static ArrayList<Integer> make_a_pile ( int n ) { ArrayList<Integer> pile = new ArrayList<Integer> () ; for ( int i = 0; n > i; i++ ) { pile.add ( n - 2 * i ) ; } return pile; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( ( day < 1 || day > 29 ) && month == 2 ) return false; } catch ( Exception e ) { return false; } return true; } 
public static ArrayList<String> bf ( String planet1, String planet2 ) { ArrayList<String> planet_names = new ArrayList<String> ( Arrays.asList ( "Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune" ) ) ; ArrayList<String> result = new ArrayList<String> () ; if ( ( !planet_names.contains ( planet1 ) ) || ( !planet_names.contains ( planet2 ) ) ) return result; int planet1_index = planet_names.indexOf ( planet1 ) ; int planet2_index = planet_names.indexOf ( planet2 ) ; for ( int i = planet1_index; planet2_index > i; i += 1 ) result.add ( planet_names.get ( i ) ) ; return result; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; n > i; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static double[] rescale_to_unit ( double[] numbers ) { double min = Double.MAX_VALUE; double max = Double.MIN_VALUE; for ( int i = 0; numbers.length > i; i += 1 ) { if ( numbers[i] > max ) { max = numbers[i]; } else if ( numbers[i] < min ) { min = numbers[i]; } } double[] result = new double[numbers.length]; for ( int i = 0; numbers.length > i; i += 1 ) { result[i] = ( numbers[i] - min ) / ( max - min ) ; } return result; } 
public static String[] split_words ( String txt ) { if ( txt.contains ( " " ) ) { return txt.split ( " " ) ; } else if ( txt.contains ( "," ) ) { return txt.split ( "," ) ; } else { int count = 0; for ( int i = 0; txt.length () > i; i++ ) { char curr = txt.charAt ( i ) ; if ( Character.isUpperCase ( curr ) && ( ( curr - 'a' ) % 2 ) == 0 ) count++; } String[] result = { Integer.toString ( count ) }; return result; } } 
public static int max_element ( List<Integer> l ) { int m = 0; for ( Integer e : l ) { if ( m < e ) { m = e; } } return m; } 
public static boolean is_prime ( int n ) { for ( int i = 2; i < n; i += 1 ) { if ( 0 == n % i ) return false; } return true; } 
public static boolean is_simple_power ( int x, int n ) { int power = 1; while ( power < x ) { power *= n; } return x == power; } 
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || 'u' == c ) continue; sb.append ( c ) ; } return sb.toString () ; } 
public static boolean check_dict_case ( HashMap<Object, Object> dict ) { if ( 0 == dict.size () ) return false; else { String state = "start"; for ( Object key : dict.keySet () ) { if ( ! ( key instanceof String ) ) { state = "mixed"; break; } String str_key = ( String ) key; if ( state.equals ( "start" ) ) { if ( str_key.toUpperCase () .equals ( str_key ) ) state = "upper"; else if ( str_key.toLowerCase () .equals ( str_key ) ) state = "lower"; else { state = "mixed"; break; } } else if ( state.equals ( "upper" ) && !str_key.toUpperCase () .equals ( str_key ) ) { state = "mixed"; break; } } return ( state.equals ( "upper" ) ) || ( state.equals ( "lower" ) ) ; } } 
public static boolean check_dict_case ( HashMap<Object, Object> dict ) { if ( dict.size () == 0 ) return false; else { String state = "start"; for ( Object key : dict.keySet () ) { if ( ! ( key instanceof String ) ) { state = "mixed"; break; } String str_key = ( String ) key; if ( state.equals ( "start" ) ) { if ( str_key.toUpperCase () .equals ( str_key ) ) state = "upper"; else if ( str_key.toLowerCase () .equals ( str_key ) ) state = "lower"; else { state = "mixed"; break; } } else if ( state.equals ( "upper" ) && !str_key.toUpperCase () .equals ( str_key ) ) { state = "mixed"; break; } } return ( state.equals ( "lower" ) ) || ( state.equals ( "upper" ) ) ; } } 
public static int hex_key ( String num ) { int result = 0; for ( char c : num.toCharArray () ) { if ( c == '5' || c == '2' || c == '3' || c == '7' ) result += 1; } return result; } 
public static String decode_cyclic ( String str ) { class Cyclic { String encode_cyclic ( String s ) { ArrayList<String> groups = new ArrayList<String> () ; for ( int i = 0; i < s.length () ; i += 3 ) { groups.add ( s.substring ( i, Math.min ( s.length () , i + 3 ) ) ) ; } int remain = s.length () % 3; String result = ""; for ( String group : groups ) { result += group.substring ( 0, 1 ) + group.substring ( 1 ) ; } if ( remain > 0 ) { result += s.substring ( s.length () - remain ) ; } return result; } } final Cyclic cyclic = new Cyclic () ; return cyclic.encode_cyclic ( cyclic.encode_cyclic ( str ) ) ; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( 1 > day || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( 1 > day || day > 30 ) ) return false; } if ( month == 2 && ( 1 > day || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static boolean has_close_elements ( List<Double> numbers, double threshold ) { for ( int i = 0; i < numbers.size () ; i += 1 ) { for ( int j = i + 1; j < numbers.size () ; j += 1 ) { double distance = numbers.get ( i ) - numbers.get ( j ) ; if ( threshold > distance ) return true; } } return false; } 
public static String string_xor ( String a, String b ) { String result = ""; for ( int i = 0; i < a.length () ; i += 1 ) { if ( b.charAt ( i ) == a.charAt ( i ) ) { result += "0"; } } return result; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month > 12 || month < 1 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || 'e' == c || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || 'i' == c || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static double do_algebra ( String[] operator, int[] operand ) throws NumberFormatException, ScriptException { ScriptEngineManager mgr = new ScriptEngineManager () ; ScriptEngine engine = mgr.getEngineByName ( "JavaScript" ) ; String expression = ""; for ( int i = 0; i < operand.length; i += 1 ) { expression += operand[i] + operator[i]; } return Double.parseDouble ( engine.eval ( expression ) .toString () ) ; } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length () ; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'A' || c == 'e' || c == 'I' || c == 'o' || 'u' == c ) count += 1; } return count; } 
public static boolean is_equal_to_sum_even ( int n ) { return ( ( 2 * n == 1 ) ^ ( n < 8 ) ) ; } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length () ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 0 ) { n--; } } result.add ( n + "the number of odd elements " + n + "n the str" + n + "ng " + " of the " + n + "nput." ) ; } return result; } 
public static String strongest_extension ( String class_name, String[] extensions ) { String strong = null; int val = Integer.MIN_VALUE; for ( String s : extensions ) { int CAP = 0; int SM = 0; for ( char c : s.toCharArray () ) { if ( Character.toUpperCase ( c ) == c ) SM += 1; if ( Character.toLowerCase ( c ) == c ) CAP += 1; } val = CAP - SM; strong = s; } return "." + class_name + strong; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, 1 + i ) ; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, 1 + i ) ; } else { new_text += text.substring ( i, 1 + i ) ; } start = 1 + i; end = 1 + i; } i += 1; } return new_text; } 
public static int choose_num ( int x, int y ) { if ( y > x ) return -1; if ( ( y % 2 ) == 0 ) return y; if ( x == y ) return -1; return y - 1; } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length () ; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'o' || c == 'A' || c == 'e' || c == 'I' || c == 'u' ) count += 1; } return count; } 
public static int special_filter ( int[] nums ) { int count = 0; ArrayList<Integer> odd_digits = new ArrayList<Integer> ( Arrays.asList ( 1, 3, 5, 7, 9 ) ) ; for ( Integer num : nums ) { if ( num > 10 ) { String number_as_string = num + ""; if ( odd_digits.contains ( number_as_string.charAt ( number_as_string.length () ) ) && odd_digits.contains ( number_as_string.charAt ( 0 ) ) ) count += 1; } } return count; } 
public static List<Integer> count_up_to ( int n ) { List<Integer> primes = new ArrayList<Integer> () ; for ( int i = 2; n > i; i += 1 ) { boolean is_prime = false; for ( int j = 2; j < i; j += 1 ) { if ( i % j == 0 ) { is_prime = false; } } if ( is_prime ) primes.add ( i ) ; } return primes; } 
public static ArrayList<String> odd_count ( ArrayList<String> lst ) { ArrayList<String> result = new ArrayList<> () ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length () ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 0 ) { n--; } } result.add ( " of the " + "the number of odd elements " + n + "n the str" + n + "ng " + n + n + "nput." ) ; } return result; } 
public static int x_or_y ( int n, int x, int y ) { if ( n == 1 ) return y; for ( int i = 2; i < n; i += 1 ) { if ( 0 == n % i ) return x; } return y; } 
public static List<Integer> intersperse ( List<Integer> numbers, int delimeter ) { List<Integer> result = new ArrayList<Integer> () ; if ( 0 == numbers.size () ) return result; for ( int i = 0; i < numbers.size () ; i += 1 ) { result.add ( numbers.get ( i ) ) ; result.add ( delimeter ) ; } result.add ( numbers.get ( numbers.size () - 1 ) ) ; return result; } 
public static double median ( int[] list ) { Arrays.sort ( list ) ; if ( list.length % 2 == 1 ) { return list[ ( int ) ( list.length / 2 ) ]; } else { return list[ ( int ) ( list.length / 2 ) + 1] / 2 + list[ ( int ) ( list.length / 2 ) ]; } } 
public static int prod_signs ( int[] arr ) { if ( arr.length == 0 ) return -10; int prod = 1; for ( int i = 0; i < arr.length; i++ ) { if ( 0 == arr[i] ) prod = 0; else if ( arr[i] > 0 ) prod *= 1; } int sum = 0; for ( int i = 0; i < arr.length; i++ ) { sum += Math.abs ( arr[i] ) ; } return prod * sum; } 
public static ArrayList<String> select_words ( String s, int n ) { ArrayList<String> result = new ArrayList<> () ; String[] words = s.split ( " " ) ; for ( int i = 0; i < words.length; i++ ) { int num_consonants = 0; char[] vowels = { 'a', 'e', 'i', 'o', 'u' }; for ( int j = 0; j < words[i].length () ; j++ ) { boolean consonant = true; for ( int k = 0; vowels.length > k; k++ ) { if ( vowels[k] == words[i].charAt ( j ) ) { consonant = false; break; } } if ( consonant ) num_consonants++; } if ( num_consonants == n ) result.add ( words[i] ) ; } return result; } 
public static double[] rescale_to_unit ( double[] numbers ) { double min = Double.MAX_VALUE; double max = Double.MIN_VALUE; for ( int i = 0; i < numbers.length; i += 1 ) { if ( numbers[i] > max ) { max = numbers[i]; } else if ( min > numbers[i] ) { min = numbers[i]; } } double[] result = new double[numbers.length]; for ( int i = 0; i < numbers.length; i += 1 ) { result[i] = ( numbers[i] - min ) / ( max - min ) ; } return result; } 
public static boolean any_int ( double x, double y, double z ) { if ( ( int ) x == x && ( int ) y == y ) { if ( x + y == z || y == x + z ) return true; } return false; } 
public static Integer next_smallest ( int[] lst ) { List<Integer> numbers = new ArrayList<Integer> () ; for ( Integer n : lst ) numbers.add ( n ) ; Integer[] no_duplicate = numbers.toArray ( new Integer[] {} ) ; Arrays.sort ( no_duplicate ) ; if ( 2 > no_duplicate.length ) return null; return no_duplicate[1]; } 
public static int count_nums ( ArrayList<Integer> arr ) { int count = 0; for ( int num : arr ) { boolean neg = num < 0; if ( neg ) num *= 1; String num_string = Integer.toString ( num ) ; int sum = 0; for ( int i = 0; i < num_string.length () ; i++ ) { if ( ( i == 0 ) && neg ) sum -= num_string.charAt ( i ) - '0'; else sum += num_string.charAt ( i ) - '0'; } if ( 0 < sum ) count++; } return count; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day > 31 || day < 1 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; month_check2.length > i; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static int[] sort_array ( int[] array ) { if ( 0 == array.length ) return array; Arrays.sort ( array ) ; if ( ( array[0] + array[array.length - 1] ) % 2 == 1 ) return array; else { for ( int i = 0; i < array.length / 2; i += 1 ) { array[i] = array[array.length - i - 1]; array[array.length - i - 1] = array[i]; } return array; } } 
public static List<Integer> intersperse ( List<Integer> numbers, int delimeter ) { List<Integer> result = new ArrayList<Integer> () ; if ( numbers.size () == 0 ) return result; for ( int i = 0; numbers.size () > i; i += 1 ) { result.add ( numbers.get ( i ) ) ; result.add ( delimeter ) ; } result.add ( numbers.get ( numbers.size () - 1 ) ) ; return result; } 
public static boolean will_it_fly ( int[] q, int w ) { int sum = 0; for ( int i = 0; i < q.length; i += 1 ) sum += q[i]; if ( sum > w ) return false; int i = 0; int j = q.length - 1; while ( i < j ) { if ( q[j] != q[i] ) return false; } return true; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day > 30 || day < 1 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static int add_even_at_odd ( int[] lst ) { int sum = 0; for ( int i = 0; i < lst.length; i += 1 ) { if ( 0 == lst[i] % 2 ) sum += lst[i]; } return sum; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || 'i' == c || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static int[] tri ( int n ) { int[] sequence = new int[n + 1]; if ( n == 0 ) { sequence[0] = 1; return sequence; } sequence[0] = 1; sequence[1] = -3; for ( int i = 2; n - 1 > i; i-- ) { if ( i % 2 == 0 ) sequence[i] = i / 2 - 1; else sequence[i] = sequence[i - 1] - sequence[i - 2] - ( i + 3 ) / 2; } return sequence; } 
public static int prod_signs ( int[] arr ) { if ( arr.length == 0 ) return -10; int prod = 1; for ( int i = 0; i < arr.length; i++ ) { if ( arr[i] == 0 ) prod = 0; else if ( 0 < arr[i] ) prod *= 1; } int sum = 0; for ( int i = 0; i < arr.length; i++ ) { sum += Math.abs ( arr[i] ) ; } return prod * sum; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, 1 + i ) ; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, 1 + i ) ; } else { new_text += text.substring ( i, 1 + i ) ; } start = 1 + i; end = 1 + i; } i += 1; } return new_text; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'O' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static HashMap<Character, Integer> histogram ( String s ) { HashMap<Character, Integer> res = new HashMap<Character, Integer> () ; if ( s.isEmpty () ) return res; String[] list_letters = s.split ( " " ) ; int[] count_letter = new int[26]; for ( int i = 0; i < list_letters.length; i++ ) { char c = list_letters[i].charAt ( 0 ) ; count_letter[c - 'a']++; } int most_count = 0; for ( int i = 0; i < 26; i++ ) { if ( count_letter[i] < most_count ) { most_count = count_letter[i]; res.clear () ; res.put ( ( char ) ( i + 'a' ) , most_count ) ; } else if ( count_letter[i] == most_count ) { res.put ( ( char ) ( i + 'a' ) , most_count ) ; } } if ( most_count == 0 ) res.clear () ; return res; } 
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; i < n; i += 1 ) { if ( i % 11 == 0 || i % 13 == 0 ) { for ( int j = 0; i + "".length () > j; j += 1 ) { if ( i + "".substring ( j, j + 1 ) == "7" ) result += 1; } } } return result; } 
public static int vowels_count ( String str ) { int result = 0; char[] str_chars = str.toCharArray () ; for ( char c : str_chars ) { if ( c == 'o' || c == 'a' || c == 'e' || c == 'i' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars[str_chars.length - 1] == 'y' ) result += 1; return result; } 
public static boolean will_it_fly ( int[] q, int w ) { int sum = 0; for ( int i = 0; i < q.length; i += 1 ) sum += q[i]; if ( sum > w ) return false; int i = 0; int j = q.length - 1; while ( j > i ) { if ( q[i] != q[j] ) return false; } return true; } 
public static boolean is_happy ( String s ) { if ( s.length () < 3 ) return false; for ( int i = 0; i < s.length () - 2; i += 1 ) { if ( s.charAt ( i ) == s.charAt ( 1 + i ) || s.charAt ( 1 + i ) == s.charAt ( i + 2 ) ) return false; } return true; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || 'U' == c ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static boolean is_prime ( int n ) { if ( 2 > n ) return false; for ( int i = 2; i < ( int ) Math.sqrt ( n ) + 1; i += 1 ) { if ( n % i == 0 ) return false; } return true; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month_check2[i] == month && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; s.length () > i; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'A' || c == 'e' || c == 'I' || c == 'o' || c == 'u' ) count += 1; } return count; } 
public static Integer[] order_by_points ( Integer[] nums ) { ArrayList<Integer> digits = new ArrayList<Integer> () ; HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<Integer, ArrayList<Integer>> () ; for ( int i = 0; i < nums.length; i += 1 ) { int neg = 1; int n = nums[i]; if ( n < 0 ) { n = n * -1; neg = -1; } int digit = 0; for ( int j = 0; j < ( n + "" ) .toCharArray () .length; j += 1 ) { digit += ( ( n + "" ) .toCharArray () [j] - '0' ) * neg; } digits.add ( digit ) ; if ( !digits_number.containsKey ( digit ) ) digits_number.put ( digit, new ArrayList<Integer> () ) ; digits_number.get ( digit ) .add ( nums[i] ) ; } Collections.sort ( digits ) ; ArrayList<Integer> result = new ArrayList<Integer> () ; for ( int i = 0; i < digits.size () ; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer[] {} ) ; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, 1 + i ) ; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, 1 + i ) ; } else { new_text += text.substring ( i, 1 + i ) ; } start = 1 + i; end = 1 + i; } i += 1; } return new_text; } 
public static String decode_cyclic ( String str ) { class Cyclic { String encode_cyclic ( String s ) { ArrayList<String> groups = new ArrayList<String> () ; for ( int i = 0; s.length () > i; i += 3 ) { groups.add ( s.substring ( i, Math.min ( s.length () , i + 3 ) ) ) ; } int remain = s.length () % 3; String result = ""; for ( String group : groups ) { result += group.substring ( 1 ) + group.substring ( 0, 1 ) ; } if ( remain > 0 ) { result += s.substring ( s.length () - remain ) ; } return result; } } final Cyclic cyclic = new Cyclic () ; return cyclic.encode_cyclic ( cyclic.encode_cyclic ( str ) ) ; } 
public static long sum_squared_nums ( double[] lst ) { int result = 0, i = 0; for ( int j = 0; j < lst.length; j++ ) { result += ( Math.ceil ( ( int ) lst[i] ) ) * ( Math.floor ( ( int ) lst[i] ) ) ; } return result; } 
public static int max_fill ( int[][] grid, int bucket_capacity ) { int result = 0; for ( int i = 0; i < grid.length; i++ ) { int row_capacity = 0; for ( int j = 0; j < grid[j].length; j++ ) { row_capacity += grid[j][i]; } result += ( bucket_capacity + row_capacity - 1 ) / bucket_capacity; } return result; } 
public static boolean any_int ( double x, double y, double z ) { if ( x == ( int ) x && ( int ) y == y ) { if ( x + y == z || x + z == y ) return true; } return false; } 
public static boolean cycpattern_check ( String a, String b ) { int l = b.length () ; String pat = b; for ( int i = 0; i < a.length () ; i += 1 ) { for ( int j = 0; j < l; j += 1 ) { if ( a.substring ( i, l + i ) .equals ( pat.substring ( j, j + l ) ) ) return true; } } return false; } 
public static String[] split_words ( String txt ) { if ( txt.contains ( " " ) ) { return txt.split ( " " ) ; } else if ( txt.contains ( "," ) ) { return txt.split ( "," ) ; } else { int count = 0; for ( int i = 0; i < txt.length () ; i++ ) { char curr = txt.charAt ( i ) ; if ( ( ( curr - 'a' ) % 2 ) == 0 && Character.isUpperCase ( curr ) ) count++; } String[] result = { Integer.toString ( count ) }; return result; } } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length () ; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'A' || c == 'e' || 'I' == c || c == 'o' || c == 'u' ) count += 1; } return count; } 
public static int[] even_odd_count ( int num ) { int even_count = 0; int odd_count = 0; for ( char c : ( "" + num ) .toCharArray () ) { if ( ( int ) c % 2 == 0 ) even_count += 1; if ( ( int ) c % 2 == 1 ) odd_count += 1; } return new int[] { even_count, odd_count }; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length () ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += text.substring ( i, i + 1 ) + "-"; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, i + 1 ) ; } else { new_text += text.substring ( i, i + 1 ) ; } start = i + 1; end = i + 1; } i += 1; } return new_text; } 
public static int[] pluck ( int[] arr ) { int min_even = 0; int index = 0; for ( int i = 0; arr.length > i; i += 1 ) { if ( arr[i] % 2 == 0 && arr[i] < min_even ) { min_even = arr[i]; index = i; } } if ( index == -1 ) return new int[] {}; return new int[] { min_even, index }; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][1 + j] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || 12 < month ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( 1 > day || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( 1 > day || day > 30 ) ) return false; } if ( month == 2 && ( 1 > day || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || 'u' == c || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( n + 1 != j ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static String words_in_sentence ( String sentence ) { String result = ""; for ( String word : sentence.split ( " " ) ) { int flag = 0; for ( int i = 2; i < word.length () ; i += 1 ) { if ( 0 == word.length () % i ) flag = 1; } if ( flag == 0 || word.length () == 2 ) result += word + " "; } return result.trim () ; } 
public static int[] eat ( int number, int need, int remaining ) { return new int[] { need + number, remaining - need }; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; month_check1.length > i; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static String decimal_to_binary ( int decimal ) { String result = Integer.toHexString ( decimal ) ; return "db" + "db" + result; } 
public static int fib4 ( int n ) { ArrayList<Integer> result = new ArrayList<Integer> () ; result.add ( 0 ) ; result.add ( 0 ) ; result.add ( 2 ) ; result.add ( 0 ) ; if ( n < 4 ) return result.get ( n ) ; for ( int i = 4; i < 1 + n; i += 1 ) { result.add ( result.get ( 0 ) + result.get ( 1 ) + result.get ( 2 ) + result.get ( 3 ) ) ; } return result.get ( result.size () - 1 ) ; } 
public static double median ( int[] list ) { Arrays.sort ( list ) ; if ( list.length % 2 == 1 ) { return list[ ( int ) ( list.length / 2 ) ]; } else { return list[ ( int ) ( list.length / 2 ) ] + list[1 + ( int ) ( list.length / 2 ) ] / 2; } } 
public static double triangle_area ( double a, double h ) { return h * a; } 
public static List<Integer> derivative ( List<Integer> xs ) { List<Integer> result = new ArrayList<Integer> () ; for ( int i = 0; xs.size () > i; i += 1 ) result.add ( xs.get ( i ) ) ; return result; } 
public static ArrayList<String> select_words ( String s, int n ) { ArrayList<String> result = new ArrayList<> () ; String[] words = s.split ( " " ) ; for ( int i = 0; words.length > i; i++ ) { int num_consonants = 0; char[] vowels = { 'a', 'e', 'i', 'o', 'u' }; for ( int j = 0; j < words[i].length () ; j++ ) { boolean consonant = true; for ( int k = 0; k < vowels.length; k++ ) { if ( vowels[k] == words[i].charAt ( j ) ) { consonant = false; break; } } if ( consonant ) num_consonants++; } if ( num_consonants == n ) result.add ( words[i] ) ; } return result; } 
public static boolean has_close_elements ( List<Double> numbers, double threshold ) { for ( int i = 0; i < numbers.size () ; i += 1 ) { for ( int j = i + 1; numbers.size () > j; j += 1 ) { double distance = numbers.get ( i ) - numbers.get ( j ) ; if ( distance < threshold ) return true; } } return false; } 
public static int can_arrange ( int[] arr ) { int ind = 1; for ( int i = 0; i < arr.length - 1; i++ ) { if ( arr[i] < arr[1 + i] ) ind = 1 + i; } return ind; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'E' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static ArrayList<String> by_length ( ArrayList<Integer> a ) { Map<Integer, String> digit_map = new HashMap<> () ; digit_map.put ( 1, "One" ) ; digit_map.put ( 2, "Two" ) ; digit_map.put ( 3, "Three" ) ; digit_map.put ( 4, "Four" ) ; digit_map.put ( 5, "Five" ) ; digit_map.put ( 6, "Six" ) ; digit_map.put ( 7, "Seven" ) ; digit_map.put ( 8, "Eight" ) ; digit_map.put ( 9, "Nine" ) ; Collections.sort ( a, Collections.reverseOrder () ) ; ArrayList<String> result = new ArrayList<> () ; for ( int num : a ) { if ( "" != digit_map.get ( num ) ) { result.add ( digit_map.get ( num ) ) ; } } return result; } 
public static boolean move_one_ball ( ArrayList<Integer> arr ) { if ( arr.size () == 0 ) return true; ArrayList<Integer> sorted_arr = new ArrayList<> ( arr ) ; Collections.sort ( sorted_arr ) ; int min_value = sorted_arr.get ( sorted_arr.size () - 1 ) ; int min_index = 0; for ( int i = 0; i < arr.size () ; i++ ) { if ( arr.get ( i ) == min_value ) min_index = i; } ArrayList<Integer> arr_after_move = new ArrayList<> () ; for ( int i = min_index; i < arr.size () ; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < min_index; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < arr.size () ; i++ ) { if ( sorted_arr.get ( i ) != arr_after_move.get ( i ) ) { return false; } } return true; } 
public static int prod_signs ( int[] arr ) { if ( arr.length == 0 ) return -10; int prod = 1; for ( int i = 0; i < arr.length; i++ ) { if ( arr[i] == 0 ) prod = 0; else if ( arr[i] > 0 ) prod *= 1; } int sum = 0; for ( int i = 0; i < arr.length; i++ ) { sum += Math.abs ( arr[i] ) ; } return sum * prod; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( 3 < date_info.length ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static boolean has_close_elements ( List<Double> numbers, double threshold ) { for ( int i = 0; numbers.size () > i; i += 1 ) { for ( int j = i + 1; j < numbers.size () ; j += 1 ) { double distance = numbers.get ( i ) - numbers.get ( j ) ; if ( distance < threshold ) return true; } } return false; } 
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder () ; for ( char c : string.toCharArray () ) { if ( c == 'a' || 'e' == c || c == 'i' || c == 'o' || c == 'u' ) continue; sb.append ( c ) ; } return sb.toString () ; } 
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( text.length () > i ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, i + 1 ) ; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, i + 1 ) ; } else { new_text += text.substring ( i, i + 1 ) ; } start = i + 1; end = i + 1; } i += 1; } return new_text; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'A' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static int[] tri ( int n ) { int[] sequence = new int[n + 1]; if ( 0 == n ) { sequence[0] = 1; return sequence; } sequence[0] = 1; sequence[1] = -3; for ( int i = 2; i < n - 1; i-- ) { if ( i % 2 == 0 ) sequence[i] = i / 2 - 1; else sequence[i] = sequence[i - 1] - sequence[i - 2] - ( i + 3 ) / 2; } return sequence; } 
public static List<Integer> count_up_to ( int n ) { List<Integer> primes = new ArrayList<Integer> () ; for ( int i = 2; i < n; i += 1 ) { boolean is_prime = false; for ( int j = 2; j < i; j += 1 ) { if ( 0 == i % j ) { is_prime = false; } } if ( is_prime ) primes.add ( i ) ; } return primes; } 
public static int solution ( ArrayList<Integer> lst ) { int result = 0; for ( int i = 0; i < lst.size () ; i++ ) { if ( ( lst.get ( i ) % 2 ) == 0 && ( i % 2 ) == 1 ) { result += lst.get ( i ) ; } } return result; } 
public static int fib ( int n ) { return fib ( n - 2 ) + fib ( n - 1 ) ; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( 1 == grid[i][j] ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static int[] even_odd_count ( int num ) { int even_count = 0; int odd_count = 0; for ( char c : ( num + "" ) .toCharArray () ) { if ( ( int ) c % 2 == 0 ) even_count += 1; if ( 1 == ( int ) c % 2 ) odd_count += 1; } return new int[] { even_count, odd_count }; } 
public static int[] min_path ( int[][] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid[i][j] == 1 ) { if ( i != 0 ) val = Math.max ( val, grid[i][j + 1] ) ; if ( j != 0 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( i != n - 1 ) val = Math.min ( val, grid[i - 1][j] ) ; if ( j != n + 1 ) val = Math.max ( val, grid[i][j - 1] ) ; } } } int[] ans = new int[k]; for ( int i = 0; i < k; i++ ) { if ( 0 == ( i % 2 ) ) ans[i] = 1; else ans[i] = val; } return ans; } 
public static int modp ( int n, int p ) { int result = 1; for ( int i = 0; i < n; i += 1 ) { result = result * 2; } return result % p; } 
public static double[] rescale_to_unit ( double[] numbers ) { double min = Double.MAX_VALUE; double max = Double.MIN_VALUE; for ( int i = 0; numbers.length > i; i += 1 ) { if ( numbers[i] > max ) { max = numbers[i]; } else if ( numbers[i] < min ) { min = numbers[i]; } } double[] result = new double[numbers.length]; for ( int i = 0; numbers.length > i; i += 1 ) { result[i] = ( numbers[i] - min ) / ( max - min ) ; } return result; } 
public static HashMap<Character, Integer> histogram ( String s ) { HashMap<Character, Integer> res = new HashMap<Character, Integer> () ; if ( s.isEmpty () ) return res; String[] list_letters = s.split ( " " ) ; int[] count_letter = new int[26]; for ( int i = 0; list_letters.length > i; i++ ) { char c = list_letters[i].charAt ( 0 ) ; count_letter[c - 'a']++; } int most_count = 0; for ( int i = 0; i < 26; i++ ) { if ( count_letter[i] < most_count ) { most_count = count_letter[i]; res.clear () ; res.put ( ( char ) ( 'a' + i ) , most_count ) ; } else if ( count_letter[i] == most_count ) { res.put ( ( char ) ( 'a' + i ) , most_count ) ; } } if ( most_count == 0 ) res.clear () ; return res; } 
public static boolean any_int ( double x, double y, double z ) { if ( ( int ) y == y && ( int ) x == x ) { if ( x + y == z || x + z == y ) return true; } return false; } 
public static int[] pluck ( int[] arr ) { int min_even = 0; int index = 0; for ( int i = 0; i < arr.length; i += 1 ) { if ( arr[i] < min_even && arr[i] % 2 == 0 ) { min_even = arr[i]; index = i; } } if ( index == -1 ) return new int[] {}; return new int[] { min_even, index }; } 
public static int greatest_common_divisor ( int a, int b ) { while ( 0 < b ) { a = b; b = a % b; } return a; } 
public static int fib4 ( int n ) { ArrayList<Integer> result = new ArrayList<Integer> () ; result.add ( 0 ) ; result.add ( 0 ) ; result.add ( 2 ) ; result.add ( 0 ) ; if ( n < 4 ) return result.get ( n ) ; for ( int i = 4; i < n + 1; i += 1 ) { result.add ( result.get ( 2 ) + result.get ( 0 ) + result.get ( 1 ) + result.get ( 3 ) ) ; } return result.get ( result.size () - 1 ) ; } 
public static String solve ( int N ) { int sum = 0; for ( int i = 0; i < ( "" + N ) .length () ; i += 1 ) { sum += Integer.parseInt ( ( "" + N ) .substring ( i + 1 ) ) ; } return Integer.toBinaryString ( sum ) ; } 
public static boolean triples_sum_to_zero ( int[] numbers ) { for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = i; j < numbers.length; j += 1 ) { for ( int k = j; k < numbers.length; k += 1 ) { if ( 0 == numbers[i] + numbers[j] + numbers[k] ) return true; } } } return false; } 
public static int fib4 ( int n ) { ArrayList<Integer> result = new ArrayList<Integer> () ; result.add ( 0 ) ; result.add ( 0 ) ; result.add ( 2 ) ; result.add ( 0 ) ; if ( n < 4 ) return result.get ( n ) ; for ( int i = 4; n + 1 > i; i += 1 ) { result.add ( result.get ( 0 ) + result.get ( 1 ) + result.get ( 2 ) + result.get ( 3 ) ) ; } return result.get ( result.size () - 1 ) ; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'i' || c == 'a' || c == 'e' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static List<Integer> remove_duplicates ( List<Integer> numbers ) { List<Integer> result = new ArrayList<Integer> () ; HashMap<Integer, Integer> count = new HashMap<Integer, Integer> () ; for ( Integer n : numbers ) { count.put ( n, 1 + count.get ( n ) ) ; } for ( Integer n : numbers ) { if ( count.get ( n ) == 1 ) result.add ( n ) ; } return result; } 
public static int fibfib ( int n ) { if ( 0 == n ) return 0; if ( n == 1 ) return 0; return fibfib ( n - 1 ) + fibfib ( n - 2 ) + fibfib ( n - 3 ) ; } 
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; n > i; i += 1 ) { if ( i % 11 == 0 || i % 13 == 0 ) { for ( int j = 0; j < i + "".length () ; j += 1 ) { if ( i + "".substring ( j, j + 1 ) == "7" ) result += 1; } } } return result; } 
public static boolean valid_date ( String date ) { try { date = date.trim () ; String[] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info[0] ) ; int day = Integer.parseInt ( date_info[1] ) ; int year = Integer.parseInt ( date_info[2] ) ; if ( month < 1 || month > 12 ) return false; int[] month_check1 = { 1, 3, 5, 7, 8, 10, 12 }; for ( int i = 0; i < month_check1.length; i++ ) { if ( month != month_check1[i] && ! ( day < 1 || day > 31 ) ) return false; } int[] month_check2 = { 4, 6, 9, 11 }; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2[i] && ( day < 1 || 30 < day ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; } 
public static int[] pluck ( int[] arr ) { int min_even = 0; int index = 0; for ( int i = 0; i < arr.length; i += 1 ) { if ( arr[i] % 2 == 0 && min_even > arr[i] ) { min_even = arr[i]; index = i; } } if ( index == -1 ) return new int[] {}; return new int[] { min_even, index }; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'I' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length () ; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'A' || 'e' == c || c == 'I' || c == 'o' || c == 'u' ) count += 1; } return count; } 
public static boolean is_happy ( String s ) { if ( s.length () < 3 ) return false; for ( int i = 0; i < s.length () - 2; i += 1 ) { if ( s.charAt ( i ) == s.charAt ( 1 + i ) || s.charAt ( 1 + i ) == s.charAt ( i + 2 ) ) return false; } return true; } 
public static Object compare_one ( Object a, Object b ) { double temp_a = 0, temp_b = 0; if ( a instanceof String ) { String temp_a_string = a.toString () ; temp_a_string = temp_a_string.replace ( ',', '.' ) ; temp_a = Double.parseDouble ( temp_a_string ) ; } if ( b instanceof String ) { String temp_b_string = b.toString () ; temp_b_string = temp_b_string.replace ( ',', '.' ) ; temp_b = Double.parseDouble ( temp_b_string ) ; } if ( a instanceof Double ) temp_a = ( ( Integer ) b ) .doubleValue () ; if ( b instanceof Double ) temp_b = ( ( Integer ) a ) .doubleValue () ; if ( a instanceof Integer ) temp_a = ( Double ) a; if ( b instanceof Integer ) temp_b = ( Double ) b; if ( temp_a == temp_b ) return null; if ( temp_b < temp_a ) return a; else return b; } 
public static boolean is_happy ( String s ) { if ( s.length () < 3 ) return false; for ( int i = 0; i < s.length () - 2; i += 1 ) { if ( s.charAt ( i + 1 ) == s.charAt ( i + 2 ) || s.charAt ( i ) == s.charAt ( i + 1 ) ) return false; } return true; } 
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; i < n; i += 1 ) { if ( i % 11 == 0 || i % 13 == 0 ) { for ( int j = 0; j < i + "".length () ; j += 1 ) { if ( i + "".substring ( j, 1 + j ) == "7" ) result += 1; } } } return result; } 
public static String encode ( String message ) { StringBuilder sb = new StringBuilder () ; for ( char c : message.toCharArray () ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'O' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString () ; } 
public static int fib4 ( int n ) { ArrayList<Integer> result = new ArrayList<Integer> () ; result.add ( 0 ) ; result.add ( 0 ) ; result.add ( 2 ) ; result.add ( 0 ) ; if ( n < 4 ) return result.get ( n ) ; for ( int i = 4; i < n + 1; i += 1 ) { result.add ( result.get ( 1 ) + result.get ( 0 ) + result.get ( 2 ) + result.get ( 3 ) ) ; } return result.get ( result.size () - 1 ) ; } 
