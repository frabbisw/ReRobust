public static ArrayList < Object > reverse_delete ( String s, String c ) { String new_s = ""; for ( int i = 0; i < s.length ( ) ; i++ ) { if ( c.indexOf ( s.charAt ( i ) ) == -1 ) { new_s += s.charAt ( i ) ; } } String reverse_s = ""; for ( int i = new_s.length ( ) - 1; i > = 0; i-- ) { reverse_s += new_s.charAt ( i ) ; } ArrayList < Object > res = new ArrayList < > ( ) ; res.add ( new_s ) ; res.add ( reverse_s.equals ( new_s ) ) ; return res; }
public static boolean check ( String s ) { int val = 0; for ( int i = 0; i < s.length ( ) ; i++ ) { if ( s.charAt ( i ) == ' ( ' ) val++; else val--; if ( val < 0 ) return false; } return val == 0; } public static String match_parens ( String [ ] lst ) { String S1 = lst [ 0 ] + lst [ 1 ] ; String S2 = lst [ 1 ] + lst [ 0 ] ; if ( check ( S1 ) || check ( S2 ) ) return "Yes"; return "No"; }
public static int greatest_common_divisor ( int a, int b ) { while ( b > 0 ) { int tmp = a; a = b; b = tmp % b; } return a; }
public static String words_in_sentence ( String sentence ) { String result = ""; for ( String word : sentence.split ( " " ) ) { int flag = 0; if ( word.length ( ) == 1 ) flag = 1; for ( int i = 2; i < word.length ( ) ; i += 1 ) { if ( word.length ( ) % i == 0 ) flag = 1; } if ( flag == 0 || word.length ( ) == 2 ) result += word + " "; } return result.trim ( ) ; }
public static int hex_key ( String num ) { int result = 0; for ( char c : num.toCharArray ( ) ) { if ( c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' ) result += 1; } return result; }
public static int is_bored ( String S ) { String [ ] sentences = S.split ( "\\.|\\?|!" ) ; int result = 0; for ( String sentence : sentences ) { sentence = sentence.trim ( ) ; if ( sentence.length ( ) > = 2 && sentence.subSequence ( 0, 2 ) .equals ( "I " ) ) result += 1; } return result; }
public static int max_element ( List < Integer > l ) { int m = l.get ( 0 ) ; for ( Integer e : l ) { if ( e > m ) { m = e; } } return m; }
public static int add_elements ( ArrayList < Integer > arr, int k ) { int result = 0; for ( int i = 0; i < k; i++ ) { if ( Integer.toString ( arr.get ( i ) ) .length ( ) < = 2 ) { result += arr.get ( i ) ; } } return result; }
public static boolean simplify ( String x, String n ) { int a = Integer.parseInt ( x.split ( "/" ) [ 0 ] ) ; int b = Integer.parseInt ( x.split ( "/" ) [ 1 ] ) ; int c = Integer.parseInt ( n.split ( "/" ) [ 0 ] ) ; int d = Integer.parseInt ( n.split ( "/" ) [ 1 ] ) ; int numerator = a * c; int denom = b * d; if ( 1.0 * numerator / denom == ( int ) ( numerator / denom ) ) return true; return false; }
public static int sum_to_n ( int n ) { return ( n + 1 ) * n / 2; }
public static int [ ] min_path ( int [ ] [ ] grid, int k ) { int n = grid.length; int val = n * n + 1; for ( int i = 0; i < n; i++ ) { for ( int j = 0; j < n; j++ ) { if ( grid [ i ] [ j ] == 1 ) { if ( i != 0 ) val = Math.min ( val, grid [ i - 1 ] [ j ] ) ; if ( j != 0 ) val = Math.min ( val, grid [ i ] [ j - 1 ] ) ; if ( i != n - 1 ) val = Math.min ( val, grid [ i + 1 ] [ j ] ) ; if ( j != n - 1 ) val = Math.min ( val, grid [ i ] [ j + 1 ] ) ; } } } int [ ] ans = new int [ k ] ; for ( int i = 0; i < k; i++ ) { if ( ( i % 2 ) == 0 ) ans [ i ] = 1; else ans [ i ] = val; } return ans; }
public static int prod_signs ( int [ ] arr ) { if ( arr.length == 0 ) return -10; int prod = 1; for ( int i = 0; i < arr.length; i++ ) { if ( arr [ i ] == 0 ) prod = 0; else if ( arr [ i ] < 0 ) prod *= -1; } int sum = 0; for ( int i = 0; i < arr.length; i++ ) { sum += Math.abs ( arr [ i ] ) ; } return prod * sum; }
public static List < Integer > incr_list ( List < Integer > l ) { List < Integer > result = new ArrayList < Integer > ( ) ; for ( Integer n : l ) { result.add ( n + 1 ) ; } return result; }
public static boolean is_palindrome ( String text ) { for ( int i = 0; i < text.length ( ) ; i += 1 ) { if ( text.charAt ( i ) != text.charAt ( text.length ( ) - i - 1 ) ) return false; } return true; }
public static String change_base ( int x, int base ) { String result = ""; while ( x > 0 ) { result = ( x % base ) + result; x = ( int ) x / base; } return result; }
public static String encode ( String message ) { StringBuilder sb = new StringBuilder ( ) ; for ( char c : message.toCharArray ( ) ) { if ( Character.isUpperCase ( c ) ) { c = Character.toLowerCase ( c ) ; } else if ( Character.isLowerCase ( c ) ) { c = Character.toUpperCase ( c ) ; } if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) { c = ( char ) ( ( int ) c + 2 ) ; } sb.append ( c ) ; } return sb.toString ( ) ; }
public static boolean any_int ( double x, double y, double z ) { if ( ( int ) x == x && ( int ) y == y && ( int ) z == z ) { if ( x + y == z || x + z == y || y + z == x ) return true; } return false; }
public static int count_nums ( ArrayList < Integer > arr ) { int count = 0; for ( int num : arr ) { boolean neg = num < 0; if ( neg ) num *= -1; String num_string = Integer.toString ( num ) ; int sum = 0; for ( int i = 0; i < num_string.length ( ) ; i++ ) { if ( ( i == 0 ) && neg ) sum -= num_string.charAt ( i ) - '0'; else sum += num_string.charAt ( i ) - '0'; } if ( sum > 0 ) count++; } return count; }
public static ArrayList < Integer > generate_integers ( int a, int b ) { int lower = Math.max ( 2, Math.min ( a, b ) ) ; int upper = Math.min ( 8, Math.max ( a, b ) ) ; ArrayList < Integer > result = new ArrayList < Integer > ( ) ; for ( int i = lower; i < = upper; i += 1 ) { if ( i % 2 == 0 ) result.add ( i ) ; } return result; }
public static int solution ( ArrayList < Integer > lst ) { int result = 0; for ( int i = 0; i < lst.size ( ) ; i++ ) { if ( ( i % 2 ) == 0 && ( lst.get ( i ) % 2 ) == 1 ) { result += lst.get ( i ) ; } } return result; }
public static List < Integer > factorize ( int n ) { List < Integer > result = new ArrayList < Integer > ( ) ; int i = 2; while ( i < = ( int ) ( Math.sqrt ( n ) + 1 ) ) { if ( n % i == 0 ) { result.add ( i ) ; n = n / i; } else { i += 1; } } if ( n > 1 ) { result.add ( n ) ; } return result; }
public static int modp ( int n, int p ) { int result = 1; for ( int i = 0; i < n; i += 1 ) { result = ( 2 * result ) % p; } return result; }
public static double do_algebra ( String [ ] operator, int [ ] operand ) throws NumberFormatException, ScriptException { ScriptEngineManager mgr = new ScriptEngineManager ( ) ; ScriptEngine engine = mgr.getEngineByName ( "JavaScript" ) ; String expression = operand [ 0 ] + ""; for ( int i = 0; i < operator.length; i += 1 ) { expression += operator [ i ] + operand [ i + 1 ] ; } return Double.parseDouble ( engine.eval ( expression ) .toString ( ) ) ; }
public static List < Integer > get_positive ( List < Integer > numbers ) { List < Integer > result = new ArrayList < Integer > ( ) ; for ( Integer number : numbers ) { if ( number > 0 ) { result.add ( number ) ; } } return result; }
public static String circular_shift ( int x, int shift ) { String s = x + ""; if ( shift > s.length ( ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = s.length ( ) - 1; i > = 0; i -= 1 ) sb.append ( s.charAt ( i ) ) ; return sb.toString ( ) ; } else { return s.substring ( s.length ( ) - shift ) + s.substring ( 0, s.length ( ) - shift ) ; } }
public static int fruit_distribution ( String s, int n ) { int result = n; for ( String str : s.split ( " " ) ) { try { int cnt = Integer.parseInt ( str ) ; result -= cnt; } catch ( Exception e ) { continue; } } return result; }
public static List < Integer > remove_duplicates ( List < Integer > numbers ) { List < Integer > result = new ArrayList < Integer > ( ) ; HashMap < Integer, Integer > count = new HashMap < Integer, Integer > ( ) ; for ( Integer n : numbers ) { if ( ! count.containsKey ( n ) ) count.put ( n, 0 ) ; count.put ( n, count.get ( n ) + 1 ) ; } for ( Integer n : numbers ) { if ( count.get ( n ) == 1 ) result.add ( n ) ; } return result; }
public static double triangle_area ( double a, double h ) { return a * h / 2.; }
public static boolean has_close_elements ( List < Double > numbers, double threshold ) { for ( int i = 0; i < numbers.size ( ) ; i += 1 ) { for ( int j = i + 1; j < numbers.size ( ) ; j += 1 ) { double distance = Math.abs ( numbers.get ( i ) - numbers.get ( j ) ) ; if ( distance < threshold ) return true; } } return false; }
public static double poly ( List < Double > xs, double x ) { double sum = 0; for ( int i = 0; i < xs.size ( ) ; i += 1 ) { sum += xs.get ( i ) * Math.pow ( x, i ) ; } return sum; } public static double find_zero ( List < Double > xs ) { double begin = -1.; double end = 1.; while ( poly ( xs, begin ) * poly ( xs, end ) > 0 ) { begin *= 2.; end *= 2.; } while ( end - begin > 1e-10 ) { double center = ( begin + end ) / 2.; if ( poly ( xs, center ) * poly ( xs, begin ) > 0 ) { begin = center; } else { end = center; } } return begin; }
public static boolean move_one_ball ( ArrayList < Integer > arr ) { if ( arr.size ( ) == 0 ) return true; ArrayList < Integer > sorted_arr = new ArrayList < > ( arr ) ; Collections.sort ( sorted_arr ) ; int min_value = sorted_arr.get ( 0 ) ; int min_index = 0; for ( int i = 0; i < arr.size ( ) ; i++ ) { if ( arr.get ( i ) == min_value ) min_index = i; } ArrayList < Integer > arr_after_move = new ArrayList < > ( ) ; for ( int i = min_index; i < arr.size ( ) ; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < min_index; i++ ) { arr_after_move.add ( arr.get ( i ) ) ; } for ( int i = 0; i < arr.size ( ) ; i++ ) { if ( arr_after_move.get ( i ) != sorted_arr.get ( i ) ) { return false; } } return true; }
public static String string_sequence ( int n ) { String result = ""; for ( int i = 0; i < = n; i += 1 ) { result += i + " "; } return result.trim ( ) ; }
public static int count_distinct_characters ( String string ) { HashSet < Character > distinct = new HashSet < Character > ( ) ; for ( char c : string.toCharArray ( ) ) { if ( ! distinct.contains ( Character.toLowerCase ( c ) ) ) distinct.add ( Character.toLowerCase ( c ) ) ; } return distinct.size ( ) ; }
public static boolean is_prime ( int n ) { if ( n < 2 ) return false; for ( int k = 2; k < n - 1; k += 1 ) { if ( n % k == 0 ) return false; } return true; }
public static List < String > filter_by_prefix ( List < String > strings, String prefix ) { List < String > result = new ArrayList < String > ( ) ; for ( String string : strings ) { if ( string.startsWith ( prefix ) ) { result.add ( string ) ; } } return result; }
public static int fib4 ( int n ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; result.add ( 0 ) ; result.add ( 0 ) ; result.add ( 2 ) ; result.add ( 0 ) ; if ( n < 4 ) return result.get ( n ) ; for ( int i = 4; i < n + 1; i += 1 ) { result.add ( result.get ( 0 ) + result.get ( 1 ) + result.get ( 2 ) + result.get ( 3 ) ) ; result.remove ( 0 ) ; } return result.get ( result.size ( ) - 1 ) ; }
public static String string_to_md5 ( String text ) throws NoSuchAlgorithmException { if ( text.equals ( "" ) ) return null; MessageDigest md = MessageDigest.getInstance ( "MD5" ) ; md.update ( text.getBytes ( ) ) ; byte [ ] digest = md.digest ( ) ; return DatatypeConverter.printHexBinary ( digest ) .toLowerCase ( ) ; }
public static String decimal_to_binary ( int decimal ) { String result = Integer.toBinaryString ( decimal ) ; return "db" + result + "db"; }
public static List < Integer > count_up_to ( int n ) { List < Integer > primes = new ArrayList < Integer > ( ) ; for ( int i = 2; i < n; i += 1 ) { boolean is_prime = true; for ( int j = 2; j < i; j += 1 ) { if ( i % j == 0 ) { is_prime = false; break; } } if ( is_prime ) primes.add ( i ) ; } return primes; }
public static boolean cycpattern_check ( String a, String b ) { int l = b.length ( ) ; String pat = b + b; for ( int i = 0; i < a.length ( ) - l + 1; i += 1 ) { for ( int j = 0; j < l + 1; j += 1 ) { if ( a.substring ( i, i + l ) .equals ( pat.substring ( j, j + l ) ) ) return true; } } return false; }
public static boolean is_prime ( int k ) { if ( k < 2 ) return false; for ( int i = 2; i < k; i += 1 ) { if ( k % i == 0 ) return false; } return true; } public static int largest_prime_factor ( int n ) { int largest = 1; for ( int j = 2; j < n; j += 1 ) { if ( n % j == 0 && is_prime ( j ) ) { largest = j; } } return largest; }
public static ArrayList < Integer > unique_digits ( ArrayList < Integer > x ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i : x ) { int num = i; boolean all_odd = true; while ( num > 0 ) { int curr_digit = num % 10; if ( ( curr_digit % 2 ) == 0 ) { all_odd = false; break; } num /= 10; } if ( all_odd ) { res.add ( i ) ; } } Collections.sort ( res ) ; return res; }
public static int count_upper ( String s ) { int count = 0; for ( int i = 0; i < s.length ( ) ; i += 2 ) { char c = s.charAt ( i ) ; if ( c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) count += 1; } return count; }
public static String concatenate ( String [ ] strings ) { String result = ""; for ( String string : strings ) result += string; return result; }
public static int fizz_buzz ( int n ) { int result = 0; for ( int i = 0; i < n; i += 1 ) { if ( i % 11 == 0 || i % 13 == 0 ) { for ( int j = 0; j < ( i + "" ) .length ( ) ; j += 1 ) { if ( ( i + "" ) .substring ( j, j + 1 ) .equals ( "7" ) ) result += 1; } } } return result; }
public static ArrayList < String > select_words ( String s, int n ) { ArrayList < String > result = new ArrayList < > ( ) ; String [ ] words = s.split ( " " ) ; for ( int i = 0; i < words.length; i++ ) { int num_consonants = 0; char [ ] vowels = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' } ; for ( int j = 0; j < words [ i ] .length ( ) ; j++ ) { boolean consonant = true; for ( int k = 0; k < vowels.length; k++ ) { if ( vowels [ k ] == words [ i ] .charAt ( j ) ) { consonant = false; break; } } if ( consonant ) num_consonants++; } if ( num_consonants == n ) result.add ( words [ i ] ) ; } return result; }
public static String longest ( List < String > strings ) { int maxlen = 0; for ( String string : strings ) { if ( string.length ( ) > maxlen ) { maxlen = string.length ( ) ; } } for ( String string : strings ) { if ( string.length ( ) == maxlen ) { return string; } } return null; }
public static String anti_shuffle ( String s ) { String result = ""; for ( String str : s.split ( " " ) ) { char [ ] chars = str.toCharArray ( ) ; Arrays.sort ( chars ) ; result += new String ( chars ) + " "; } return result.substring ( 0, result.length ( ) - 1 ) ; }
public static String remove_vowels ( String string ) { StringBuilder sb = new StringBuilder ( ) ; for ( char c : string.toCharArray ( ) ) { char c_lower = Character.toLowerCase ( c ) ; if ( c_lower == 'a' || c_lower == 'e' || c_lower == 'i' || c_lower == 'o' || c_lower == 'u' ) continue; sb.append ( c ) ; } return sb.toString ( ) ; }
public static String solve_string ( String s ) { int flg = 0; StringBuilder sb = new StringBuilder ( ) ; for ( char c : s.toCharArray ( ) ) { if ( Character.isAlphabetic ( c ) ) { if ( Character.isLowerCase ( c ) ) sb.append ( Character.toUpperCase ( c ) ) ; else sb.append ( Character.toLowerCase ( c ) ) ; flg = 1; } else sb.append ( c ) ; } if ( flg == 0 ) { sb = new StringBuilder ( ) ; for ( int i = s.length ( ) - 1; i > = 0; i -= 1 ) sb.append ( s.charAt ( i ) ) ; } return sb.toString ( ) ; }
public static int can_arrange ( int [ ] arr ) { int ind = -1; for ( int i = 1; i < arr.length; i++ ) { if ( arr [ i ] < arr [ i - 1 ] ) ind = i; } return ind; }
public static int fib ( int n ) { if ( n == 0 || n == 1 ) return n; return fib ( n - 1 ) + fib ( n - 2 ) ; }
public static boolean below_zero ( List < Integer > operations ) { int balance = 0; for ( Integer op : operations ) { balance += op; if ( balance < 0 ) { return true; } } return false; }
public static String int_to_mini_roman ( int number ) { int [ ] num = new int [ ] { 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 } ; String [ ] sym = new String [ ] { "I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M" } ; int i = 12; String result = ""; while ( number > 0 ) { int div = ( int ) ( number / num [ i ] ) ; while ( div > 0 ) { result += sym [ i ] ; div -= 1; } number %= num [ i ] ; i -= 1; } return result.toLowerCase ( ) ; }
public static ArrayList < Integer > factorial ( int n ) { ArrayList < Integer > ret = new ArrayList < > ( ) ; for ( int i = 1; i < = n; i++ ) { if ( ( i % 2 ) == 0 ) { int x = 1; for ( int j = 1; j < = i; j++ ) x *= j; ret.add ( x ) ; } else { int x = 0; for ( int j = 1; j < = i; j++ ) x += j; ret.add ( x ) ; } } return ret; }
public static double median ( int [ ] list ) { Arrays.sort ( list ) ; if ( list.length % 2 == 1 ) { return list [ ( int ) ( list.length / 2 ) ] ; } else { return ( list [ ( int ) ( list.length / 2 ) ] + list [ ( int ) ( list.length / 2 ) - 1 ] ) / 2.; } }
public static List < Integer > sort_third ( List < Integer > l ) { List < Integer > result = new ArrayList < Integer > ( ) ; List < Integer > thirds = new ArrayList < Integer > ( ) ; for ( int i = 0; i < l.size ( ) ; i += 3 ) { thirds.add ( l.get ( i ) ) ; } Collections.sort ( thirds ) ; for ( int i = 0; i < l.size ( ) ; i += 1 ) { if ( i % 3 == 0 ) { result.add ( thirds.get ( ( int ) ( i / 3 ) ) ) ; } else { result.add ( l.get ( i ) ) ; } } return result; }
public static String [ ] numerical_letter_grade ( double [ ] grades ) { String [ ] letter_grade = new String [ grades.length ] ; for ( int i = 0; i < grades.length; i += 1 ) { double gpa = grades [ i ] ; if ( gpa == 4.0 ) letter_grade [ i ] = "A+"; else if ( gpa > 3.7 ) letter_grade [ i ] = "A"; else if ( gpa > 3.3 ) letter_grade [ i ] = "A-"; else if ( gpa > 3.0 ) letter_grade [ i ] = "B+"; else if ( gpa > 2.7 ) letter_grade [ i ] = "B"; else if ( gpa > 2.3 ) letter_grade [ i ] = "B-"; else if ( gpa > 2.0 ) letter_grade [ i ] = "C+"; else if ( gpa > 1.7 ) letter_grade [ i ] = "C"; else if ( gpa > 1.3 ) letter_grade [ i ] = "C-"; else if ( gpa > 1.0 ) letter_grade [ i ] = "D+"; else if ( gpa > 0.7 ) letter_grade [ i ] = "D"; else if ( gpa > 0.0 ) letter_grade [ i ] = "D-"; else letter_grade [ i ] = "E"; } return letter_grade; }
public static int special_filter ( int [ ] nums ) { int count = 0; ArrayList < Integer > odd_digits = new ArrayList < Integer > ( Arrays.asList ( 1, 3, 5, 7, 9 ) ) ; for ( Integer num : nums ) { if ( num > 10 ) { String number_as_string = num + ""; if ( odd_digits.contains ( number_as_string.charAt ( 0 ) - '0' ) && odd_digits.contains ( number_as_string.charAt ( number_as_string.length ( ) - 1 ) - '0' ) ) count += 1; } } return count; }
public static Integer [ ] sum_product ( List < Integer > numbers ) { Integer [ ] result = new Integer [ ] { 0, 1 } ; for ( Integer n : numbers ) { result [ 0 ] += n; result [ 1 ] *= n; } return result; }
public static Integer [ ] order_by_points ( Integer [ ] nums ) { ArrayList < Integer > digits = new ArrayList < Integer > ( ) ; HashMap < Integer, ArrayList < Integer > > digits_number = new HashMap < Integer, ArrayList < Integer > > ( ) ; for ( int i = 0; i < nums.length; i += 1 ) { int neg = 1; int n = nums [ i ] ; if ( n < 0 ) { n = -1 * n; neg = -1; } int digit = 0; for ( int j = 0; j < ( n + "" ) .toCharArray ( ) .length; j += 1 ) { if ( j == 0 ) digit += ( ( n + "" ) .toCharArray ( ) [ j ] - '0' ) * neg; else digit += ( n + "" ) .toCharArray ( ) [ j ] - '0'; } if ( ! digits.contains ( digit ) ) digits.add ( digit ) ; if ( ! digits_number.containsKey ( digit ) ) digits_number.put ( digit, new ArrayList < Integer > ( ) ) ; digits_number.get ( digit ) .add ( nums [ i ] ) ; } Collections.sort ( digits ) ; ArrayList < Integer > result = new ArrayList < Integer > ( ) ; for ( int i = 0; i < digits.size ( ) ; i += 1 ) { result.addAll ( digits_number.get ( digits.get ( i ) ) ) ; } return result.toArray ( new Integer [ ] { } ) ; }
public static int how_many_times ( String string, String substring ) { int times = 0; for ( int i = 0; i < string.length ( ) - substring.length ( ) + 1; i += 1 ) { if ( string.substring ( i, i + substring.length ( ) ) .equals ( substring ) ) { times += 1; } } return times; }
public static int closest_integer ( String value ) { if ( value.indexOf ( '.' ) > = 0 ) { while ( value.charAt ( value.length ( ) - 1 ) == '0' ) value = value.substring ( 0, value.length ( ) - 1 ) ; } double num = Double.parseDouble ( value ) ; int result = 0; if ( value.length ( ) > = 2 && value.substring ( value.length ( ) - 2 ) .equals ( ".5" ) ) { result = num > 0 ? ( int ) Math.ceil ( num ) : ( int ) Math.floor ( num ) ; } else if ( value.length ( ) > 0 ) { result = ( int ) Math.round ( num ) ; } return result; }
public static boolean is_palindrome ( int n ) { String n_str = Integer.toString ( n ) ; String n_str_rev = ""; for ( int i = n_str.length ( ) - 1; i > = 0; i-- ) { n_str_rev += n_str.substring ( i, i + 1 ) ; } return n_str.equals ( n_str_rev ) ; } public static ArrayList < Integer > even_odd_palindrome ( int n ) { int even_palindrome_count = 0, odd_palindrome_count = 0; for ( int i = 1; i < = n; i++ ) { if ( ( i % 2 ) == 1 && is_palindrome ( i ) ) odd_palindrome_count++; else if ( ( i % 2 ) == 0 && is_palindrome ( i ) ) even_palindrome_count++; } ArrayList < Integer > result = new ArrayList < > ( Arrays.asList ( even_palindrome_count, odd_palindrome_count ) ) ; return result; }
public static boolean triples_sum_to_zero ( int [ ] numbers ) { for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = i + 1; j < numbers.length; j += 1 ) { for ( int k = j + 1; k < numbers.length; k += 1 ) { if ( numbers [ i ] + numbers [ j ] + numbers [ k ] == 0 ) return true; } } } return false; }
public static int [ ] even_odd_count ( int num ) { int even_count = 0; int odd_count = 0; for ( char c : ( Math.abs ( num ) + "" ) .toCharArray ( ) ) { int n = c - '0'; if ( n % 2 == 0 ) even_count += 1; if ( n % 2 == 1 ) odd_count += 1; } return new int [ ] { even_count, odd_count } ; }
public static int add_even_at_odd ( int [ ] lst ) { int sum = 0; for ( int i = 1; i < lst.length; i += 2 ) { if ( lst [ i ] % 2 == 0 ) sum += lst [ i ] ; } return sum; }
public static boolean is_nested ( String brackets ) { ArrayList < Integer > opening_brackets = new ArrayList < > ( ) ; ArrayList < Integer > closing_brackets = new ArrayList < > ( ) ; for ( int i = 0; i < brackets.length ( ) ; i++ ) { if ( brackets.charAt ( i ) == ' [ ' ) opening_brackets.add ( i ) ; else closing_brackets.add ( i ) ; } Collections.reverse ( closing_brackets ) ; int cnt = 0, i = 0, l = closing_brackets.size ( ) ; for ( int idx : opening_brackets ) { if ( i < l && idx < closing_brackets.get ( i ) ) { i++; cnt++; } } return cnt > = 2; }
public static String decode_cyclic ( String str ) { class Cyclic { String encode_cyclic ( String s ) { ArrayList < String > groups = new ArrayList < String > ( ) ; for ( int i = 0; i < s.length ( ) - s.length ( ) % 3; i += 3 ) { groups.add ( s.substring ( i, Math.min ( s.length ( ) , i + 3 ) ) ) ; } int remain = s.length ( ) % 3; String result = ""; for ( String group : groups ) { result += group.substring ( 1 ) + group.substring ( 0, 1 ) ; } if ( remain > 0 ) { result += s.substring ( s.length ( ) - remain ) ; } return result; } } final Cyclic cyclic = new Cyclic ( ) ; return cyclic.encode_cyclic ( cyclic.encode_cyclic ( str ) ) ; }
public static double truncate_number ( double number ) { return number % 1.0; }
public static String encode_shift ( String string ) { StringBuilder sb = new StringBuilder ( ) ; for ( char c : string.toCharArray ( ) ) { c = ( char ) ( ( ( ( int ) c + 5 - ( int ) ( 'a' ) ) % 26 ) + ( int ) ( 'a' ) ) ; sb.append ( c ) ; } return sb.toString ( ) ; } public static String decode_shift ( String string ) { StringBuilder sb = new StringBuilder ( ) ; for ( char c : string.toCharArray ( ) ) { c = ( char ) ( ( ( ( int ) c + 21 - ( int ) ( 'a' ) ) % 26 ) + ( int ) ( 'a' ) ) ; sb.append ( c ) ; } return sb.toString ( ) ; }
public static int [ ] common ( int [ ] l1, int [ ] l2 ) { HashSet < Integer > common = new HashSet < Integer > ( ) ; for ( int i = 0; i < l1.length; i += 1 ) { for ( int j = 0; j < l2.length; j += 1 ) { if ( l1 [ i ] == l2 [ j ] ) common.add ( l1 [ i ] ) ; } } int [ ] result = new int [ common.size ( ) ] ; int index = 0; for ( Integer c : common ) { result [ index ] = c; index += 1; } Arrays.sort ( result ) ; return result; }
public static int largest_divisor ( int n ) { for ( int i = n - 1; i > = 1; i -= 1 ) { if ( n % i == 0 ) return i; } return 1; }
public static Object compare_one ( Object a, Object b ) { double temp_a = 0, temp_b = 0; if ( a instanceof String ) { String temp_a_string = a.toString ( ) ; temp_a_string = temp_a_string.replace ( ',', '.' ) ; temp_a = Double.parseDouble ( temp_a_string ) ; } if ( b instanceof String ) { String temp_b_string = b.toString ( ) ; temp_b_string = temp_b_string.replace ( ',', '.' ) ; temp_b = Double.parseDouble ( temp_b_string ) ; } if ( a instanceof Double ) temp_a = ( Double ) a; if ( b instanceof Double ) temp_b = ( Double ) b; if ( a instanceof Integer ) temp_a = ( ( Integer ) a ) .doubleValue ( ) ; if ( b instanceof Integer ) temp_b = ( ( Integer ) b ) .doubleValue ( ) ; if ( temp_a == temp_b ) return null; if ( temp_a > temp_b ) return a; else return b; }
public static int multiply ( int a, int b ) { return Math.abs ( a % 10 ) * Math.abs ( b % 10 ) ; }
public static int digits ( int n ) { int product = 1; int odd_count = 0; while ( n > 0 ) { int digit = n % 10; if ( digit % 2 == 1 ) { product *= digit; odd_count++; } n /= 10; } if ( odd_count == 0 ) return 0; return product; }
public static String fix_spaces ( String text ) { String new_text = ""; int i = 0; int start = 0; int end = 0; while ( i < text.length ( ) ) { if ( text.charAt ( i ) == ' ' ) end += 1; else { if ( end - start > 2 ) new_text += "-" + text.substring ( i, i + 1 ) ; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } new_text += text.substring ( i, i + 1 ) ; } else { new_text += text.substring ( i, i + 1 ) ; } start = i + 1; end = i + 1; } i += 1; } if ( end - start > 2 ) new_text += "-"; else if ( end - start > 0 ) { for ( int j = start; j < end; j += 1 ) { new_text += "_"; } } return new_text; }
public static List < Integer > unique ( List < Integer > l ) { List < Integer > result = new ArrayList < Integer > ( ) ; for ( Integer n : l ) { if ( result.contains ( n ) ) continue; result.add ( n ) ; } Collections.sort ( result ) ; return result; }
public static boolean is_equal_to_sum_even ( int n ) { return ( ( n % 2 == 0 ) && ( n > = 8 ) ) ; }
public static int [ ] sort_array ( int [ ] array ) { if ( array.length == 0 ) return array; Arrays.sort ( array ) ; if ( ( array [ 0 ] + array [ array.length - 1 ] ) % 2 == 1 ) return array; else { for ( int i = 0; i < array.length / 2; i += 1 ) { int tmp = array [ i ] ; array [ i ] = array [ array.length - i - 1 ] ; array [ array.length - i - 1 ] = tmp; } return array; } }
public static List < Integer > parse_nested_parens ( String paren_string ) { String [ ] paren_groups = paren_string.split ( " " ) ; List < Integer > result = new ArrayList < Integer > ( ) ; for ( String paren_group : paren_groups ) { int depth = 0; int max_depth = 0; for ( char c : paren_group.toCharArray ( ) ) { if ( c == ' ( ' ) { depth += 1; max_depth = Math.max ( depth, max_depth ) ; } else { depth -= 1; } } result.add ( max_depth ) ; } return result; }
public static boolean iscude ( int a ) { a = Math.abs ( a ) ; double root = Math.pow ( a, 1./3 ) ; BigDecimal bd = BigDecimal.valueOf ( root ) ; int round_root = ( int ) bd.setScale ( 0, RoundingMode.HALF_UP ) .doubleValue ( ) ; return ( ( int ) Math.pow ( round_root, 3 ) ) == a; }
public static int sum_squares ( int [ ] lst ) { int result = 0; for ( int i = 0; i < lst.length; i += 1 ) { if ( i % 3 == 0 ) result += lst [ i ] * lst [ i ] ; else if ( i % 4 == 0 ) result += lst [ i ] * lst [ i ] * lst [ i ] ; else result += lst [ i ] ; } return result; }
public static int choose_num ( int x, int y ) { if ( x > y ) return -1; if ( ( y % 2 ) == 0 ) return y; if ( x == y ) return -1; return y - 1; }
public static List < Integer > rolling_max ( List < Integer > numbers ) { List < Integer > result = new ArrayList < Integer > ( ) ; Integer running_max = null; for ( Integer n : numbers ) { if ( running_max == null ) { running_max = n; } else { running_max = Math.max ( running_max, n ) ; } result.add ( running_max ) ; } return result; }
public static long min_subarray_sum ( ArrayList < Long > nums ) { long max_sum = 0; long s = 0; for ( long num : nums ) { s += -num; if ( s < 0 ) { s = 0; } max_sum = Math.max ( s, max_sum ) ; } if ( max_sum == 0 ) { max_sum = -nums.get ( 0 ) ; for ( int i = 1; i < nums.size ( ) ; i++ ) { max_sum = Math.max ( max_sum, -nums.get ( i ) ) ; } } long min_sum = -max_sum; return min_sum; }
public static double mean_absolute_deviation ( List < Double > numbers ) { double sum = 0.; for ( Double number : numbers ) { sum += number; } double mean = sum / numbers.size ( ) ; double deviation_sum = 0.; for ( Double number : numbers ) { deviation_sum += Math.abs ( number - mean ) ; } return deviation_sum / numbers.size ( ) ; }
public static String sort_numbers ( String numbers ) { final HashMap < String, Integer > value_map = new HashMap < String, Integer > ( ) ; value_map.put ( "zero", 0 ) ; value_map.put ( "one", 1 ) ; value_map.put ( "two", 2 ) ; value_map.put ( "three", 3 ) ; value_map.put ( "four", 4 ) ; value_map.put ( "five", 5 ) ; value_map.put ( "six", 6 ) ; value_map.put ( "seven", 7 ) ; value_map.put ( "eight", 8 ) ; value_map.put ( "nine", 9 ) ; ArrayList < String > number_array = new ArrayList < String > ( Arrays.asList ( numbers.split ( " " ) ) ) ; Collections.sort ( number_array, new Comparator < String > ( ) { public int compare ( String n1, String n2 ) { return value_map.get ( n1 ) - value_map.get ( n2 ) ; } } ) ; String result = ""; for ( String number : number_array ) { result += number + " "; } return result.trim ( ) ; }
public static ArrayList < String > odd_count ( ArrayList < String > lst ) { ArrayList < String > result = new ArrayList < > ( ) ; for ( String s : lst ) { int n = 0; for ( int i = 0; i < s.length ( ) ; i++ ) { int digit = s.charAt ( i ) - '0'; if ( digit % 2 == 1 ) { n++; } } result.add ( "the number of odd elements " + n + "n the str" + n + "ng " + n + " of the " + n + "nput." ) ; } return result; }
public static ArrayList < String > sorted_list_sum ( ArrayList < String > lst ) { ArrayList < String > result = new ArrayList < String > ( ) ; for ( String str : lst ) { if ( str.length ( ) % 2 == 1 ) continue; result.add ( str ) ; } Collections.sort ( result, ( s1, s2 ) - > { if ( s1.length ( ) == s2.length ( ) ) return s1.compareTo ( s2 ) ; return s1.length ( ) - s2.length ( ) ; } ) ; return result; }
public static boolean monotonic ( int [ ] l ) { int [ ] sorted = new int [ l.length ] ; int [ ] reverse_sorted = new int [ l.length ] ; System.arraycopy ( l, 0, sorted, 0, l.length ) ; Arrays.sort ( sorted ) ; for ( int i = 0; i < l.length; i += 1 ) reverse_sorted [ i ] = sorted [ l.length - i - 1 ] ; if ( Arrays.equals ( l, sorted ) || Arrays.equals ( l, reverse_sorted ) ) return true; return false; }
public static List < String > total_match ( List < String > lst1, List < String > lst2 ) { int l1 = 0; for ( String st : lst1 ) l1 += st.length ( ) ; int l2 = 0; for ( String st : lst2 ) l2 += st.length ( ) ; if ( l1 < = l2 ) return lst1; return lst2; }
public static boolean is_palindrome ( String str ) { for ( int i = 0; i < str.length ( ) ; i += 1 ) { if ( str.charAt ( i ) != str.charAt ( str.length ( ) - 1 - i ) ) return false; } return true; } public static String make_palindrome ( String str ) { if ( str.length ( ) == 0 ) return ""; int beginning_of_suffix = 0; while ( ! is_palindrome ( str.substring ( beginning_of_suffix ) ) ) { beginning_of_suffix += 1; } String result = str; for ( int i = beginning_of_suffix - 1; i > = 0; i -= 1 ) { result += String.valueOf ( str.charAt ( i ) ) ; } return result; }
public static boolean is_prime ( int n ) { for ( int i = 2; i < ( int ) Math.pow ( n, 0.5 ) + 1; i += 1 ) { if ( n % i == 0 ) return false; } return true; } public static int skjkasdkd ( int [ ] lst ) { int max = 0; int i = 0; while ( i < lst.length ) { if ( lst [ i ] > max && is_prime ( lst [ i ] ) ) max = lst [ i ] ; i += 1; } int result = 0; for ( char c : ( max + "" ) .toCharArray ( ) ) { result += c - '0'; } return result; }
public static int max_fill ( int [ ] [ ] grid, int bucket_capacity ) { int result = 0; for ( int i = 0; i < grid.length; i++ ) { int row_capacity = 0; for ( int j = 0; j < grid [ i ] .length; j++ ) { row_capacity += grid [ i ] [ j ] ; } result += ( row_capacity + bucket_capacity - 1 ) / bucket_capacity; } return result; }
public static boolean right_angle_triangle ( int a, int b, int c ) { return a*a + b*b == c*c || b*b + c*c == a*a || c*c + a*a == b*b; }
public static String rounded_avg ( int n, int m ) { if ( m < n ) return "-1"; int summation = 0; for ( int i = n; i < m + 1; i++ ) { summation += i; } double avg = ( ( double ) summation ) / ( ( double ) ( m - n + 1 ) ) ; double rem = avg - Math.floor ( avg ) ; int avg_rounded = 0; if ( rem < = 0.5 ) { avg_rounded = ( int ) Math.floor ( avg ) ; } else { avg_rounded = ( int ) Math.ceil ( avg ) ; } return Integer.toBinaryString ( avg_rounded ) ; }
public static double [ ] rescale_to_unit ( double [ ] numbers ) { double min = Double.MAX_VALUE; double max = Double.MIN_VALUE; for ( int i = 0; i < numbers.length; i += 1 ) { if ( numbers [ i ] > max ) { max = numbers [ i ] ; } if ( numbers [ i ] < min ) { min = numbers [ i ] ; } } double [ ] result = new double [ numbers.length ] ; for ( int i = 0; i < numbers.length; i += 1 ) { result [ i ] = ( numbers [ i ] - min ) / ( max - min ) ; } return result; }
public static long sum_squared_nums ( double [ ] lst ) { int result = 0; for ( int i = 0; i < lst.length; i++ ) { result += ( Math.ceil ( lst [ i ] ) ) * ( Math.ceil ( lst [ i ] ) ) ; } return result; }
public static int [ ] sort_even ( int [ ] l ) { int [ ] result = new int [ l.length ] ; int [ ] evens = new int [ ( int ) Math.ceil ( l.length / 2. ) ] ; for ( int i = 0; i < l.length; i += 2 ) { evens [ ( int ) i / 2 ] = l [ i ] ; } Arrays.sort ( evens ) ; for ( int i = 0; i < l.length; i += 1 ) { if ( i % 2 == 0 ) { result [ i ] = evens [ ( int ) i / 2 ] ; } else { result [ i ] = l [ i ] ; } } return result; }
public static boolean is_happy ( String s ) { if ( s.length ( ) < 3 ) return false; for ( int i = 0; i < s.length ( ) - 2; i += 1 ) { if ( s.charAt ( i ) == s.charAt ( i + 1 ) || s.charAt ( i + 1 ) == s.charAt ( i + 2 ) || s.charAt ( i + 2 ) == s.charAt ( i ) ) return false; } return true; }
public static int [ ] eat ( int number, int need, int remaining ) { if ( need < = remaining ) { return new int [ ] { number + need, remaining - need } ; } else { return new int [ ] { number + remaining , 0 } ; } }
public static String get_closet_vowel ( String word ) { if ( word.length ( ) < 3 ) return ""; ArrayList < Character > vowels = new ArrayList < Character > ( Arrays.asList ( 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' ) ) ; for ( int i = word.length ( ) - 2; i > 0; i-- ) { if ( vowels.contains ( word.charAt ( i ) ) ) { if ( !vowels.contains ( word.charAt ( i + 1 ) ) && !vowels.contains ( word.charAt ( i - 1 ) ) ) { return word.substring ( i, i + 1 ) ; } } } return ""; }
public static int [ ] compare ( int [ ] game, int [ ] guess ) { int [ ] result = new int [ game.length ] ; for ( int i = 0; i < game.length; i += 1 ) { result [ i ] = Math.abs ( game [ i ] - guess [ i ] ) ; } return result; }
public static double [ ] find_closest_elements ( double [ ] numbers ) { double [ ] result = new double [ 2 ] ; double distance = Double.MAX_VALUE; for ( int i = 0; i < numbers.length; i += 1 ) { for ( int j = i + 1; j < numbers.length; j += 1 ) { double new_distance = Math.abs ( numbers [ i ] - numbers [ j ] ) ; if ( new_distance < distance ) { distance = new_distance; if ( numbers [ i ] < numbers [ j ] ) { result [ 0 ] = numbers [ i ] ; result [ 1 ] = numbers [ j ] ; } else { result [ 0 ] = numbers [ j ] ; result [ 1 ] = numbers [ i ] ; } } } } return result; }
public static int x_or_y ( int n, int x, int y ) { if ( n == 1 ) return y; for ( int i = 2; i < n; i += 1 ) { if ( n % i == 0 ) return y; } return x; }
public static int strlen ( String string ) { return string.length ( ) ; }
public static String flip_case ( String string ) { char [ ] char_list = string.toCharArray ( ) ; for ( int i = 0; i < char_list.length; i += 1 ) { char c = char_list [ i ] ; if ( Character.isLowerCase ( c ) ) { char_list [ i ] = Character.toUpperCase ( c ) ; } else { char_list [ i ] = Character.toLowerCase ( c ) ; } } return new String ( char_list ) ; }
public static String encrypt ( String s ) { StringBuilder sb = new StringBuilder ( ) ; String d = "abcdefghijklmnopqrstuvwxyz"; for ( char c : s.toCharArray ( ) ) { if ( 'a' < = c && c < = 'z' ) { sb.append ( d.charAt ( ( d.indexOf ( ( int ) c ) + 2 * 2 ) % 26 ) ) ; } else { sb.append ( c ) ; } } return sb.toString ( ) ; }
public static int [ ] largest_smallest_integers ( int [ ] lst ) { boolean negative = false, positive = false; int max_negative = Integer.MIN_VALUE, min_positive = Integer.MAX_VALUE; for ( int i = 0; i < lst.length; i++ ) { if ( lst [ i ] < 0 ) { negative = true; max_negative = Math.max ( max_negative, lst [ i ] ) ; } else if ( lst [ i ] > 0 ) { positive = true; min_positive = Math.min ( min_positive, lst [ i ] ) ; } } if ( !negative ) max_negative = 0; if ( !positive ) min_positive = 0; int [ ] result = { max_negative, min_positive } ; return result; }
public static int vowels_count ( String str ) { int result = 0; char [ ] str_chars = str.toCharArray ( ) ; for ( char c : str_chars ) { if ( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ) result += 1; } if ( str_chars [ str_chars.length - 1 ] == 'y' || str_chars [ str_chars.length - 1 ] == 'Y' ) result += 1; return result; }
public static int search ( int [ ] lst ) { int max = -1; for ( Integer i : lst ) { if ( i > max ) max = i; } int result = -1; int [ ] frq = new int [ max + 1 ] ; for ( int i = 0; i < lst.length; i += 1 ) frq [ lst [ i ] ] += 1; for ( int i = 0; i < frq.length; i += 1 ) if ( frq [ i ] > = i && frq [ i ] > 0 ) result = i; return result; }
public static List < String > all_prefixes ( String string ) { List < String > result = new ArrayList < String > ( ) ; for ( int i = 0; i < string.length ( ) ; i += 1 ) { result.add ( string.substring ( 0, i + 1 ) ) ; } return result; }
public static boolean pairs_sum_to_zero ( List < Integer > l ) { for ( int i = 0; i < l.size ( ) ; i += 1 ) { for ( int j = i + 1; j < l.size ( ) ; j += 1 ) { if ( l.get ( i ) + l.get ( j ) == 0 ) return true; } } return false; }
public static boolean will_it_fly ( int [ ] q, int w ) { int sum = 0; for ( int i = 0; i < q.length; i += 1 ) sum += q [ i ] ; if ( sum > w ) return false; int i = 0; int j = q.length - 1; while ( i < j ) { if ( q [ i ] != q [ j ] ) return false; i += 1; j -= 1; } return true; }
public static Integer next_smallest ( int [ ] lst ) { HashSet < Integer > numbers = new HashSet < Integer > ( ) ; for ( Integer n : lst ) numbers.add ( n ) ; Integer [ ] no_duplicate = numbers.toArray ( new Integer [ ] { } ) ; Arrays.sort ( no_duplicate ) ; if ( no_duplicate.length < 2 ) return null; return no_duplicate [ 1 ] ; }
public static int digit_sum ( String s ) { int result = 0; for ( char c : s.toCharArray ( ) ) { if ( 'A' < = c && c < = 'Z' ) result += ( int ) c; } return result; }
public static boolean same_chars ( String s0, String s1 ) { HashSet < Character > set0 = new HashSet < Character > ( ) ; HashSet < Character > set1 = new HashSet < Character > ( ) ; for ( char c0 : s0.toCharArray ( ) ) { set0.add ( c0 ) ; } for ( char c1 : s1.toCharArray ( ) ) { set1.add ( c1 ) ; } return set0.equals ( set1 ) ; }
public static int number_ones ( int n ) { if ( n < 0 ) n *= -1; int count = 0; while ( n > 0 ) { count += n & 1; n > > = 1; } return count; } public static ArrayList < Integer > sort_array_binary ( ArrayList < Integer > arr ) { Collections.sort ( arr, new Comparator < Integer > ( ) { @Override public int compare ( Integer o1, Integer o2 ) { int num_ones_o1 = number_ones ( o1 ) ; int num_ones_o2 = number_ones ( o2 ) ; if ( num_ones_o1 == num_ones_o2 ) { if ( o1 == o2 ) return 0; if ( o1 < o2 ) return -1; if ( o1 > o2 ) return 1; } if ( num_ones_o1 < num_ones_o2 ) return -1; else return 1; } } ) ; return arr; }
public static ArrayList < String > words_strings ( String s ) { ArrayList < String > result = new ArrayList < String > ( ) ; if ( s == null || s.isEmpty ( ) ) return result; String s_list = ""; for ( char c : s.toCharArray ( ) ) { if ( c == ',' ) { s_list += ' '; } else { s_list += c; } } String [ ] result_array = s_list.trim ( ) .split ( "\\s+" ) ; for ( String r : result_array ) { result.add ( r ) ; } return result; }
public static boolean is_prime ( int num ) { if ( num == 0 || num == 1 ) return false; if ( num == 2 ) return true; for ( int i = 2; i < = num; i++ ) { if ( ( num % i ) == 0 ) return false; } return true; } public static String intersection ( int [ ] interval1, int [ ] interval2 ) { int l = Math.max ( interval1 [ 0 ] , interval2 [ 0 ] ) ; int r = Math.min ( interval1 [ 1 ] , interval2 [ 1 ] ) ; int length = r - l; if ( length > 0 && is_prime ( length ) ) return "YES"; return "NO"; }
public static HashMap < Character, Integer > histogram ( String s ) { HashMap < Character, Integer > res = new HashMap < Character, Integer > ( ) ; if ( s.isEmpty ( ) ) return res; String [ ] list_letters = s.split ( " " ) ; int [ ] count_letter = new int [ 26 ] ; for ( int i = 0; i < list_letters.length; i++ ) { char c = list_letters [ i ] .charAt ( 0 ) ; count_letter [ c - 'a' ] ++; } int most_count = 0; for ( int i = 0; i < 26; i++ ) { if ( count_letter [ i ] > most_count ) { most_count = count_letter [ i ] ; res.clear ( ) ; res.put ( ( char ) ( 'a' + i ) , most_count ) ; } else if ( count_letter [ i ] == most_count ) { res.put ( ( char ) ( 'a' + i ) , most_count ) ; } } if ( most_count == 0 ) res.clear ( ) ; return res; }
public static boolean prime_length ( String string ) { int l = string.length ( ) ; if ( l < = 1 ) return false; for ( int i = 2; i < l; i += 1 ) { if ( l % i == 0 ) return false; } return true; }
public static String [ ] split_words ( String txt ) { if ( txt.contains ( " " ) ) { return txt.split ( " " ) ; } else if ( txt.contains ( "," ) ) { return txt.split ( "," ) ; } else { int count = 0; for ( int i = 0; i < txt.length ( ) ; i++ ) { char curr = txt.charAt ( i ) ; if ( Character.isLowerCase ( curr ) && ( ( curr - 'a' ) % 2 ) == 1 ) count++; } String [ ] result = { Integer.toString ( count ) } ; return result; } }
public static boolean is_sorted ( int [ ] lst ) { HashMap < Integer, Integer > count_num = new HashMap < > ( ) ; for ( int i = 0; i < lst.length; i++ ) { count_num.put ( lst [ i ] , 0 ) ; } for ( int i = 0; i < lst.length; i++ ) { count_num.put ( lst [ i ] , count_num.get ( lst [ i ] ) + 1 ) ; } for ( int i = 0; i < lst.length; i++ ) { if ( count_num.get ( lst [ i ] ) > 2 ) return false; } for ( int i = 0; i < lst.length - 1; i++ ) { if ( lst [ i ] > lst [ i + 1 ] ) return false; } return true; }
public static List < String > filter_by_substring ( List < String > strings, String substring ) { List < String > result = new ArrayList < String > ( ) ; for ( String string : strings ) { if ( string.contains ( substring ) ) { result.add ( string ) ; } } return result; }
public class Tuple { int x; int y; public Tuple ( int x, int y ) { this.x = x; this.y = y; } @Override public boolean equals ( Object o ) { if ( o instanceof Tuple ) { return this.x == ( ( Tuple ) o ) .x && this.y == ( ( Tuple ) o ) .y; } return false; } } public static ArrayList < Tuple > get_row ( ArrayList < ArrayList < Integer > > lst, int x ) { ArrayList < Tuple > result = new ArrayList < Tuple > ( ) ; for ( int i = 0; i < lst.size ( ) ; i += 1 ) { for ( int j = lst.get ( i ) .size ( ) - 1; j > = 0; j -= 1 ) { if ( lst.get ( i ) .get ( j ) == x ) { result.add ( new GET_ROW ( ) .new Tuple ( i, j ) ) ; } } } return result; }
public static ArrayList < Integer > make_a_pile ( int n ) { ArrayList < Integer > pile = new ArrayList < Integer > ( ) ; for ( int i = 0; i < n; i++ ) { pile.add ( n + 2 * i ) ; } return pile; }
public static boolean below_threshold ( int [ ] l, int t ) { for ( int i = 0; i < l.length; i += 1 ) { if ( l [ i ] > = t ) return false; } return true; }
public static String find_max ( String [ ] words ) { ArrayList < String > words_list = new ArrayList < String > ( Arrays.asList ( words ) ) ; Collections.sort ( words_list, ( w1, w2 ) - > { Character [ ] c1 = ( ( String ) w1 ) .chars ( ) .mapToObj ( c - > ( char ) c ) .toArray ( Character [ ] ::new ) ; HashSet < Character > s1 = new HashSet < Character > ( Arrays.asList ( c1 ) ) ; Character [ ] c2 = ( ( String ) w2 ) .chars ( ) .mapToObj ( c - > ( char ) c ) .toArray ( Character [ ] ::new ) ; HashSet < Character > s2 = new HashSet < Character > ( Arrays.asList ( c2 ) ) ; if ( s2.size ( ) != s1.size ( ) ) return s2.size ( ) - s1.size ( ) ; else return w1.compareTo ( w2 ) ; } ) ; return words_list.get ( 0 ) ; }
public static ArrayList < Integer > get_odd_collatz ( int n ) { ArrayList < Integer > result = new ArrayList < > ( ) ; if ( ( n % 2 ) == 1 ) result.add ( n ) ; while ( n > 1 ) { if ( ( n % 2 ) == 0 ) n /= 2; else n = 3 * n + 1; if ( ( n % 2 ) == 1 ) result.add ( n ) ; } Collections.sort ( result ) ; return result; }
public static int smallest_change ( int [ ] arr ) { int result = 0; for ( int i = 0; i < arr.length / 2; i += 1 ) { if ( arr [ i ] != arr [ arr.length - i - 1 ] ) result += 1; } return result; }
public static long special_factorial ( long n ) { long fact_i = 1, special_fact = 1; for ( int i = 1; i < = n; i++ ) { fact_i *= i; special_fact *= fact_i; } return special_fact; }
public static double triangle_area_2 ( double a, double b, double c ) { if ( a + b < = c || a + c < = b || b + c < = a ) return -1; double s = ( a + b + c ) / 2.; double result = Math.pow ( s * ( s - a ) * ( s - b ) * ( s - c ) , 0.5 ) ; BigDecimal bd = BigDecimal.valueOf ( result ) ; bd = bd.setScale ( 2, RoundingMode.HALF_UP ) ; return bd.doubleValue ( ) ; }
public static List < Integer > filter_integers ( List < Object > values ) { List < Integer > result = new ArrayList < Integer > ( ) ; for ( Object value : values ) { if ( value instanceof Integer ) { result.add ( ( Integer ) value ) ; } } return result; }
public static String string_xor ( String a, String b ) { String result = ""; for ( int i = 0; i < a.length ( ) ; i += 1 ) { if ( a.charAt ( i ) == b.charAt ( i ) ) { result += "0"; } else { result += "1"; } } return result; }
public static List < String > separate_paren_groups ( String paren_string ) { List < String > result = new ArrayList < String > ( ) ; String current_string = ""; int current_depth = 0; for ( char c : paren_string.toCharArray ( ) ) { if ( c == ' ( ' ) { current_depth += 1; current_string += String.valueOf ( c ) ; } else if ( c == ' ) ' ) { current_depth -= 1; current_string += String.valueOf ( c ) ; if ( current_depth == 0 ) { result.add ( current_string ) ; current_string = ""; } } } return result; }
public static boolean correct_bracketing ( String brackets ) { int depth = 0; for ( char b : brackets.toCharArray ( ) ) { if ( b == ' < ' ) depth += 1; else depth -= 1; if ( depth < 0 ) return false; } return depth == 0; }
public static int double_the_difference ( double [ ] lst ) { int result = 0; for ( Double d : lst ) { if ( ( int ) d.doubleValue ( ) == d ) { int d_int = ( int ) d.doubleValue ( ) ; if ( d_int % 2 == 1 && d_int > = 0 ) { result += d_int * d_int; } } } return result; }
public static String solve ( int N ) { int sum = 0; for ( int i = 0; i < ( N + "" ) .length ( ) ; i += 1 ) { sum += Integer.parseInt ( ( N + "" ) .substring ( i, i + 1 ) ) ; } return Integer.toBinaryString ( sum ) ; }
public static boolean check_dict_case ( HashMap < Object, Object > dict ) { if ( dict.size ( ) == 0 ) return false; else { String state = "start"; for ( Object key : dict.keySet ( ) ) { if ( ! ( key instanceof String ) ) { state = "mixed"; break; } String str_key = ( String ) key; if ( state.equals ( "start" ) ) { if ( str_key.toUpperCase ( ) .equals ( str_key ) ) state = "upper"; else if ( str_key.toLowerCase ( ) .equals ( str_key ) ) state = "lower"; else { state = "mixed"; break; } } else if ( ( state.equals ( "upper" ) && !str_key.toUpperCase ( ) .equals ( str_key ) ) || ( state.equals ( "lower" ) && !str_key.toLowerCase ( ) .equals ( str_key ) ) ) { state = "mixed"; break; } } return ( state.equals ( "upper" ) ) || ( state.equals ( "lower" ) ) ; } }
public static boolean valid_date ( String date ) { try { date = date.trim ( ) ; String [ ] date_info = date.split ( "-" ) ; if ( date_info.length > 3 ) return false; int month = Integer.parseInt ( date_info [ 0 ] ) ; int day = Integer.parseInt ( date_info [ 1 ] ) ; int year = Integer.parseInt ( date_info [ 2 ] ) ; if ( month < 1 || month > 12 ) return false; int [ ] month_check1 = { 1, 3, 5, 7, 8, 10, 12 } ; for ( int i = 0; i < month_check1.length; i++ ) { if ( month == month_check1 [ i ] && ( day < 1 || day > 31 ) ) return false; } int [ ] month_check2 = { 4, 6, 9, 11 } ; for ( int i = 0; i < month_check2.length; i++ ) { if ( month == month_check2 [ i ] && ( day < 1 || day > 30 ) ) return false; } if ( month == 2 && ( day < 1 || day > 29 ) ) return false; } catch ( Exception e ) { return false; } return true; }
public static int fibfib ( int n ) { if ( n == 0 ) return 0; if ( n == 1 ) return 0; if ( n == 2 ) return 1; return fibfib ( n - 1 ) + fibfib ( n - 2 ) + fibfib ( n - 3 ) ; }
public static String file_name_check ( String file_name ) { String [ ] lst = file_name.split ( "\\." ) ; if ( lst.length != 2 ) return "No"; if ( ! ( lst [ 1 ] .equals ( "txt" ) || lst [ 1 ] .equals ( "exe" ) || lst [ 1 ] .equals ( "dll" ) ) ) return "No"; if ( lst [ 0 ] .length ( ) == 0 ) return "No"; if ( ! ( ( 'a' < = lst [ 0 ] .charAt ( 0 ) && lst [ 0 ] .charAt ( 0 ) < = 'z' ) || ( 'A' < = lst [ 0 ] .charAt ( 0 ) && lst [ 0 ] .charAt ( 0 ) < = 'Z' ) ) ) return "No"; int digit_cnt = 0; for ( char c : file_name.toCharArray ( ) ) { if ( '0' < = c && c < = '9' ) digit_cnt += 1; } if ( digit_cnt > 3 ) return "No"; return "Yes"; }
public static ArrayList < Integer > maximum_k ( ArrayList < Integer > arr, int k ) { Collections.sort ( arr ) ; ArrayList < Integer > result = new ArrayList < > ( ) ; for ( int i = arr.size ( ) - k; i < = arr.size ( ) - 1; i++ ) { result.add ( arr.get ( i ) ) ; } return result; }
public static int starts_one_ends ( int n ) { if ( n == 1 ) return 1; return ( int ) ( ( 10 + 9 - 1 ) * Math.pow ( 10, n - 2 ) ) ; }
public static List < Integer > derivative ( List < Integer > xs ) { List < Integer > result = new ArrayList < Integer > ( ) ; for ( int i = 1; i < xs.size ( ) ; i += 1 ) result.add ( i * xs.get ( i ) ) ; return result; }
public static int [ ] pluck ( int [ ] arr ) { int min_even = Integer.MAX_VALUE; int index = -1; for ( int i = 0; i < arr.length; i += 1 ) { if ( arr [ i ] % 2 == 0 && arr [ i ] < min_even ) { min_even = arr [ i ] ; index = i; } } if ( index == -1 ) return new int [ ] { } ; return new int [ ] { min_even, index } ; }
public static boolean is_prime ( int n ) { for ( int i = 2; i < n; i += 1 ) { if ( n % i == 0 ) return false; } return true; } public static boolean is_multiply_prime ( int a ) { for ( int i = 2; i < a; i += 1 ) { if ( ! is_prime ( i ) ) continue; for ( int j = i; j < a; j += 1 ) { if ( ! is_prime ( j ) ) continue; for ( int k = j; k < a; k += 1 ) { if ( ! is_prime ( k ) ) continue; if ( i * j * k == a ) return true; } } } return false; }
public static int car_race_collision ( int n ) { return n * n; }
public static List < Integer > intersperse ( List < Integer > numbers, int delimeter ) { List < Integer > result = new ArrayList < Integer > ( ) ; if ( numbers.size ( ) == 0 ) return result; for ( int i = 0; i < numbers.size ( ) - 1; i += 1 ) { result.add ( numbers.get ( i ) ) ; result.add ( delimeter ) ; } result.add ( numbers.get ( numbers.size ( ) - 1 ) ) ; return result; }
public static String strongest_extension ( String class_name, String [ ] extensions ) { String strong = null; int val = Integer.MIN_VALUE; for ( String s : extensions ) { int CAP = 0; int SM = 0; for ( char c : s.toCharArray ( ) ) { if ( Character.toUpperCase ( c ) == c ) CAP += 1; if ( Character.toLowerCase ( c ) == c ) SM += 1; } if ( CAP - SM > val ) { val = CAP - SM; strong = s; } } return class_name + "." + strong; }
public static int get_max_triples ( int n ) { int [ ] A = new int [ n ] ; for ( int i = 1; i < = n; i += 1 ) A [ i - 1 ] = i * i - i + 1; int result = 0; for ( int i = 0; i < n-2; i += 1 ) { for ( int j = i + 1; j < n-1; j += 1 ) { for ( int k = j + 1; k < n; k += 1 ) { if ( ( A [ i ] + A [ j ] + A [ k ] ) % 3 == 0 ) result += 1; } } } return result; }
public static ArrayList < String > bf ( String planet1, String planet2 ) { ArrayList < String > planet_names = new ArrayList < String > ( Arrays.asList ( "Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune" ) ) ; ArrayList < String > result = new ArrayList < String > ( ) ; if ( ( ! planet_names.contains ( planet1 ) ) || ( ! planet_names.contains ( planet2 ) ) ) return result; int planet1_index = planet_names.indexOf ( planet1 ) ; int planet2_index = planet_names.indexOf ( planet2 ) ; if ( planet1_index < planet2_index ) { for ( int i = planet1_index + 1; i < planet2_index; i += 1 ) result.add ( planet_names.get ( i ) ) ; } else { for ( int i = planet2_index + 1; i < planet1_index; i += 1 ) result.add ( planet_names.get ( i ) ) ; } return result; }
public static boolean is_simple_power ( int x, int n ) { if ( n == 1 ) return x == 1; int power = 1; while ( power < x ) { power *= n; } return power == x; }
public static List < Integer > parse_music ( String music_string ) { HashMap < String, Integer > note_map = new HashMap < String, Integer > ( ) ; note_map.put ( "o", 4 ) ; note_map.put ( "o|", 2 ) ; note_map.put ( ".|", 1 ) ; List < Integer > result = new ArrayList < Integer > ( ) ; if ( music_string.trim ( ) .equals ( "" ) ) return result; for ( String note : music_string.split ( " " ) ) { result.add ( note_map.get ( note ) ) ; } return result; }
public static ArrayList < String > by_length ( ArrayList < Integer > a ) { Map < Integer, String > digit_map = new HashMap < > ( ) ; digit_map.put ( 1, "One" ) ; digit_map.put ( 2, "Two" ) ; digit_map.put ( 3, "Three" ) ; digit_map.put ( 4, "Four" ) ; digit_map.put ( 5, "Five" ) ; digit_map.put ( 6, "Six" ) ; digit_map.put ( 7, "Seven" ) ; digit_map.put ( 8, "Eight" ) ; digit_map.put ( 9, "Nine" ) ; Collections.sort ( a, Collections.reverseOrder ( ) ) ; ArrayList < String > result = new ArrayList < > ( ) ; for ( int num : a ) { if ( digit_map.get ( num ) != null ) { result.add ( digit_map.get ( num ) ) ; } } return result; }
public static boolean check_if_last_char_is_a_letter ( String txt ) { String [ ] parts = txt.split ( " " ) ; String last = " "; if ( parts.length != 0 ) last = parts [ parts.length - 1 ] ; if ( txt.length ( ) != 0 && txt.charAt ( txt.length ( ) - 1 ) == ' ' ) last = " "; if ( txt.length ( ) == 0 ) last = " "; int last_char_pos = Character.toLowerCase ( last.charAt ( 0 ) ) - 'a'; return ( last.length ( ) == 1 ) && ( 0 < = last_char_pos && last_char_pos < = 25 ) ; }
public static int [ ] tri ( int n ) { int [ ] sequence = new int [ n + 1 ] ; if ( n == 0 ) { sequence [ 0 ] = 1; return sequence; } sequence [ 0 ] = 1; sequence [ 1 ] = 3; for ( int i = 2; i < n + 1; i++ ) { if ( i % 2 == 0 ) sequence [ i ] = i / 2 + 1; else sequence [ i ] = sequence [ i - 1 ] + sequence [ i - 2 ] + ( i + 3 ) / 2; } return sequence; }
public static String exchange ( ArrayList < Integer > lst1, ArrayList < Integer > lst2 ) { int odd = 0, even = 0; for ( int i : lst1 ) { if ( ( i % 2 ) == 1 ) odd++; } for ( int i : lst2 ) { if ( ( i % 2 ) == 0 ) even++; } if ( even > = odd ) { return "YES"; } return "NO"; }
public static boolean is_prime ( int n ) { if ( n < 2 ) return false; for ( int i = 2; i < ( int ) Math.sqrt ( n ) + 1; i += 1 ) { if ( n % i == 0 ) return false; } return true; } public static int prime_fib ( int n ) { ArrayList < Integer > fib = new ArrayList < Integer > ( ) ; fib.add ( 0 ) ; fib.add ( 1 ) ; while ( true ) { int len = fib.size ( ) ; fib.add ( fib.get ( len - 1 ) + fib.get ( len - 2 ) ) ; if ( is_prime ( fib.get ( fib.size ( ) - 1 ) ) ) n -= 1; if ( n == 0 ) return fib.get ( fib.size ( ) - 1 ) ; } }
public static int add ( int x, int y ) { return x + y; }
public static List < Integer > strange_sort_list ( List < Integer > lst ) { List < Integer > result = new ArrayList < Integer > ( ) ; boolean switched = true; while ( lst.size ( ) > 0 ) { if ( switched ) { result.add ( Collections.min ( lst ) ) ; } else { result.add ( Collections.max ( lst ) ) ; } lst.remove ( result.get ( result.size ( ) - 1 ) ) ; switched = ( ! switched ) ; } return result; }